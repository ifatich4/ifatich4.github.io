function changeGrafikBeli(t) {
  grafikEmas2.destroy(), "1" == t ? grafikEmas2 = new Chart(ctxEmas2, config) : "2" == t ? grafikEmas2 = new Chart(ctxEmas2, config2) : "3" == t ? grafikEmas2 = new Chart(ctxEmas2, config3) : "4" == t && (grafikEmas2 = new Chart(ctxEmas2, config4))
}

function changeGrafikJual(t) {
  grafikEmas3.destroy(), "1" == t ? grafikEmas3 = new Chart(ctxEmas3, config) : "2" == t ? grafikEmas3 = new Chart(ctxEmas3, config2) : "3" == t ? grafikEmas3 = new Chart(ctxEmas3, config3) : "4" == t && (grafikEmas3 = new Chart(ctxEmas3, config4))
}! function (t, e) {
  "object" == typeof module && "object" == typeof module.exports ? module.exports = t.document ? e(t, !0) : function (t) {
    if (!t.document) throw new Error("jQuery requires a window with a document");
    return e(t)
  } : e(t)
}("undefined" != typeof window ? window : this, function (f, t) {
  function e(t, e) {
    return e.toUpperCase()
  }
  var h = [],
    d = h.slice,
    m = h.concat,
    r = h.push,
    n = h.indexOf,
    i = {},
    s = i.toString,
    g = i.hasOwnProperty,
    a = "".trim,
    v = {},
    o = "1.11.0",
    w = function (t, e) {
      return new w.fn.init(t, e)
    },
    l = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    c = /^-ms-/,
    u = /-([\da-z])/gi;

  function p(t) {
    var e = t.length,
      i = w.type(t);
    return "function" !== i && !w.isWindow(t) && (!(1 !== t.nodeType || !e) || ("array" === i || 0 === e || "number" == typeof e && 0 < e && e - 1 in t))
  }
  w.fn = w.prototype = {
    jquery: o,
    constructor: w,
    selector: "",
    length: 0,
    toArray: function () {
      return d.call(this)
    },
    get: function (t) {
      return null != t ? t < 0 ? this[t + this.length] : this[t] : d.call(this)
    },
    pushStack: function (t) {
      t = w.merge(this.constructor(), t);
      return t.prevObject = this, t.context = this.context, t
    },
    each: function (t, e) {
      return w.each(this, t, e)
    },
    map: function (i) {
      return this.pushStack(w.map(this, function (t, e) {
        return i.call(t, e, t)
      }))
    },
    slice: function () {
      return this.pushStack(d.apply(this, arguments))
    },
    first: function () {
      return this.eq(0)
    },
    last: function () {
      return this.eq(-1)
    },
    eq: function (t) {
      var e = this.length,
        t = +t + (t < 0 ? e : 0);
      return this.pushStack(0 <= t && t < e ? [this[t]] : [])
    },
    end: function () {
      return this.prevObject || this.constructor(null)
    },
    push: r,
    sort: h.sort,
    splice: h.splice
  }, w.extend = w.fn.extend = function () {
    var t, e, i, s, n, a = arguments[0] || {},
      o = 1,
      r = arguments.length,
      l = !1;
    for ("boolean" == typeof a && (l = a, a = arguments[o] || {}, o++), "object" == typeof a || w.isFunction(a) || (a = {}), o === r && (a = this, o--); o < r; o++)
      if (null != (s = arguments[o]))
        for (i in s) n = a[i], e = s[i], a !== e && (l && e && (w.isPlainObject(e) || (t = w.isArray(e))) ? (n = t ? (t = !1, n && w.isArray(n) ? n : []) : n && w.isPlainObject(n) ? n : {}, a[i] = w.extend(l, n, e)) : void 0 !== e && (a[i] = e));
    return a
  }, w.extend({
    expando: "jQuery" + (o + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function (t) {
      throw new Error(t)
    },
    noop: function () {},
    isFunction: function (t) {
      return "function" === w.type(t)
    },
    isArray: Array.isArray || function (t) {
      return "array" === w.type(t)
    },
    isWindow: function (t) {
      return null != t && t == t.window
    },
    isNumeric: function (t) {
      return 0 <= t - parseFloat(t)
    },
    isEmptyObject: function (t) {
      for (var e in t) return !1;
      return !0
    },
    isPlainObject: function (t) {
      if (!t || "object" !== w.type(t) || t.nodeType || w.isWindow(t)) return !1;
      try {
        if (t.constructor && !g.call(t, "constructor") && !g.call(t.constructor.prototype, "isPrototypeOf")) return !1
      } catch (t) {
        return !1
      }
      if (v.ownLast)
        for (var e in t) return g.call(t, e);
      for (e in t);
      return void 0 === e || g.call(t, e)
    },
    type: function (t) {
      return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? i[s.call(t)] || "object" : typeof t
    },
    globalEval: function (t) {
      t && w.trim(t) && (f.execScript || function (t) {
        f.eval.call(f, t)
      })(t)
    },
    camelCase: function (t) {
      return t.replace(c, "ms-").replace(u, e)
    },
    nodeName: function (t, e) {
      return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
    },
    each: function (t, e, i) {
      var s, n = 0,
        a = t.length,
        o = p(t);
      if (i) {
        if (o)
          for (; n < a && !1 !== (s = e.apply(t[n], i)); n++);
        else
          for (n in t)
            if (s = e.apply(t[n], i), !1 === s) break
      } else if (o)
        for (; n < a && !1 !== (s = e.call(t[n], n, t[n])); n++);
      else
        for (n in t)
          if (s = e.call(t[n], n, t[n]), !1 === s) break;
      return t
    },
    trim: a && !a.call("\ufeffÃ‚ ") ? function (t) {
      return null == t ? "" : a.call(t)
    } : function (t) {
      return null == t ? "" : (t + "").replace(l, "")
    },
    makeArray: function (t, e) {
      e = e || [];
      return null != t && (p(Object(t)) ? w.merge(e, "string" == typeof t ? [t] : t) : r.call(e, t)), e
    },
    inArray: function (t, e, i) {
      var s;
      if (e) {
        if (n) return n.call(e, t, i);
        for (s = e.length, i = i ? i < 0 ? Math.max(0, s + i) : i : 0; i < s; i++)
          if (i in e && e[i] === t) return i
      }
      return -1
    },
    merge: function (t, e) {
      for (var i = +e.length, s = 0, n = t.length; s < i;) t[n++] = e[s++];
      if (i != i)
        for (; void 0 !== e[s];) t[n++] = e[s++];
      return t.length = n, t
    },
    grep: function (t, e, i) {
      for (var s = [], n = 0, a = t.length, o = !i; n < a; n++) !e(t[n], n) != o && s.push(t[n]);
      return s
    },
    map: function (t, e, i) {
      var s, n = 0,
        a = t.length,
        o = [];
      if (p(t))
        for (; n < a; n++) null != (s = e(t[n], n, i)) && o.push(s);
      else
        for (n in t) s = e(t[n], n, i), null != s && o.push(s);
      return m.apply([], o)
    },
    guid: 1,
    proxy: function (t, e) {
      var i, s;
      return "string" == typeof e && (s = t[e], e = t, t = s), w.isFunction(t) ? (i = d.call(arguments, 2), (s = function () {
        return t.apply(e || this, i.concat(d.call(arguments)))
      }).guid = t.guid = t.guid || w.guid++, s) : void 0
    },
    now: function () {
      return +new Date
    },
    support: v
  }), w.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (t, e) {
    i["[object " + e + "]"] = e.toLowerCase()
  });
  var b = function (i) {
    var t, h, y, a, e, u, w, c, d, p, x, s, f, m, n, o, g, _ = "sizzle" + -new Date,
      v = i.document,
      C = 0,
      b = 0,
      r = it(),
      k = it(),
      l = it(),
      T = function (t, e) {
        return t === e && (d = !0), 0
      },
      D = "undefined",
      S = {}.hasOwnProperty,
      M = [],
      E = M.pop,
      A = M.push,
      P = M.push,
      I = M.slice,
      O = M.indexOf || function (t) {
        for (var e = 0, i = this.length; e < i; e++)
          if (this[e] === t) return e;
        return -1
      },
      $ = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      L = "[\\x20\\t\\r\\n\\f]",
      N = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      H = N.replace("w", "w#"),
      F = "\\[" + L + "*(" + N + ")" + L + "*(?:([*^$|!~]?=)" + L + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + H + ")|)|)" + L + "*\\]",
      z = ":(" + N + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + F.replace(3, 8) + ")*)|.*)\\)|)",
      R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"),
      B = new RegExp("^" + L + "*," + L + "*"),
      j = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),
      W = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"),
      V = new RegExp(z),
      q = new RegExp("^" + H + "$"),
      Y = {
        ID: new RegExp("^#(" + N + ")"),
        CLASS: new RegExp("^\\.(" + N + ")"),
        TAG: new RegExp("^(" + N.replace("w", "w*") + ")"),
        ATTR: new RegExp("^" + F),
        PSEUDO: new RegExp("^" + z),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + $ + ")$", "i"),
        needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
      },
      U = /^(?:input|select|textarea|button)$/i,
      X = /^h\d$/i,
      G = /^[^{]+\{\s*\[native \w/,
      K = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      Q = /[+~]/,
      J = /'|\\/g,
      Z = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"),
      tt = function (t, e, i) {
        var s = "0x" + e - 65536;
        return s != s || i ? e : s < 0 ? String.fromCharCode(65536 + s) : String.fromCharCode(s >> 10 | 55296, 1023 & s | 56320)
      };
    try {
      P.apply(M = I.call(v.childNodes), v.childNodes), M[v.childNodes.length].nodeType
    } catch (t) {
      P = {
        apply: M.length ? function (t, e) {
          A.apply(t, I.call(e))
        } : function (t, e) {
          for (var i = t.length, s = 0; t[i++] = e[s++];);
          t.length = i - 1
        }
      }
    }

    function et(t, e, i, s) {
      var n, a, o, r, l, c, d;
      if ((e ? e.ownerDocument || e : v) !== x && p(e), i = i || [], !t || "string" != typeof t) return i;
      if (1 !== (n = (e = e || x).nodeType) && 9 !== n) return [];
      if (f && !s) {
        if (c = K.exec(t))
          if (d = c[1]) {
            if (9 === n) {
              if (!(r = e.getElementById(d)) || !r.parentNode) return i;
              if (r.id === d) return i.push(r), i
            } else if (e.ownerDocument && (r = e.ownerDocument.getElementById(d)) && g(e, r) && r.id === d) return i.push(r), i
          } else {
            if (c[2]) return P.apply(i, e.getElementsByTagName(t)), i;
            if ((d = c[3]) && h.getElementsByClassName && e.getElementsByClassName) return P.apply(i, e.getElementsByClassName(d)), i
          } if (h.qsa && (!m || !m.test(t))) {
          if (l = r = _, c = e, d = 9 === n && t, 1 === n && "object" !== e.nodeName.toLowerCase()) {
            for (o = dt(t), (r = e.getAttribute("id")) ? l = r.replace(J, "\\$&") : e.setAttribute("id", l), l = "[id='" + l + "'] ", a = o.length; a--;) o[a] = l + ht(o[a]);
            c = Q.test(t) && lt(e.parentNode) || e, d = o.join(",")
          }
          if (d) try {
            return P.apply(i, c.querySelectorAll(d)), i
          } catch (t) {} finally {
            r || e.removeAttribute("id")
          }
        }
      }
      return function (t, e, i, s) {
        var n, a, o, r, l, c = dt(t);
        if (!s && 1 === c.length) {
          if (2 < (a = c[0] = c[0].slice(0)).length && "ID" === (o = a[0]).type && h.getById && 9 === e.nodeType && f && y.relative[a[1].type]) {
            if (!(e = (y.find.ID(o.matches[0].replace(Z, tt), e) || [])[0])) return i;
            t = t.slice(a.shift().value.length)
          }
          for (n = Y.needsContext.test(t) ? 0 : a.length; n-- && (o = a[n], !y.relative[r = o.type]);)
            if ((l = y.find[r]) && (s = l(o.matches[0].replace(Z, tt), Q.test(a[0].type) && lt(e.parentNode) || e))) {
              if (a.splice(n, 1), !(t = s.length && ht(a))) return P.apply(i, s), i;
              break
            }
        }
        return u(t, c)(s, e, !f, i, Q.test(t) && lt(e.parentNode) || e), i
      }(t.replace(R, "$1"), e, i, s)
    }

    function it() {
      var i = [];

      function s(t, e) {
        return i.push(t + " ") > y.cacheLength && delete s[i.shift()], s[t + " "] = e
      }
      return s
    }

    function st(t) {
      return t[_] = !0, t
    }

    function nt(t) {
      var e = x.createElement("div");
      try {
        return !!t(e)
      } catch (t) {
        return !1
      } finally {
        e.parentNode && e.parentNode.removeChild(e), e = null
      }
    }

    function at(t, e) {
      for (var i = t.split("|"), s = t.length; s--;) y.attrHandle[i[s]] = e
    }

    function ot(t, e) {
      var i = e && t,
        s = i && 1 === t.nodeType && 1 === e.nodeType && (~e.sourceIndex || 1 << 31) - (~t.sourceIndex || 1 << 31);
      if (s) return s;
      if (i)
        for (; i = i.nextSibling;)
          if (i === e) return -1;
      return t ? 1 : -1
    }

    function rt(o) {
      return st(function (a) {
        return a = +a, st(function (t, e) {
          for (var i, s = o([], t.length, a), n = s.length; n--;) t[i = s[n]] && (t[i] = !(e[i] = t[i]))
        })
      })
    }

    function lt(t) {
      return t && typeof t.getElementsByTagName !== D && t
    }
    for (t in h = et.support = {}, e = et.isXML = function (t) {
        t = t && (t.ownerDocument || t).documentElement;
        return !!t && "HTML" !== t.nodeName
      }, p = et.setDocument = function (t) {
        var l = t ? t.ownerDocument || t : v,
          t = l.defaultView;
        return l !== x && 9 === l.nodeType && l.documentElement ? (s = (x = l).documentElement, f = !e(l), t && t !== t.top && (t.addEventListener ? t.addEventListener("unload", function () {
          p()
        }, !1) : t.attachEvent && t.attachEvent("onunload", function () {
          p()
        })), h.attributes = nt(function (t) {
          return t.className = "i", !t.getAttribute("className")
        }), h.getElementsByTagName = nt(function (t) {
          return t.appendChild(l.createComment("")), !t.getElementsByTagName("*").length
        }), h.getElementsByClassName = G.test(l.getElementsByClassName) && nt(function (t) {
          return t.innerHTML = "<div class='a'></div><div class='a i'></div>", t.firstChild.className = "i", 2 === t.getElementsByClassName("i").length
        }), h.getById = nt(function (t) {
          return s.appendChild(t).id = _, !l.getElementsByName || !l.getElementsByName(_).length
        }), h.getById ? (y.find.ID = function (t, e) {
          if (typeof e.getElementById !== D && f) {
            t = e.getElementById(t);
            return t && t.parentNode ? [t] : []
          }
        }, y.filter.ID = function (t) {
          var e = t.replace(Z, tt);
          return function (t) {
            return t.getAttribute("id") === e
          }
        }) : (delete y.find.ID, y.filter.ID = function (t) {
          var e = t.replace(Z, tt);
          return function (t) {
            t = typeof t.getAttributeNode !== D && t.getAttributeNode("id");
            return t && t.value === e
          }
        }), y.find.TAG = h.getElementsByTagName ? function (t, e) {
          return typeof e.getElementsByTagName !== D ? e.getElementsByTagName(t) : void 0
        } : function (t, e) {
          var i, s = [],
            n = 0,
            a = e.getElementsByTagName(t);
          if ("*" !== t) return a;
          for (; i = a[n++];) 1 === i.nodeType && s.push(i);
          return s
        }, y.find.CLASS = h.getElementsByClassName && function (t, e) {
          return typeof e.getElementsByClassName !== D && f ? e.getElementsByClassName(t) : void 0
        }, n = [], m = [], (h.qsa = G.test(l.querySelectorAll)) && (nt(function (t) {
          t.innerHTML = "<select t=''><option selected=''></option></select>", t.querySelectorAll("[t^='']").length && m.push("[*^$]=" + L + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || m.push("\\[" + L + "*(?:value|" + $ + ")"), t.querySelectorAll(":checked").length || m.push(":checked")
        }), nt(function (t) {
          var e = l.createElement("input");
          e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && m.push("name" + L + "*[*^$|!~]?="), t.querySelectorAll(":enabled").length || m.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), m.push(",.*:")
        })), (h.matchesSelector = G.test(o = s.webkitMatchesSelector || s.mozMatchesSelector || s.oMatchesSelector || s.msMatchesSelector)) && nt(function (t) {
          h.disconnectedMatch = o.call(t, "div"), o.call(t, "[s!='']:x"), n.push("!=", z)
        }), m = m.length && new RegExp(m.join("|")), n = n.length && new RegExp(n.join("|")), t = G.test(s.compareDocumentPosition), g = t || G.test(s.contains) ? function (t, e) {
          var i = 9 === t.nodeType ? t.documentElement : t,
            e = e && e.parentNode;
          return t === e || !(!e || 1 !== e.nodeType || !(i.contains ? i.contains(e) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(e)))
        } : function (t, e) {
          if (e)
            for (; e = e.parentNode;)
              if (e === t) return !0;
          return !1
        }, T = t ? function (t, e) {
          if (t === e) return d = !0, 0;
          var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
          return i || (1 & (i = (t.ownerDocument || t) === (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !h.sortDetached && e.compareDocumentPosition(t) === i ? t === l || t.ownerDocument === v && g(v, t) ? -1 : e === l || e.ownerDocument === v && g(v, e) ? 1 : c ? O.call(c, t) - O.call(c, e) : 0 : 4 & i ? -1 : 1)
        } : function (t, e) {
          if (t === e) return d = !0, 0;
          var i, s = 0,
            n = t.parentNode,
            a = e.parentNode,
            o = [t],
            r = [e];
          if (!n || !a) return t === l ? -1 : e === l ? 1 : n ? -1 : a ? 1 : c ? O.call(c, t) - O.call(c, e) : 0;
          if (n === a) return ot(t, e);
          for (i = t; i = i.parentNode;) o.unshift(i);
          for (i = e; i = i.parentNode;) r.unshift(i);
          for (; o[s] === r[s];) s++;
          return s ? ot(o[s], r[s]) : o[s] === v ? -1 : r[s] === v ? 1 : 0
        }, l) : x
      }, et.matches = function (t, e) {
        return et(t, null, null, e)
      }, et.matchesSelector = function (t, e) {
        if ((t.ownerDocument || t) !== x && p(t), e = e.replace(W, "='$1']"), !(!h.matchesSelector || !f || n && n.test(e) || m && m.test(e))) try {
          var i = o.call(t, e);
          if (i || h.disconnectedMatch || t.document && 11 !== t.document.nodeType) return i
        } catch (t) {}
        return 0 < et(e, x, null, [t]).length
      }, et.contains = function (t, e) {
        return (t.ownerDocument || t) !== x && p(t), g(t, e)
      }, et.attr = function (t, e) {
        (t.ownerDocument || t) !== x && p(t);
        var i = y.attrHandle[e.toLowerCase()],
          i = i && S.call(y.attrHandle, e.toLowerCase()) ? i(t, e, !f) : void 0;
        return void 0 !== i ? i : h.attributes || !f ? t.getAttribute(e) : (i = t.getAttributeNode(e)) && i.specified ? i.value : null
      }, et.error = function (t) {
        throw new Error("Syntax error, unrecognized expression: " + t)
      }, et.uniqueSort = function (t) {
        var e, i = [],
          s = 0,
          n = 0;
        if (d = !h.detectDuplicates, c = !h.sortStable && t.slice(0), t.sort(T), d) {
          for (; e = t[n++];) e === t[n] && (s = i.push(n));
          for (; s--;) t.splice(i[s], 1)
        }
        return c = null, t
      }, a = et.getText = function (t) {
        var e, i = "",
          s = 0,
          n = t.nodeType;
        if (n) {
          if (1 === n || 9 === n || 11 === n) {
            if ("string" == typeof t.textContent) return t.textContent;
            for (t = t.firstChild; t; t = t.nextSibling) i += a(t)
          } else if (3 === n || 4 === n) return t.nodeValue
        } else
          for (; e = t[s++];) i += a(e);
        return i
      }, (y = et.selectors = {
        cacheLength: 50,
        createPseudo: st,
        match: Y,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: !0
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: !0
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          ATTR: function (t) {
            return t[1] = t[1].replace(Z, tt), t[3] = (t[4] || t[5] || "").replace(Z, tt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
          },
          CHILD: function (t) {
            return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || et.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && et.error(t[0]), t
          },
          PSEUDO: function (t) {
            var e, i = !t[5] && t[2];
            return Y.CHILD.test(t[0]) ? null : (t[3] && void 0 !== t[4] ? t[2] = t[4] : i && V.test(i) && (e = dt(i, !0)) && (e = i.indexOf(")", i.length - e) - i.length) && (t[0] = t[0].slice(0, e), t[2] = i.slice(0, e)), t.slice(0, 3))
          }
        },
        filter: {
          TAG: function (t) {
            var e = t.replace(Z, tt).toLowerCase();
            return "*" === t ? function () {
              return !0
            } : function (t) {
              return t.nodeName && t.nodeName.toLowerCase() === e
            }
          },
          CLASS: function (t) {
            var e = r[t + " "];
            return e || (e = new RegExp("(^|" + L + ")" + t + "(" + L + "|$)")) && r(t, function (t) {
              return e.test("string" == typeof t.className && t.className || typeof t.getAttribute !== D && t.getAttribute("class") || "")
            })
          },
          ATTR: function (e, i, s) {
            return function (t) {
              t = et.attr(t, e);
              return null == t ? "!=" === i : !i || (t += "", "=" === i ? t === s : "!=" === i ? t !== s : "^=" === i ? s && 0 === t.indexOf(s) : "*=" === i ? s && -1 < t.indexOf(s) : "$=" === i ? s && t.slice(-s.length) === s : "~=" === i ? -1 < (" " + t + " ").indexOf(s) : "|=" === i && (t === s || t.slice(0, s.length + 1) === s + "-"))
            }
          },
          CHILD: function (p, t, e, f, m) {
            var g = "nth" !== p.slice(0, 3),
              v = "last" !== p.slice(-4),
              b = "of-type" === t;
            return 1 === f && 0 === m ? function (t) {
              return !!t.parentNode
            } : function (t, e, i) {
              var s, n, a, o, r, l, c = g != v ? "nextSibling" : "previousSibling",
                d = t.parentNode,
                h = b && t.nodeName.toLowerCase(),
                u = !i && !b;
              if (d) {
                if (g) {
                  for (; c;) {
                    for (a = t; a = a[c];)
                      if (b ? a.nodeName.toLowerCase() === h : 1 === a.nodeType) return !1;
                    l = c = "only" === p && !l && "nextSibling"
                  }
                  return !0
                }
                if (l = [v ? d.firstChild : d.lastChild], v && u) {
                  for (r = (s = (n = d[_] || (d[_] = {}))[p] || [])[0] === C && s[1], o = s[0] === C && s[2], a = r && d.childNodes[r]; a = ++r && a && a[c] || (o = r = 0) || l.pop();)
                    if (1 === a.nodeType && ++o && a === t) {
                      n[p] = [C, r, o];
                      break
                    }
                } else if (u && (s = (t[_] || (t[_] = {}))[p]) && s[0] === C) o = s[1];
                else
                  for (;
                    (a = ++r && a && a[c] || (o = r = 0) || l.pop()) && ((b ? a.nodeName.toLowerCase() !== h : 1 !== a.nodeType) || !++o || (u && ((a[_] || (a[_] = {}))[p] = [C, o]), a !== t)););
                return (o -= m) === f || o % f == 0 && 0 <= o / f
              }
            }
          },
          PSEUDO: function (t, a) {
            var e, o = y.pseudos[t] || y.setFilters[t.toLowerCase()] || et.error("unsupported pseudo: " + t);
            return o[_] ? o(a) : 1 < o.length ? (e = [t, t, "", a], y.setFilters.hasOwnProperty(t.toLowerCase()) ? st(function (t, e) {
              for (var i, s = o(t, a), n = s.length; n--;) t[i = O.call(t, s[n])] = !(e[i] = s[n])
            }) : function (t) {
              return o(t, 0, e)
            }) : o
          }
        },
        pseudos: {
          not: st(function (t) {
            var s = [],
              n = [],
              r = u(t.replace(R, "$1"));
            return r[_] ? st(function (t, e, i, s) {
              for (var n, a = r(t, null, s, []), o = t.length; o--;)(n = a[o]) && (t[o] = !(e[o] = n))
            }) : function (t, e, i) {
              return s[0] = t, r(s, null, i, n), !n.pop()
            }
          }),
          has: st(function (e) {
            return function (t) {
              return 0 < et(e, t).length
            }
          }),
          contains: st(function (e) {
            return function (t) {
              return -1 < (t.textContent || t.innerText || a(t)).indexOf(e)
            }
          }),
          lang: st(function (i) {
            return q.test(i || "") || et.error("unsupported lang: " + i), i = i.replace(Z, tt).toLowerCase(),
              function (t) {
                var e;
                do {
                  if (e = f ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return (e = e.toLowerCase()) === i || 0 === e.indexOf(i + "-")
                } while ((t = t.parentNode) && 1 === t.nodeType);
                return !1
              }
          }),
          target: function (t) {
            var e = i.location && i.location.hash;
            return e && e.slice(1) === t.id
          },
          root: function (t) {
            return t === s
          },
          focus: function (t) {
            return t === x.activeElement && (!x.hasFocus || x.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
          },
          enabled: function (t) {
            return !1 === t.disabled
          },
          disabled: function (t) {
            return !0 === t.disabled
          },
          checked: function (t) {
            var e = t.nodeName.toLowerCase();
            return "input" === e && !!t.checked || "option" === e && !!t.selected
          },
          selected: function (t) {
            return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
          },
          empty: function (t) {
            for (t = t.firstChild; t; t = t.nextSibling)
              if (t.nodeType < 6) return !1;
            return !0
          },
          parent: function (t) {
            return !y.pseudos.empty(t)
          },
          header: function (t) {
            return X.test(t.nodeName)
          },
          input: function (t) {
            return U.test(t.nodeName)
          },
          button: function (t) {
            var e = t.nodeName.toLowerCase();
            return "input" === e && "button" === t.type || "button" === e
          },
          text: function (t) {
            return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (t = t.getAttribute("type")) || "text" === t.toLowerCase())
          },
          first: rt(function () {
            return [0]
          }),
          last: rt(function (t, e) {
            return [e - 1]
          }),
          eq: rt(function (t, e, i) {
            return [i < 0 ? i + e : i]
          }),
          even: rt(function (t, e) {
            for (var i = 0; i < e; i += 2) t.push(i);
            return t
          }),
          odd: rt(function (t, e) {
            for (var i = 1; i < e; i += 2) t.push(i);
            return t
          }),
          lt: rt(function (t, e, i) {
            for (var s = i < 0 ? i + e : i; 0 <= --s;) t.push(s);
            return t
          }),
          gt: rt(function (t, e, i) {
            for (var s = i < 0 ? i + e : i; ++s < e;) t.push(s);
            return t
          })
        }
      }).pseudos.nth = y.pseudos.eq, {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
      }) y.pseudos[t] = function (e) {
      return function (t) {
        return "input" === t.nodeName.toLowerCase() && t.type === e
      }
    }(t);
    for (t in {
        submit: !0,
        reset: !0
      }) y.pseudos[t] = function (i) {
      return function (t) {
        var e = t.nodeName.toLowerCase();
        return ("input" === e || "button" === e) && t.type === i
      }
    }(t);

    function ct() {}

    function dt(t, e) {
      var i, s, n, a, o, r, l, c = k[t + " "];
      if (c) return e ? 0 : c.slice(0);
      for (o = t, r = [], l = y.preFilter; o;) {
        for (a in i && !(s = B.exec(o)) || (s && (o = o.slice(s[0].length) || o), r.push(n = [])), i = !1, (s = j.exec(o)) && (i = s.shift(), n.push({
            value: i,
            type: s[0].replace(R, " ")
          }), o = o.slice(i.length)), y.filter) !(s = Y[a].exec(o)) || l[a] && !(s = l[a](s)) || (i = s.shift(), n.push({
          value: i,
          type: a,
          matches: s
        }), o = o.slice(i.length));
        if (!i) break
      }
      return e ? o.length : o ? et.error(t) : k(t, r).slice(0)
    }

    function ht(t) {
      for (var e = 0, i = t.length, s = ""; e < i; e++) s += t[e].value;
      return s
    }

    function ut(o, t, e) {
      var r = t.dir,
        l = e && "parentNode" === r,
        c = b++;
      return t.first ? function (t, e, i) {
        for (; t = t[r];)
          if (1 === t.nodeType || l) return o(t, e, i)
      } : function (t, e, i) {
        var s, n, a = [C, c];
        if (i) {
          for (; t = t[r];)
            if ((1 === t.nodeType || l) && o(t, e, i)) return !0
        } else
          for (; t = t[r];)
            if (1 === t.nodeType || l) {
              if ((s = (n = t[_] || (t[_] = {}))[r]) && s[0] === C && s[1] === c) return a[2] = s[2];
              if ((n[r] = a)[2] = o(t, e, i)) return !0
            }
      }
    }

    function pt(n) {
      return 1 < n.length ? function (t, e, i) {
        for (var s = n.length; s--;)
          if (!n[s](t, e, i)) return !1;
        return !0
      } : n[0]
    }

    function ft(t, e, i, s, n) {
      for (var a, o = [], r = 0, l = t.length, c = null != e; r < l; r++) !(a = t[r]) || i && !i(a, s, n) || (o.push(a), c && e.push(r));
      return o
    }

    function mt(p, f, m, g, v, t) {
      return g && !g[_] && (g = mt(g)), v && !v[_] && (v = mt(v, t)), st(function (t, e, i, s) {
        var n, a, o, r = [],
          l = [],
          c = e.length,
          d = t || function (t, e, i) {
            for (var s = 0, n = e.length; s < n; s++) et(t, e[s], i);
            return i
          }(f || "*", i.nodeType ? [i] : i, []),
          h = !p || !t && f ? d : ft(d, r, p, i, s),
          u = m ? v || (t ? p : c || g) ? [] : e : h;
        if (m && m(h, u, i, s), g)
          for (n = ft(u, l), g(n, [], i, s), a = n.length; a--;)(o = n[a]) && (u[l[a]] = !(h[l[a]] = o));
        if (t) {
          if (v || p) {
            if (v) {
              for (n = [], a = u.length; a--;)(o = u[a]) && n.push(h[a] = o);
              v(null, u = [], n, s)
            }
            for (a = u.length; a--;)(o = u[a]) && -1 < (n = v ? O.call(t, o) : r[a]) && (t[n] = !(e[n] = o))
          }
        } else u = ft(u === e ? u.splice(c, u.length) : u), v ? v(null, e, u, s) : P.apply(e, u)
      })
    }

    function gt(g, v) {
      function t(t, e, i, s, n) {
        var a, o, r, l = 0,
          c = "0",
          d = t && [],
          h = [],
          u = w,
          p = t || _ && y.find.TAG("*", n),
          f = C += null == u ? 1 : Math.random() || .1,
          m = p.length;
        for (n && (w = e !== x && e); c !== m && null != (a = p[c]); c++) {
          if (_ && a) {
            for (o = 0; r = g[o++];)
              if (r(a, e, i)) {
                s.push(a);
                break
              } n && (C = f)
          }
          b && ((a = !r && a) && l--, t && d.push(a))
        }
        if (l += c, b && c !== l) {
          for (o = 0; r = v[o++];) r(d, h, e, i);
          if (t) {
            if (0 < l)
              for (; c--;) d[c] || h[c] || (h[c] = E.call(s));
            h = ft(h)
          }
          P.apply(s, h), n && !t && 0 < h.length && 1 < l + v.length && et.uniqueSort(s)
        }
        return n && (C = f, w = u), d
      }
      var b = 0 < v.length,
        _ = 0 < g.length;
      return b ? st(t) : t
    }
    return ct.prototype = y.filters = y.pseudos, y.setFilters = new ct, u = et.compile = function (t, e) {
      var i, s = [],
        n = [],
        a = l[t + " "];
      if (!a) {
        for (i = (e = e || dt(t)).length; i--;)((a = function t(e) {
          for (var s, i, n, a = e.length, o = y.relative[e[0].type], r = o || y.relative[" "], l = o ? 1 : 0, c = ut(function (t) {
              return t === s
            }, r, !0), d = ut(function (t) {
              return -1 < O.call(s, t)
            }, r, !0), h = [function (t, e, i) {
              return !o && (i || e !== w) || ((s = e).nodeType ? c : d)(t, e, i)
            }]; l < a; l++)
            if (i = y.relative[e[l].type]) h = [ut(pt(h), i)];
            else {
              if ((i = y.filter[e[l].type].apply(null, e[l].matches))[_]) {
                for (n = ++l; n < a && !y.relative[e[n].type]; n++);
                return mt(1 < l && pt(h), 1 < l && ht(e.slice(0, l - 1).concat({
                  value: " " === e[l - 2].type ? "*" : ""
                })).replace(R, "$1"), i, l < n && t(e.slice(l, n)), n < a && t(e = e.slice(n)), n < a && ht(e))
              }
              h.push(i)
            } return pt(h)
        }(e[i]))[_] ? s : n).push(a);
        a = l(t, gt(n, s))
      }
      return a
    }, h.sortStable = _.split("").sort(T).join("") === _, h.detectDuplicates = !!d, p(), h.sortDetached = nt(function (t) {
      return 1 & t.compareDocumentPosition(x.createElement("div"))
    }), nt(function (t) {
      return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
    }) || at("type|href|height|width", function (t, e, i) {
      return i ? void 0 : t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
    }), h.attributes && nt(function (t) {
      return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
    }) || at("value", function (t, e, i) {
      return i || "input" !== t.nodeName.toLowerCase() ? void 0 : t.defaultValue
    }), nt(function (t) {
      return null == t.getAttribute("disabled")
    }) || at($, function (t, e, i) {
      return i ? void 0 : !0 === t[e] ? e.toLowerCase() : (e = t.getAttributeNode(e)) && e.specified ? e.value : null
    }), et
  }(f);
  w.find = b, w.expr = b.selectors, w.expr[":"] = w.expr.pseudos, w.unique = b.uniqueSort, w.text = b.getText, w.isXMLDoc = b.isXML, w.contains = b.contains;
  var _ = w.expr.match.needsContext,
    y = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    x = /^.[^:#\[\.,]*$/;

  function C(t, i, s) {
    if (w.isFunction(i)) return w.grep(t, function (t, e) {
      return !!i.call(t, e, t) !== s
    });
    if (i.nodeType) return w.grep(t, function (t) {
      return t === i !== s
    });
    if ("string" == typeof i) {
      if (x.test(i)) return w.filter(i, t, s);
      i = w.filter(i, t)
    }
    return w.grep(t, function (t) {
      return 0 <= w.inArray(t, i) !== s
    })
  }
  w.filter = function (t, e, i) {
    var s = e[0];
    return i && (t = ":not(" + t + ")"), 1 === e.length && 1 === s.nodeType ? w.find.matchesSelector(s, t) ? [s] : [] : w.find.matches(t, w.grep(e, function (t) {
      return 1 === t.nodeType
    }))
  }, w.fn.extend({
    find: function (t) {
      var e, i = [],
        s = this,
        n = s.length;
      if ("string" != typeof t) return this.pushStack(w(t).filter(function () {
        for (e = 0; e < n; e++)
          if (w.contains(s[e], this)) return !0
      }));
      for (e = 0; e < n; e++) w.find(t, s[e], i);
      return (i = this.pushStack(1 < n ? w.unique(i) : i)).selector = this.selector ? this.selector + " " + t : t, i
    },
    filter: function (t) {
      return this.pushStack(C(this, t || [], !1))
    },
    not: function (t) {
      return this.pushStack(C(this, t || [], !0))
    },
    is: function (t) {
      return !!C(this, "string" == typeof t && _.test(t) ? w(t) : t || [], !1).length
    }
  });
  var k = f.document,
    T = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/;
  (w.fn.init = function (t, e) {
    var i, s;
    if (!t) return this;
    if ("string" != typeof t) return t.nodeType ? (this.context = this[0] = t, this.length = 1, this) : w.isFunction(t) ? void 0 !== D.ready ? D.ready(t) : t(w) : (void 0 !== t.selector && (this.selector = t.selector, this.context = t.context), w.makeArray(t, this));
    if (!(i = "<" === t.charAt(0) && ">" === t.charAt(t.length - 1) && 3 <= t.length ? [null, t, null] : T.exec(t)) || !i[1] && e) return (!e || e.jquery ? e || D : this.constructor(e)).find(t);
    if (i[1]) {
      if (e = e instanceof w ? e[0] : e, w.merge(this, w.parseHTML(i[1], e && e.nodeType ? e.ownerDocument || e : k, !0)), y.test(i[1]) && w.isPlainObject(e))
        for (i in e) w.isFunction(this[i]) ? this[i](e[i]) : this.attr(i, e[i]);
      return this
    }
    if ((s = k.getElementById(i[2])) && s.parentNode) {
      if (s.id !== i[2]) return D.find(t);
      this.length = 1, this[0] = s
    }
    return this.context = k, this.selector = t, this
  }).prototype = w.fn;
  var D = w(k),
    S = /^(?:parents|prev(?:Until|All))/,
    M = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };

  function E(t, e) {
    for (;
      (t = t[e]) && 1 !== t.nodeType;);
    return t
  }
  w.extend({
    dir: function (t, e, i) {
      for (var s = [], n = t[e]; n && 9 !== n.nodeType && (void 0 === i || 1 !== n.nodeType || !w(n).is(i));) 1 === n.nodeType && s.push(n), n = n[e];
      return s
    },
    sibling: function (t, e) {
      for (var i = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && i.push(t);
      return i
    }
  }), w.fn.extend({
    has: function (t) {
      var e, i = w(t, this),
        s = i.length;
      return this.filter(function () {
        for (e = 0; e < s; e++)
          if (w.contains(this, i[e])) return !0
      })
    },
    closest: function (t, e) {
      for (var i, s = 0, n = this.length, a = [], o = _.test(t) || "string" != typeof t ? w(t, e || this.context) : 0; s < n; s++)
        for (i = this[s]; i && i !== e; i = i.parentNode)
          if (i.nodeType < 11 && (o ? -1 < o.index(i) : 1 === i.nodeType && w.find.matchesSelector(i, t))) {
            a.push(i);
            break
          } return this.pushStack(1 < a.length ? w.unique(a) : a)
    },
    index: function (t) {
      return t ? "string" == typeof t ? w.inArray(this[0], w(t)) : w.inArray(t.jquery ? t[0] : t, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
    },
    add: function (t, e) {
      return this.pushStack(w.unique(w.merge(this.get(), w(t, e))))
    },
    addBack: function (t) {
      return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
    }
  }), w.each({
    parent: function (t) {
      t = t.parentNode;
      return t && 11 !== t.nodeType ? t : null
    },
    parents: function (t) {
      return w.dir(t, "parentNode")
    },
    parentsUntil: function (t, e, i) {
      return w.dir(t, "parentNode", i)
    },
    next: function (t) {
      return E(t, "nextSibling")
    },
    prev: function (t) {
      return E(t, "previousSibling")
    },
    nextAll: function (t) {
      return w.dir(t, "nextSibling")
    },
    prevAll: function (t) {
      return w.dir(t, "previousSibling")
    },
    nextUntil: function (t, e, i) {
      return w.dir(t, "nextSibling", i)
    },
    prevUntil: function (t, e, i) {
      return w.dir(t, "previousSibling", i)
    },
    siblings: function (t) {
      return w.sibling((t.parentNode || {}).firstChild, t)
    },
    children: function (t) {
      return w.sibling(t.firstChild)
    },
    contents: function (t) {
      return w.nodeName(t, "iframe") ? t.contentDocument || t.contentWindow.document : w.merge([], t.childNodes)
    }
  }, function (s, n) {
    w.fn[s] = function (t, e) {
      var i = w.map(this, n, t);
      return (e = "Until" !== s.slice(-5) ? t : e) && "string" == typeof e && (i = w.filter(e, i)), 1 < this.length && (M[s] || (i = w.unique(i)), S.test(s) && (i = i.reverse())), this.pushStack(i)
    }
  });
  var A, P = /\S+/g,
    I = {};

  function O() {
    k.addEventListener ? (k.removeEventListener("DOMContentLoaded", $, !1), f.removeEventListener("load", $, !1)) : (k.detachEvent("onreadystatechange", $), f.detachEvent("onload", $))
  }

  function $() {
    !k.addEventListener && "load" !== event.type && "complete" !== k.readyState || (O(), w.ready())
  }
  w.Callbacks = function (n) {
    var t, i;
    n = "string" == typeof n ? I[n] || (i = I[t = n] = {}, w.each(t.match(P) || [], function (t, e) {
      i[e] = !0
    }), i) : w.extend({}, n);
    var s, e, a, o, r, l, c = [],
      d = !n.once && [],
      h = function (t) {
        for (e = n.memory && t, a = !0, r = l || 0, l = 0, o = c.length, s = !0; c && r < o; r++)
          if (!1 === c[r].apply(t[0], t[1]) && n.stopOnFalse) {
            e = !1;
            break
          } s = !1, c && (d ? d.length && h(d.shift()) : e ? c = [] : u.disable())
      },
      u = {
        add: function () {
          var t;
          return c && (t = c.length, function s(t) {
            w.each(t, function (t, e) {
              var i = w.type(e);
              "function" === i ? n.unique && u.has(e) || c.push(e) : e && e.length && "string" !== i && s(e)
            })
          }(arguments), s ? o = c.length : e && (l = t, h(e))), this
        },
        remove: function () {
          return c && w.each(arguments, function (t, e) {
            for (var i; - 1 < (i = w.inArray(e, c, i));) c.splice(i, 1), s && (i <= o && o--, i <= r && r--)
          }), this
        },
        has: function (t) {
          return t ? -1 < w.inArray(t, c) : !(!c || !c.length)
        },
        empty: function () {
          return c = [], o = 0, this
        },
        disable: function () {
          return c = d = e = void 0, this
        },
        disabled: function () {
          return !c
        },
        lock: function () {
          return d = void 0, e || u.disable(), this
        },
        locked: function () {
          return !d
        },
        fireWith: function (t, e) {
          return !c || a && !d || (e = [t, (e = e || []).slice ? e.slice() : e], s ? d.push(e) : h(e)), this
        },
        fire: function () {
          return u.fireWith(this, arguments), this
        },
        fired: function () {
          return !!a
        }
      };
    return u
  }, w.extend({
    Deferred: function (t) {
      var a = [
          ["resolve", "done", w.Callbacks("once memory"), "resolved"],
          ["reject", "fail", w.Callbacks("once memory"), "rejected"],
          ["notify", "progress", w.Callbacks("memory")]
        ],
        n = "pending",
        o = {
          state: function () {
            return n
          },
          always: function () {
            return r.done(arguments).fail(arguments), this
          },
          then: function () {
            var n = arguments;
            return w.Deferred(function (s) {
              w.each(a, function (t, e) {
                var i = w.isFunction(n[t]) && n[t];
                r[e[1]](function () {
                  var t = i && i.apply(this, arguments);
                  t && w.isFunction(t.promise) ? t.promise().done(s.resolve).fail(s.reject).progress(s.notify) : s[e[0] + "With"](this === o ? s.promise() : this, i ? [t] : arguments)
                })
              }), n = null
            }).promise()
          },
          promise: function (t) {
            return null != t ? w.extend(t, o) : o
          }
        },
        r = {};
      return o.pipe = o.then, w.each(a, function (t, e) {
        var i = e[2],
          s = e[3];
        o[e[1]] = i.add, s && i.add(function () {
          n = s
        }, a[1 ^ t][2].disable, a[2][2].lock), r[e[0]] = function () {
          return r[e[0] + "With"](this === r ? o : this, arguments), this
        }, r[e[0] + "With"] = i.fireWith
      }), o.promise(r), t && t.call(r, r), r
    },
    when: function (t) {
      function e(e, i, s) {
        return function (t) {
          i[e] = this, s[e] = 1 < arguments.length ? d.call(arguments) : t, s === n ? c.notifyWith(i, s) : --l || c.resolveWith(i, s)
        }
      }
      var n, i, s, a = 0,
        o = d.call(arguments),
        r = o.length,
        l = 1 !== r || t && w.isFunction(t.promise) ? r : 0,
        c = 1 === l ? t : w.Deferred();
      if (1 < r)
        for (n = new Array(r), i = new Array(r), s = new Array(r); a < r; a++) o[a] && w.isFunction(o[a].promise) ? o[a].promise().done(e(a, s, o)).fail(c.reject).progress(e(a, i, n)) : --l;
      return l || c.resolveWith(s, o), c.promise()
    }
  }), w.fn.ready = function (t) {
    return w.ready.promise().done(t), this
  }, w.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function (t) {
      t ? w.readyWait++ : w.ready(!0)
    },
    ready: function (t) {
      if (!0 === t ? !--w.readyWait : !w.isReady) {
        if (!k.body) return setTimeout(w.ready);
        (w.isReady = !0) !== t && 0 < --w.readyWait || (A.resolveWith(k, [w]), w.fn.trigger && w(k).trigger("ready").off("ready"))
      }
    }
  }), w.ready.promise = function (t) {
    if (!A)
      if (A = w.Deferred(), "complete" === k.readyState) setTimeout(w.ready);
      else if (k.addEventListener) k.addEventListener("DOMContentLoaded", $, !1), f.addEventListener("load", $, !1);
    else {
      k.attachEvent("onreadystatechange", $), f.attachEvent("onload", $);
      var i = !1;
      try {
        i = null == f.frameElement && k.documentElement
      } catch (t) {}
      i && i.doScroll && ! function e() {
        if (!w.isReady) {
          try {
            i.doScroll("left")
          } catch (t) {
            return setTimeout(e, 50)
          }
          O(), w.ready()
        }
      }()
    }
    return A.promise(t)
  };
  var L, N = "undefined";
  for (L in w(v)) break;
  v.ownLast = "0" !== L, v.inlineBlockNeedsLayout = !1, w(function () {
      var t, e, i = k.getElementsByTagName("body")[0];
      i && ((t = k.createElement("div")).style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", e = k.createElement("div"), i.appendChild(t).appendChild(e), typeof e.style.zoom !== N && (e.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1", (v.inlineBlockNeedsLayout = 3 === e.offsetWidth) && (i.style.zoom = 1)), i.removeChild(t), t = e = null)
    }),
    function () {
      var t = k.createElement("div");
      if (null == v.deleteExpando) {
        v.deleteExpando = !0;
        try {
          delete t.test
        } catch (t) {
          v.deleteExpando = !1
        }
      }
      t = null
    }(), w.acceptData = function (t) {
      var e = w.noData[(t.nodeName + " ").toLowerCase()],
        i = +t.nodeType || 1;
      return (1 === i || 9 === i) && (!e || !0 !== e && t.getAttribute("classid") === e)
    };
  var H = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    F = /([A-Z])/g;

  function z(t, e, i) {
    if (void 0 === i && 1 === t.nodeType) {
      var s = "data-" + e.replace(F, "-$1").toLowerCase();
      if ("string" == typeof (i = t.getAttribute(s))) {
        try {
          i = "true" === i || "false" !== i && ("null" === i ? null : +i + "" === i ? +i : H.test(i) ? w.parseJSON(i) : i)
        } catch (t) {}
        w.data(t, e, i)
      } else i = void 0
    }
    return i
  }

  function R(t) {
    for (var e in t)
      if (("data" !== e || !w.isEmptyObject(t[e])) && "toJSON" !== e) return;
    return 1
  }

  function B(t, e, i, s) {
    if (w.acceptData(t)) {
      var n, a = w.expando,
        o = t.nodeType,
        r = o ? w.cache : t,
        l = o ? t[a] : t[a] && a;
      if (l && r[l] && (s || r[l].data) || void 0 !== i || "string" != typeof e) return r[l = l || (o ? t[a] = h.pop() || w.guid++ : a)] || (r[l] = o ? {} : {
        toJSON: w.noop
      }), "object" != typeof e && "function" != typeof e || (s ? r[l] = w.extend(r[l], e) : r[l].data = w.extend(r[l].data, e)), l = r[l], s || (l.data || (l.data = {}), l = l.data), void 0 !== i && (l[w.camelCase(e)] = i), "string" == typeof e ? null == (n = l[e]) && (n = l[w.camelCase(e)]) : n = l, n
    }
  }

  function j(t, e, i) {
    if (w.acceptData(t)) {
      var s, n, a = t.nodeType,
        o = a ? w.cache : t,
        r = a ? t[w.expando] : w.expando;
      if (o[r]) {
        if (e && (s = i ? o[r] : o[r].data)) {
          n = (e = w.isArray(e) ? e.concat(w.map(e, w.camelCase)) : e in s ? [e] : (e = w.camelCase(e)) in s ? [e] : e.split(" ")).length;
          for (; n--;) delete s[e[n]];
          if (i ? !R(s) : !w.isEmptyObject(s)) return
        }(i || (delete o[r].data, R(o[r]))) && (a ? w.cleanData([t], !0) : v.deleteExpando || o != o.window ? delete o[r] : o[r] = null)
      }
    }
  }
  w.extend({
    cache: {},
    noData: {
      "applet ": !0,
      "embed ": !0,
      "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
    },
    hasData: function (t) {
      return !!(t = t.nodeType ? w.cache[t[w.expando]] : t[w.expando]) && !R(t)
    },
    data: function (t, e, i) {
      return B(t, e, i)
    },
    removeData: function (t, e) {
      return j(t, e)
    },
    _data: function (t, e, i) {
      return B(t, e, i, !0)
    },
    _removeData: function (t, e) {
      return j(t, e, !0)
    }
  }), w.fn.extend({
    data: function (t, e) {
      var i, s, n, a = this[0],
        o = a && a.attributes;
      if (void 0 !== t) return "object" == typeof t ? this.each(function () {
        w.data(this, t)
      }) : 1 < arguments.length ? this.each(function () {
        w.data(this, t, e)
      }) : a ? z(a, t, w.data(a, t)) : void 0;
      if (this.length && (n = w.data(a), 1 === a.nodeType && !w._data(a, "parsedAttrs"))) {
        for (i = o.length; i--;) 0 === (s = o[i].name).indexOf("data-") && z(a, s = w.camelCase(s.slice(5)), n[s]);
        w._data(a, "parsedAttrs", !0)
      }
      return n
    },
    removeData: function (t) {
      return this.each(function () {
        w.removeData(this, t)
      })
    }
  }), w.extend({
    queue: function (t, e, i) {
      var s;
      return t ? (s = w._data(t, e = (e || "fx") + "queue"), i && (!s || w.isArray(i) ? s = w._data(t, e, w.makeArray(i)) : s.push(i)), s || []) : void 0
    },
    dequeue: function (t, e) {
      e = e || "fx";
      var i = w.queue(t, e),
        s = i.length,
        n = i.shift(),
        a = w._queueHooks(t, e);
      "inprogress" === n && (n = i.shift(), s--), n && ("fx" === e && i.unshift("inprogress"), delete a.stop, n.call(t, function () {
        w.dequeue(t, e)
      }, a)), !s && a && a.empty.fire()
    },
    _queueHooks: function (t, e) {
      var i = e + "queueHooks";
      return w._data(t, i) || w._data(t, i, {
        empty: w.Callbacks("once memory").add(function () {
          w._removeData(t, e + "queue"), w._removeData(t, i)
        })
      })
    }
  }), w.fn.extend({
    queue: function (e, i) {
      var t = 2;
      return "string" != typeof e && (i = e, e = "fx", t--), arguments.length < t ? w.queue(this[0], e) : void 0 === i ? this : this.each(function () {
        var t = w.queue(this, e, i);
        w._queueHooks(this, e), "fx" === e && "inprogress" !== t[0] && w.dequeue(this, e)
      })
    },
    dequeue: function (t) {
      return this.each(function () {
        w.dequeue(this, t)
      })
    },
    clearQueue: function (t) {
      return this.queue(t || "fx", [])
    },
    promise: function (t, e) {
      function i() {
        --n || a.resolveWith(o, [o])
      }
      var s, n = 1,
        a = w.Deferred(),
        o = this,
        r = this.length;
      for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; r--;)(s = w._data(o[r], t + "queueHooks")) && s.empty && (n++, s.empty.add(i));
      return i(), a.promise(e)
    }
  });

  function W(t, e) {
    return "none" === w.css(t = e || t, "display") || !w.contains(t.ownerDocument, t)
  }
  var V = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    q = ["Top", "Right", "Bottom", "Left"],
    Y = w.access = function (t, e, i, s, n, a, o) {
      var r = 0,
        l = t.length,
        c = null == i;
      if ("object" === w.type(i))
        for (r in n = !0, i) w.access(t, e, r, i[r], !0, a, o);
      else if (void 0 !== s && (n = !0, w.isFunction(s) || (o = !0), e = c ? o ? (e.call(t, s), null) : (c = e, function (t, e, i) {
          return c.call(w(t), i)
        }) : e))
        for (; r < l; r++) e(t[r], i, o ? s : s.call(t[r], r, e(t[r], i)));
      return n ? t : c ? e.call(t) : l ? e(t[0], i) : a
    },
    U = /^(?:checkbox|radio)$/i;
  ! function () {
    var t = k.createDocumentFragment(),
      e = k.createElement("div"),
      i = k.createElement("input");
    if (e.setAttribute("className", "t"), e.innerHTML = "  <link/><table></table><a href='/a'>a</a>", v.leadingWhitespace = 3 === e.firstChild.nodeType, v.tbody = !e.getElementsByTagName("tbody").length, v.htmlSerialize = !!e.getElementsByTagName("link").length, v.html5Clone = "<:nav></:nav>" !== k.createElement("nav").cloneNode(!0).outerHTML, i.type = "checkbox", i.checked = !0, t.appendChild(i), v.appendChecked = i.checked, e.innerHTML = "<textarea>x</textarea>", v.noCloneChecked = !!e.cloneNode(!0).lastChild.defaultValue, t.appendChild(e), e.innerHTML = "<input type='radio' checked='checked' name='t'/>", v.checkClone = e.cloneNode(!0).cloneNode(!0).lastChild.checked, v.noCloneEvent = !0, e.attachEvent && (e.attachEvent("onclick", function () {
        v.noCloneEvent = !1
      }), e.cloneNode(!0).click()), null == v.deleteExpando) {
      v.deleteExpando = !0;
      try {
        delete e.test
      } catch (t) {
        v.deleteExpando = !1
      }
    }
    t = e = i = null
  }(),
  function () {
    var t, e, i = k.createElement("div");
    for (t in {
        submit: !0,
        change: !0,
        focusin: !0
      }) e = "on" + t, (v[t + "Bubbles"] = e in f) || (i.setAttribute(e, "t"), v[t + "Bubbles"] = !1 === i.attributes[e].expando);
    i = null
  }();
  var X = /^(?:input|select|textarea)$/i,
    G = /^key/,
    K = /^(?:mouse|contextmenu)|click/,
    Q = /^(?:focusinfocus|focusoutblur)$/,
    J = /^([^.]*)(?:\.(.+)|)$/;

  function Z() {
    return !0
  }

  function tt() {
    return !1
  }

  function et() {
    try {
      return k.activeElement
    } catch (t) {}
  }

  function it(t) {
    var e = st.split("|"),
      i = t.createDocumentFragment();
    if (i.createElement)
      for (; e.length;) i.createElement(e.pop());
    return i
  }
  w.event = {
    global: {},
    add: function (t, e, i, s, n) {
      var a, o, r, l, c, d, h, u, p, f = w._data(t);
      if (f) {
        for (i.handler && (i = (r = i).handler, n = r.selector), i.guid || (i.guid = w.guid++), (a = f.events) || (a = f.events = {}), (c = f.handle) || ((c = f.handle = function (t) {
            return typeof w === N || t && w.event.triggered === t.type ? void 0 : w.event.dispatch.apply(c.elem, arguments)
          }).elem = t), o = (e = (e || "").match(P) || [""]).length; o--;) h = p = (d = J.exec(e[o]) || [])[1], u = (d[2] || "").split(".").sort(), h && (l = w.event.special[h] || {}, h = (n ? l.delegateType : l.bindType) || h, l = w.event.special[h] || {}, d = w.extend({
          type: h,
          origType: p,
          data: s,
          handler: i,
          guid: i.guid,
          selector: n,
          needsContext: n && w.expr.match.needsContext.test(n),
          namespace: u.join(".")
        }, r), (p = a[h]) || ((p = a[h] = []).delegateCount = 0, l.setup && !1 !== l.setup.call(t, s, u, c) || (t.addEventListener ? t.addEventListener(h, c, !1) : t.attachEvent && t.attachEvent("on" + h, c))), l.add && (l.add.call(t, d), d.handler.guid || (d.handler.guid = i.guid)), n ? p.splice(p.delegateCount++, 0, d) : p.push(d), w.event.global[h] = !0);
        t = null
      }
    },
    remove: function (t, e, i, s, n) {
      var a, o, r, l, c, d, h, u, p, f, m, g = w.hasData(t) && w._data(t);
      if (g && (d = g.events)) {
        for (c = (e = (e || "").match(P) || [""]).length; c--;)
          if (p = m = (r = J.exec(e[c]) || [])[1], f = (r[2] || "").split(".").sort(), p) {
            for (h = w.event.special[p] || {}, u = d[p = (s ? h.delegateType : h.bindType) || p] || [], r = r[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), l = a = u.length; a--;) o = u[a], !n && m !== o.origType || i && i.guid !== o.guid || r && !r.test(o.namespace) || s && s !== o.selector && ("**" !== s || !o.selector) || (u.splice(a, 1), o.selector && u.delegateCount--, h.remove && h.remove.call(t, o));
            l && !u.length && (h.teardown && !1 !== h.teardown.call(t, f, g.handle) || w.removeEvent(t, p, g.handle), delete d[p])
          } else
            for (p in d) w.event.remove(t, p + e[c], i, s, !0);
        w.isEmptyObject(d) && (delete g.handle, w._removeData(t, "events"))
      }
    },
    trigger: function (t, e, i, s) {
      var n, a, o, r, l, c, d = [i || k],
        h = g.call(t, "type") ? t.type : t,
        u = g.call(t, "namespace") ? t.namespace.split(".") : [],
        p = l = i = i || k;
      if (3 !== i.nodeType && 8 !== i.nodeType && !Q.test(h + w.event.triggered) && (0 <= h.indexOf(".") && (h = (u = h.split(".")).shift(), u.sort()), a = h.indexOf(":") < 0 && "on" + h, (t = t[w.expando] ? t : new w.Event(h, "object" == typeof t && t)).isTrigger = s ? 2 : 3, t.namespace = u.join("."), t.namespace_re = t.namespace ? new RegExp("(^|\\.)" + u.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = i), e = null == e ? [t] : w.makeArray(e, [t]), r = w.event.special[h] || {}, s || !r.trigger || !1 !== r.trigger.apply(i, e))) {
        if (!s && !r.noBubble && !w.isWindow(i)) {
          for (o = r.delegateType || h, Q.test(o + h) || (p = p.parentNode); p; p = p.parentNode) d.push(p), l = p;
          l === (i.ownerDocument || k) && d.push(l.defaultView || l.parentWindow || f)
        }
        for (c = 0;
          (p = d[c++]) && !t.isPropagationStopped();) t.type = 1 < c ? o : r.bindType || h, (n = (w._data(p, "events") || {})[t.type] && w._data(p, "handle")) && n.apply(p, e), (n = a && p[a]) && n.apply && w.acceptData(p) && (t.result = n.apply(p, e), !1 === t.result && t.preventDefault());
        if (t.type = h, !s && !t.isDefaultPrevented() && (!r._default || !1 === r._default.apply(d.pop(), e)) && w.acceptData(i) && a && i[h] && !w.isWindow(i)) {
          (l = i[a]) && (i[a] = null), w.event.triggered = h;
          try {
            i[h]()
          } catch (t) {}
          w.event.triggered = void 0, l && (i[a] = l)
        }
        return t.result
      }
    },
    dispatch: function (t) {
      t = w.event.fix(t);
      var e, i, s, n, a, o = d.call(arguments),
        r = (w._data(this, "events") || {})[t.type] || [],
        l = w.event.special[t.type] || {};
      if ((o[0] = t).delegateTarget = this, !l.preDispatch || !1 !== l.preDispatch.call(this, t)) {
        for (a = w.event.handlers.call(this, t, r), e = 0;
          (s = a[e++]) && !t.isPropagationStopped();)
          for (t.currentTarget = s.elem, n = 0;
            (i = s.handlers[n++]) && !t.isImmediatePropagationStopped();) t.namespace_re && !t.namespace_re.test(i.namespace) || (t.handleObj = i, t.data = i.data, void 0 !== (i = ((w.event.special[i.origType] || {}).handle || i.handler).apply(s.elem, o)) && !1 === (t.result = i) && (t.preventDefault(), t.stopPropagation()));
        return l.postDispatch && l.postDispatch.call(this, t), t.result
      }
    },
    handlers: function (t, e) {
      var i, s, n, a, o = [],
        r = e.delegateCount,
        l = t.target;
      if (r && l.nodeType && (!t.button || "click" !== t.type))
        for (; l != this; l = l.parentNode || this)
          if (1 === l.nodeType && (!0 !== l.disabled || "click" !== t.type)) {
            for (n = [], a = 0; a < r; a++) void 0 === n[i = (s = e[a]).selector + " "] && (n[i] = s.needsContext ? 0 <= w(i, this).index(l) : w.find(i, this, null, [l]).length), n[i] && n.push(s);
            n.length && o.push({
              elem: l,
              handlers: n
            })
          } return r < e.length && o.push({
        elem: this,
        handlers: e.slice(r)
      }), o
    },
    fix: function (t) {
      if (t[w.expando]) return t;
      var e, i, s, n = t.type,
        a = t,
        o = this.fixHooks[n];
      for (o || (this.fixHooks[n] = o = K.test(n) ? this.mouseHooks : G.test(n) ? this.keyHooks : {}), s = o.props ? this.props.concat(o.props) : this.props, t = new w.Event(a), e = s.length; e--;) t[i = s[e]] = a[i];
      return t.target || (t.target = a.srcElement || k), 3 === t.target.nodeType && (t.target = t.target.parentNode), t.metaKey = !!t.metaKey, o.filter ? o.filter(t, a) : t
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function (t, e) {
        return null == t.which && (t.which = null != e.charCode ? e.charCode : e.keyCode), t
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function (t, e) {
        var i, s, n = e.button,
          a = e.fromElement;
        return null == t.pageX && null != e.clientX && (s = (i = t.target.ownerDocument || k).documentElement, i = i.body, t.pageX = e.clientX + (s && s.scrollLeft || i && i.scrollLeft || 0) - (s && s.clientLeft || i && i.clientLeft || 0), t.pageY = e.clientY + (s && s.scrollTop || i && i.scrollTop || 0) - (s && s.clientTop || i && i.clientTop || 0)), !t.relatedTarget && a && (t.relatedTarget = a === t.target ? e.toElement : a), t.which || void 0 === n || (t.which = 1 & n ? 1 : 2 & n ? 3 : 4 & n ? 2 : 0), t
      }
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function () {
          if (this !== et() && this.focus) try {
            return this.focus(), !1
          } catch (t) {}
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function () {
          return this === et() && this.blur ? (this.blur(), !1) : void 0
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function () {
          return w.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : void 0
        },
        _default: function (t) {
          return w.nodeName(t.target, "a")
        }
      },
      beforeunload: {
        postDispatch: function (t) {
          void 0 !== t.result && (t.originalEvent.returnValue = t.result)
        }
      }
    },
    simulate: function (t, e, i, s) {
      t = w.extend(new w.Event, i, {
        type: t,
        isSimulated: !0,
        originalEvent: {}
      });
      s ? w.event.trigger(t, null, e) : w.event.dispatch.call(e, t), t.isDefaultPrevented() && i.preventDefault()
    }
  }, w.removeEvent = k.removeEventListener ? function (t, e, i) {
    t.removeEventListener && t.removeEventListener(e, i, !1)
  } : function (t, e, i) {
    e = "on" + e;
    t.detachEvent && (typeof t[e] === N && (t[e] = null), t.detachEvent(e, i))
  }, w.Event = function (t, e) {
    return this instanceof w.Event ? (t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && (!1 === t.returnValue || t.getPreventDefault && t.getPreventDefault()) ? Z : tt) : this.type = t, e && w.extend(this, e), this.timeStamp = t && t.timeStamp || w.now(), void(this[w.expando] = !0)) : new w.Event(t, e)
  }, w.Event.prototype = {
    isDefaultPrevented: tt,
    isPropagationStopped: tt,
    isImmediatePropagationStopped: tt,
    preventDefault: function () {
      var t = this.originalEvent;
      this.isDefaultPrevented = Z, t && (t.preventDefault ? t.preventDefault() : t.returnValue = !1)
    },
    stopPropagation: function () {
      var t = this.originalEvent;
      this.isPropagationStopped = Z, t && (t.stopPropagation && t.stopPropagation(), t.cancelBubble = !0)
    },
    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = Z, this.stopPropagation()
    }
  }, w.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  }, function (t, n) {
    w.event.special[t] = {
      delegateType: n,
      bindType: n,
      handle: function (t) {
        var e, i = t.relatedTarget,
          s = t.handleObj;
        return i && (i === this || w.contains(this, i)) || (t.type = s.origType, e = s.handler.apply(this, arguments), t.type = n), e
      }
    }
  }), v.submitBubbles || (w.event.special.submit = {
    setup: function () {
      return !w.nodeName(this, "form") && void w.event.add(this, "click._submit keypress._submit", function (t) {
        t = t.target, t = w.nodeName(t, "input") || w.nodeName(t, "button") ? t.form : void 0;
        t && !w._data(t, "submitBubbles") && (w.event.add(t, "submit._submit", function (t) {
          t._submit_bubble = !0
        }), w._data(t, "submitBubbles", !0))
      })
    },
    postDispatch: function (t) {
      t._submit_bubble && (delete t._submit_bubble, this.parentNode && !t.isTrigger && w.event.simulate("submit", this.parentNode, t, !0))
    },
    teardown: function () {
      return !w.nodeName(this, "form") && void w.event.remove(this, "._submit")
    }
  }), v.changeBubbles || (w.event.special.change = {
    setup: function () {
      return X.test(this.nodeName) ? ("checkbox" !== this.type && "radio" !== this.type || (w.event.add(this, "propertychange._change", function (t) {
        "checked" === t.originalEvent.propertyName && (this._just_changed = !0)
      }), w.event.add(this, "click._change", function (t) {
        this._just_changed && !t.isTrigger && (this._just_changed = !1), w.event.simulate("change", this, t, !0)
      })), !1) : void w.event.add(this, "beforeactivate._change", function (t) {
        t = t.target;
        X.test(t.nodeName) && !w._data(t, "changeBubbles") && (w.event.add(t, "change._change", function (t) {
          !this.parentNode || t.isSimulated || t.isTrigger || w.event.simulate("change", this.parentNode, t, !0)
        }), w._data(t, "changeBubbles", !0))
      })
    },
    handle: function (t) {
      var e = t.target;
      return this !== e || t.isSimulated || t.isTrigger || "radio" !== e.type && "checkbox" !== e.type ? t.handleObj.handler.apply(this, arguments) : void 0
    },
    teardown: function () {
      return w.event.remove(this, "._change"), !X.test(this.nodeName)
    }
  }), v.focusinBubbles || w.each({
    focus: "focusin",
    blur: "focusout"
  }, function (i, s) {
    function n(t) {
      w.event.simulate(s, t.target, w.event.fix(t), !0)
    }
    w.event.special[s] = {
      setup: function () {
        var t = this.ownerDocument || this,
          e = w._data(t, s);
        e || t.addEventListener(i, n, !0), w._data(t, s, (e || 0) + 1)
      },
      teardown: function () {
        var t = this.ownerDocument || this,
          e = w._data(t, s) - 1;
        e ? w._data(t, s, e) : (t.removeEventListener(i, n, !0), w._removeData(t, s))
      }
    }
  }), w.fn.extend({
    on: function (t, e, i, s, n) {
      var a, o;
      if ("object" == typeof t) {
        for (a in "string" != typeof e && (i = i || e, e = void 0), t) this.on(a, e, i, t[a], n);
        return this
      }
      if (null == i && null == s ? (s = e, i = e = void 0) : null == s && ("string" == typeof e ? (s = i, i = void 0) : (s = i, i = e, e = void 0)), !1 === s) s = tt;
      else if (!s) return this;
      return 1 === n && (o = s, (s = function (t) {
        return w().off(t), o.apply(this, arguments)
      }).guid = o.guid || (o.guid = w.guid++)), this.each(function () {
        w.event.add(this, t, s, i, e)
      })
    },
    one: function (t, e, i, s) {
      return this.on(t, e, i, s, 1)
    },
    off: function (t, e, i) {
      var s, n;
      if (t && t.preventDefault && t.handleObj) return s = t.handleObj, w(t.delegateTarget).off(s.namespace ? s.origType + "." + s.namespace : s.origType, s.selector, s.handler), this;
      if ("object" != typeof t) return !1 !== e && "function" != typeof e || (i = e, e = void 0), !1 === i && (i = tt), this.each(function () {
        w.event.remove(this, t, i, e)
      });
      for (n in t) this.off(n, e, t[n]);
      return this
    },
    trigger: function (t, e) {
      return this.each(function () {
        w.event.trigger(t, e, this)
      })
    },
    triggerHandler: function (t, e) {
      var i = this[0];
      return i ? w.event.trigger(t, e, i, !0) : void 0
    }
  });
  var st = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    nt = / jQuery\d+="(?:null|\d+)"/g,
    at = new RegExp("<(?:" + st + ")[\\s/>]", "i"),
    ot = /^\s+/,
    rt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    lt = /<([\w:]+)/,
    ct = /<tbody/i,
    dt = /<|&#?\w+;/,
    ht = /<(?:script|style|link)/i,
    ut = /checked\s*(?:[^=]|=\s*.checked.)/i,
    pt = /^$|\/(?:java|ecma)script/i,
    ft = /^true\/(.*)/,
    mt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    gt = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      legend: [1, "<fieldset>", "</fieldset>"],
      area: [1, "<map>", "</map>"],
      param: [1, "<object>", "</object>"],
      thead: [1, "<table>", "</table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: v.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
    },
    vt = it(k).appendChild(k.createElement("div"));

  function bt(t, e) {
    var i, s, n = 0,
      a = typeof t.getElementsByTagName !== N ? t.getElementsByTagName(e || "*") : typeof t.querySelectorAll !== N ? t.querySelectorAll(e || "*") : void 0;
    if (!a)
      for (a = [], i = t.childNodes || t; null != (s = i[n]); n++) !e || w.nodeName(s, e) ? a.push(s) : w.merge(a, bt(s, e));
    return void 0 === e || e && w.nodeName(t, e) ? w.merge([t], a) : a
  }

  function _t(t) {
    U.test(t.type) && (t.defaultChecked = t.checked)
  }

  function yt(t, e) {
    return w.nodeName(t, "table") && w.nodeName(11 !== e.nodeType ? e : e.firstChild, "tr") ? t.getElementsByTagName("tbody")[0] || t.appendChild(t.ownerDocument.createElement("tbody")) : t
  }

  function wt(t) {
    return t.type = (null !== w.find.attr(t, "type")) + "/" + t.type, t
  }

  function xt(t) {
    var e = ft.exec(t.type);
    return e ? t.type = e[1] : t.removeAttribute("type"), t
  }

  function Ct(t, e) {
    for (var i, s = 0; null != (i = t[s]); s++) w._data(i, "globalEval", !e || w._data(e[s], "globalEval"))
  }

  function kt(t, e) {
    if (1 === e.nodeType && w.hasData(t)) {
      var i, s, n, a = w._data(t),
        t = w._data(e, a),
        o = a.events;
      if (o)
        for (i in delete t.handle, t.events = {}, o)
          for (s = 0, n = o[i].length; s < n; s++) w.event.add(e, i, o[i][s]);
      t.data && (t.data = w.extend({}, t.data))
    }
  }
  gt.optgroup = gt.option, gt.tbody = gt.tfoot = gt.colgroup = gt.caption = gt.thead, gt.th = gt.td, w.extend({
    clone: function (t, e, i) {
      var s, n, a, o, r, l = w.contains(t.ownerDocument, t);
      if (v.html5Clone || w.isXMLDoc(t) || !at.test("<" + t.nodeName + ">") ? a = t.cloneNode(!0) : (vt.innerHTML = t.outerHTML, vt.removeChild(a = vt.firstChild)), !(v.noCloneEvent && v.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || w.isXMLDoc(t)))
        for (s = bt(a), r = bt(t), o = 0; null != (n = r[o]); ++o) s[o] && function (t, e) {
          var i, s, n;
          if (1 === e.nodeType) {
            if (i = e.nodeName.toLowerCase(), !v.noCloneEvent && e[w.expando]) {
              for (s in (n = w._data(e)).events) w.removeEvent(e, s, n.handle);
              e.removeAttribute(w.expando)
            }
            "script" === i && e.text !== t.text ? (wt(e).text = t.text, xt(e)) : "object" === i ? (e.parentNode && (e.outerHTML = t.outerHTML), v.html5Clone && t.innerHTML && !w.trim(e.innerHTML) && (e.innerHTML = t.innerHTML)) : "input" === i && U.test(t.type) ? (e.defaultChecked = e.checked = t.checked, e.value !== t.value && (e.value = t.value)) : "option" === i ? e.defaultSelected = e.selected = t.defaultSelected : "input" !== i && "textarea" !== i || (e.defaultValue = t.defaultValue)
          }
        }(n, s[o]);
      if (e)
        if (i)
          for (r = r || bt(t), s = s || bt(a), o = 0; null != (n = r[o]); o++) kt(n, s[o]);
        else kt(t, a);
      return 0 < (s = bt(a, "script")).length && Ct(s, !l && bt(t, "script")), s = r = n = null, a
    },
    buildFragment: function (t, e, i, s) {
      for (var n, a, o, r, l, c, d, h = t.length, u = it(e), p = [], f = 0; f < h; f++)
        if ((a = t[f]) || 0 === a)
          if ("object" === w.type(a)) w.merge(p, a.nodeType ? [a] : a);
          else if (dt.test(a)) {
        for (r = r || u.appendChild(e.createElement("div")), l = (lt.exec(a) || ["", ""])[1].toLowerCase(), d = gt[l] || gt._default, r.innerHTML = d[1] + a.replace(rt, "<$1></$2>") + d[2], n = d[0]; n--;) r = r.lastChild;
        if (!v.leadingWhitespace && ot.test(a) && p.push(e.createTextNode(ot.exec(a)[0])), !v.tbody)
          for (n = (a = "table" !== l || ct.test(a) ? "<table>" !== d[1] || ct.test(a) ? 0 : r : r.firstChild) && a.childNodes.length; n--;) w.nodeName(c = a.childNodes[n], "tbody") && !c.childNodes.length && a.removeChild(c);
        for (w.merge(p, r.childNodes), r.textContent = ""; r.firstChild;) r.removeChild(r.firstChild);
        r = u.lastChild
      } else p.push(e.createTextNode(a));
      for (r && u.removeChild(r), v.appendChecked || w.grep(bt(p, "input"), _t), f = 0; a = p[f++];)
        if ((!s || -1 === w.inArray(a, s)) && (o = w.contains(a.ownerDocument, a), r = bt(u.appendChild(a), "script"), o && Ct(r), i))
          for (n = 0; a = r[n++];) pt.test(a.type || "") && i.push(a);
      return r = null, u
    },
    cleanData: function (t, e) {
      for (var i, s, n, a, o = 0, r = w.expando, l = w.cache, c = v.deleteExpando, d = w.event.special; null != (i = t[o]); o++)
        if ((e || w.acceptData(i)) && (a = (n = i[r]) && l[n])) {
          if (a.events)
            for (s in a.events) d[s] ? w.event.remove(i, s) : w.removeEvent(i, s, a.handle);
          l[n] && (delete l[n], c ? delete i[r] : typeof i.removeAttribute !== N ? i.removeAttribute(r) : i[r] = null, h.push(n))
        }
    }
  }), w.fn.extend({
    text: function (t) {
      return Y(this, function (t) {
        return void 0 === t ? w.text(this) : this.empty().append((this[0] && this[0].ownerDocument || k).createTextNode(t))
      }, null, t, arguments.length)
    },
    append: function () {
      return this.domManip(arguments, function (t) {
        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || yt(this, t).appendChild(t)
      })
    },
    prepend: function () {
      return this.domManip(arguments, function (t) {
        var e;
        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (e = yt(this, t)).insertBefore(t, e.firstChild)
      })
    },
    before: function () {
      return this.domManip(arguments, function (t) {
        this.parentNode && this.parentNode.insertBefore(t, this)
      })
    },
    after: function () {
      return this.domManip(arguments, function (t) {
        this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
      })
    },
    remove: function (t, e) {
      for (var i, s = t ? w.filter(t, this) : this, n = 0; null != (i = s[n]); n++) e || 1 !== i.nodeType || w.cleanData(bt(i)), i.parentNode && (e && w.contains(i.ownerDocument, i) && Ct(bt(i, "script")), i.parentNode.removeChild(i));
      return this
    },
    empty: function () {
      for (var t, e = 0; null != (t = this[e]); e++) {
        for (1 === t.nodeType && w.cleanData(bt(t, !1)); t.firstChild;) t.removeChild(t.firstChild);
        t.options && w.nodeName(t, "select") && (t.options.length = 0)
      }
      return this
    },
    clone: function (t, e) {
      return t = null != t && t, e = null == e ? t : e, this.map(function () {
        return w.clone(this, t, e)
      })
    },
    html: function (t) {
      return Y(this, function (t) {
        var e = this[0] || {},
          i = 0,
          s = this.length;
        if (void 0 === t) return 1 === e.nodeType ? e.innerHTML.replace(nt, "") : void 0;
        if (!("string" != typeof t || ht.test(t) || !v.htmlSerialize && at.test(t) || !v.leadingWhitespace && ot.test(t) || gt[(lt.exec(t) || ["", ""])[1].toLowerCase()])) {
          t = t.replace(rt, "<$1></$2>");
          try {
            for (; i < s; i++) 1 === (e = this[i] || {}).nodeType && (w.cleanData(bt(e, !1)), e.innerHTML = t);
            e = 0
          } catch (t) {}
        }
        e && this.empty().append(t)
      }, null, t, arguments.length)
    },
    replaceWith: function () {
      var e = arguments[0];
      return this.domManip(arguments, function (t) {
        e = this.parentNode, w.cleanData(bt(this)), e && e.replaceChild(t, this)
      }), e && (e.length || e.nodeType) ? this : this.remove()
    },
    detach: function (t) {
      return this.remove(t, !0)
    },
    domManip: function (i, s) {
      i = m.apply([], i);
      var t, e, n, a, o, r, l = 0,
        c = this.length,
        d = this,
        h = c - 1,
        u = i[0],
        p = w.isFunction(u);
      if (p || 1 < c && "string" == typeof u && !v.checkClone && ut.test(u)) return this.each(function (t) {
        var e = d.eq(t);
        p && (i[0] = u.call(this, t, e.html())), e.domManip(i, s)
      });
      if (c && (t = (r = w.buildFragment(i, this[0].ownerDocument, !1, this)).firstChild, 1 === r.childNodes.length && (r = t), t)) {
        for (n = (a = w.map(bt(r, "script"), wt)).length; l < c; l++) e = r, l !== h && (e = w.clone(e, !0, !0), n && w.merge(a, bt(e, "script"))), s.call(this[l], e, l);
        if (n)
          for (o = a[a.length - 1].ownerDocument, w.map(a, xt), l = 0; l < n; l++) e = a[l], pt.test(e.type || "") && !w._data(e, "globalEval") && w.contains(o, e) && (e.src ? w._evalUrl && w._evalUrl(e.src) : w.globalEval((e.text || e.textContent || e.innerHTML || "").replace(mt, "")));
        r = t = null
      }
      return this
    }
  }), w.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (t, o) {
    w.fn[t] = function (t) {
      for (var e, i = 0, s = [], n = w(t), a = n.length - 1; i <= a; i++) e = i === a ? this : this.clone(!0), w(n[i])[o](e), r.apply(s, e.get());
      return this.pushStack(s)
    }
  });
  var Tt, Dt, St = {};

  function Mt(t, e) {
    t = w(e.createElement(t)).appendTo(e.body), e = f.getDefaultComputedStyle ? f.getDefaultComputedStyle(t[0]).display : w.css(t[0], "display");
    return t.detach(), e
  }

  function Et(t) {
    var e = k,
      i = St[t];
    return i || ("none" !== (i = Mt(t, e)) && i || ((e = ((Tt = (Tt || w("<iframe frameborder='0' width='0' height='0'/>")).appendTo(e.documentElement))[0].contentWindow || Tt[0].contentDocument).document).write(), e.close(), i = Mt(t, e), Tt.detach()), St[t] = i), i
  }(ae = k.createElement("div")).innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", (Ge = ae.getElementsByTagName("a")[0]).style.cssText = "float:left;opacity:.5", v.opacity = /^0.5/.test(Ge.style.opacity), v.cssFloat = !!Ge.style.cssFloat, ae.style.backgroundClip = "content-box", ae.cloneNode(!0).style.backgroundClip = "", v.clearCloneStyle = "content-box" === ae.style.backgroundClip, Ge = ae = null, v.shrinkWrapBlocks = function () {
    var t, e, i;
    if (null == Dt) {
      if (!(t = k.getElementsByTagName("body")[0])) return;
      e = k.createElement("div"), i = k.createElement("div"), t.appendChild(e).appendChild(i), Dt = !1, typeof i.style.zoom !== N && (i.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0;width:1px;padding:1px;zoom:1", i.innerHTML = "<div></div>", i.firstChild.style.width = "5px", Dt = 3 !== i.offsetWidth), t.removeChild(e), t = i = null
    }
    return Dt
  };
  var At, Pt, It, Ot, $t, Lt, Nt, Ht, Ft = /^margin/,
    zt = new RegExp("^(" + V + ")(?!px)[a-z%]+$", "i"),
    Rt = /^(top|right|bottom|left)$/;

  function Bt(e, i) {
    return {
      get: function () {
        var t = e();
        if (null != t) return t ? void delete this.get : (this.get = i).apply(this, arguments)
      }
    }
  }

  function jt() {
    var t, e, i = k.getElementsByTagName("body")[0];
    i && (t = k.createElement("div"), e = k.createElement("div"), t.style.cssText = Ht, i.appendChild(t).appendChild(e), e.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%", w.swap(i, null != i.style.zoom ? {
      zoom: 1
    } : {}, function () {
      Ot = 4 === e.offsetWidth
    }), Nt = !(Lt = !($t = !0)), f.getComputedStyle && (Lt = "1%" !== (f.getComputedStyle(e, null) || {}).top, $t = "4px" === (f.getComputedStyle(e, null) || {
      width: "4px"
    }).width), i.removeChild(t), e = i = null)
  }
  f.getComputedStyle ? (At = function (t) {
    return t.ownerDocument.defaultView.getComputedStyle(t, null)
  }, Pt = function (t, e, i) {
    var s, n = t.style,
      a = (i = i || At(t)) ? i.getPropertyValue(e) || i[e] : void 0;
    return i && ("" !== a || w.contains(t.ownerDocument, t) || (a = w.style(t, e)), zt.test(a) && Ft.test(e) && (s = n.width, t = n.minWidth, e = n.maxWidth, n.minWidth = n.maxWidth = n.width = a, a = i.width, n.width = s, n.minWidth = t, n.maxWidth = e)), void 0 === a ? a : a + ""
  }) : k.documentElement.currentStyle && (At = function (t) {
    return t.currentStyle
  }, Pt = function (t, e, i) {
    var s, n, a, o = t.style;
    return null == (a = (i = i || At(t)) ? i[e] : void 0) && o && o[e] && (a = o[e]), zt.test(a) && !Rt.test(e) && (s = o.left, (i = (n = t.runtimeStyle) && n.left) && (n.left = t.currentStyle.left), o.left = "fontSize" === e ? "1em" : a, a = o.pixelLeft + "px", o.left = s, i && (n.left = i)), void 0 === a ? a : a + "" || "auto"
  }), o = k.createElement("div"), Ht = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px", o.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", (b = o.getElementsByTagName("a")[0]).style.cssText = "float:left;opacity:.5", v.opacity = /^0.5/.test(b.style.opacity), v.cssFloat = !!b.style.cssFloat, o.style.backgroundClip = "content-box", o.cloneNode(!0).style.backgroundClip = "", v.clearCloneStyle = "content-box" === o.style.backgroundClip, b = o = null, w.extend(v, {
    reliableHiddenOffsets: function () {
      if (null != It) return It;
      var t, e, i, s = k.createElement("div"),
        n = k.getElementsByTagName("body")[0];
      return n ? (s.setAttribute("className", "t"), s.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", (t = k.createElement("div")).style.cssText = Ht, n.appendChild(t).appendChild(s), s.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", (e = s.getElementsByTagName("td"))[0].style.cssText = "padding:0;margin:0;border:0;display:none", i = 0 === e[0].offsetHeight, e[0].style.display = "", e[1].style.display = "none", It = i && 0 === e[0].offsetHeight, n.removeChild(t), s = n = null, It) : void 0
    },
    boxSizing: function () {
      return null == Ot && jt(), Ot
    },
    boxSizingReliable: function () {
      return null == $t && jt(), $t
    },
    pixelPosition: function () {
      return null == Lt && jt(), Lt
    },
    reliableMarginRight: function () {
      var t, e, i, s;
      if (null == Nt && f.getComputedStyle) {
        if (!(t = k.getElementsByTagName("body")[0])) return;
        e = k.createElement("div"), i = k.createElement("div"), e.style.cssText = Ht, t.appendChild(e).appendChild(i), (s = i.appendChild(k.createElement("div"))).style.cssText = i.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0", s.style.marginRight = s.style.width = "0", i.style.width = "1px", Nt = !parseFloat((f.getComputedStyle(s, null) || {}).marginRight), t.removeChild(e)
      }
      return Nt
    }
  }), w.swap = function (t, e, i, s) {
    var n, a = {};
    for (n in e) a[n] = t.style[n], t.style[n] = e[n];
    for (n in s = i.apply(t, s || []), e) t.style[n] = a[n];
    return s
  };
  var Wt = /alpha\([^)]*\)/i,
    Vt = /opacity\s*=\s*([^)]*)/,
    qt = /^(none|table(?!-c[ea]).+)/,
    Yt = new RegExp("^(" + V + ")(.*)$", "i"),
    Ut = new RegExp("^([+-])=(" + V + ")", "i"),
    Xt = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Gt = {
      letterSpacing: 0,
      fontWeight: 400
    },
    Kt = ["Webkit", "O", "Moz", "ms"];

  function Qt(t, e) {
    if (e in t) return e;
    for (var i = e.charAt(0).toUpperCase() + e.slice(1), s = e, n = Kt.length; n--;)
      if ((e = Kt[n] + i) in t) return e;
    return s
  }

  function Jt(t, e) {
    for (var i, s, n, a = [], o = 0, r = t.length; o < r; o++)(s = t[o]).style && (a[o] = w._data(s, "olddisplay"), i = s.style.display, e ? (a[o] || "none" !== i || (s.style.display = ""), "" === s.style.display && W(s) && (a[o] = w._data(s, "olddisplay", Et(s.nodeName)))) : a[o] || (n = W(s), (i && "none" !== i || !n) && w._data(s, "olddisplay", n ? i : w.css(s, "display"))));
    for (o = 0; o < r; o++)(s = t[o]).style && (e && "none" !== s.style.display && "" !== s.style.display || (s.style.display = e ? a[o] || "" : "none"));
    return t
  }

  function Zt(t, e, i) {
    var s = Yt.exec(e);
    return s ? Math.max(0, s[1] - (i || 0)) + (s[2] || "px") : e
  }

  function te(t, e, i, s, n) {
    for (var a = i === (s ? "border" : "content") ? 4 : "width" === e ? 1 : 0, o = 0; a < 4; a += 2) "margin" === i && (o += w.css(t, i + q[a], !0, n)), s ? ("content" === i && (o -= w.css(t, "padding" + q[a], !0, n)), "margin" !== i && (o -= w.css(t, "border" + q[a] + "Width", !0, n))) : (o += w.css(t, "padding" + q[a], !0, n), "padding" !== i && (o += w.css(t, "border" + q[a] + "Width", !0, n)));
    return o
  }

  function ee(t, e, i) {
    var s = !0,
      n = "width" === e ? t.offsetWidth : t.offsetHeight,
      a = At(t),
      o = v.boxSizing() && "border-box" === w.css(t, "boxSizing", !1, a);
    if (n <= 0 || null == n) {
      if (((n = Pt(t, e, a)) < 0 || null == n) && (n = t.style[e]), zt.test(n)) return n;
      s = o && (v.boxSizingReliable() || n === t.style[e]), n = parseFloat(n) || 0
    }
    return n + te(t, e, i || (o ? "border" : "content"), s, a) + "px"
  }

  function ie(t, e, i, s, n) {
    return new ie.prototype.init(t, e, i, s, n)
  }
  w.extend({
    cssHooks: {
      opacity: {
        get: function (t, e) {
          if (e) {
            t = Pt(t, "opacity");
            return "" === t ? "1" : t
          }
        }
      }
    },
    cssNumber: {
      columnCount: !0,
      fillOpacity: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {
      float: v.cssFloat ? "cssFloat" : "styleFloat"
    },
    style: function (t, e, i, s) {
      if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
        var n, a, o, r = w.camelCase(e),
          l = t.style;
        if (e = w.cssProps[r] || (w.cssProps[r] = Qt(l, r)), o = w.cssHooks[e] || w.cssHooks[r], void 0 === i) return o && "get" in o && void 0 !== (n = o.get(t, !1, s)) ? n : l[e];
        if ("string" === (a = typeof i) && (n = Ut.exec(i)) && (i = (n[1] + 1) * n[2] + parseFloat(w.css(t, e)), a = "number"), null != i && i == i && ("number" !== a || w.cssNumber[r] || (i += "px"), v.clearCloneStyle || "" !== i || 0 !== e.indexOf("background") || (l[e] = "inherit"), !(o && "set" in o && void 0 === (i = o.set(t, i, s))))) try {
          l[e] = "", l[e] = i
        } catch (t) {}
      }
    },
    css: function (t, e, i, s) {
      var n, a = w.camelCase(e);
      return e = w.cssProps[a] || (w.cssProps[a] = Qt(t.style, a)), "normal" === (n = void 0 === (n = (a = w.cssHooks[e] || w.cssHooks[a]) && "get" in a ? a.get(t, !0, i) : n) ? Pt(t, e, s) : n) && e in Gt && (n = Gt[e]), "" === i || i ? (e = parseFloat(n), !0 === i || w.isNumeric(e) ? e || 0 : n) : n
    }
  }), w.each(["height", "width"], function (t, n) {
    w.cssHooks[n] = {
      get: function (t, e, i) {
        return e ? 0 === t.offsetWidth && qt.test(w.css(t, "display")) ? w.swap(t, Xt, function () {
          return ee(t, n, i)
        }) : ee(t, n, i) : void 0
      },
      set: function (t, e, i) {
        var s = i && At(t);
        return Zt(0, e, i ? te(t, n, i, v.boxSizing() && "border-box" === w.css(t, "boxSizing", !1, s), s) : 0)
      }
    }
  }), v.opacity || (w.cssHooks.opacity = {
    get: function (t, e) {
      return Vt.test((e && t.currentStyle ? t.currentStyle : t.style).filter || "") ? .01 * parseFloat(RegExp.$1) + "" : e ? "1" : ""
    },
    set: function (t, e) {
      var i = t.style,
        s = t.currentStyle,
        n = w.isNumeric(e) ? "alpha(opacity=" + 100 * e + ")" : "",
        t = s && s.filter || i.filter || "";
      ((i.zoom = 1) <= e || "" === e) && "" === w.trim(t.replace(Wt, "")) && i.removeAttribute && (i.removeAttribute("filter"), "" === e || s && !s.filter) || (i.filter = Wt.test(t) ? t.replace(Wt, n) : t + " " + n)
    }
  }), w.cssHooks.marginRight = Bt(v.reliableMarginRight, function (t, e) {
    return e ? w.swap(t, {
      display: "inline-block"
    }, Pt, [t, "marginRight"]) : void 0
  }), w.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (n, a) {
    w.cssHooks[n + a] = {
      expand: function (t) {
        for (var e = 0, i = {}, s = "string" == typeof t ? t.split(" ") : [t]; e < 4; e++) i[n + q[e] + a] = s[e] || s[e - 2] || s[0];
        return i
      }
    }, Ft.test(n) || (w.cssHooks[n + a].set = Zt)
  }), w.fn.extend({
    css: function (t, e) {
      return Y(this, function (t, e, i) {
        var s, n, a = {},
          o = 0;
        if (w.isArray(e)) {
          for (s = At(t), n = e.length; o < n; o++) a[e[o]] = w.css(t, e[o], !1, s);
          return a
        }
        return void 0 !== i ? w.style(t, e, i) : w.css(t, e)
      }, t, e, 1 < arguments.length)
    },
    show: function () {
      return Jt(this, !0)
    },
    hide: function () {
      return Jt(this)
    },
    toggle: function (t) {
      return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function () {
        W(this) ? w(this).show() : w(this).hide()
      })
    }
  }), (w.Tween = ie).prototype = {
    constructor: ie,
    init: function (t, e, i, s, n, a) {
      this.elem = t, this.prop = i, this.easing = n || "swing", this.options = e, this.start = this.now = this.cur(), this.end = s, this.unit = a || (w.cssNumber[i] ? "" : "px")
    },
    cur: function () {
      var t = ie.propHooks[this.prop];
      return (t && t.get ? t : ie.propHooks._default).get(this)
    },
    run: function (t) {
      var e = ie.propHooks[this.prop];
      return this.pos = t = this.options.duration ? w.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : t, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), (e && e.set ? e : ie.propHooks._default).set(this), this
    }
  }, ie.prototype.init.prototype = ie.prototype, ie.propHooks = {
    _default: {
      get: function (t) {
        var e;
        return null == t.elem[t.prop] || t.elem.style && null != t.elem.style[t.prop] ? (e = w.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0 : t.elem[t.prop]
      },
      set: function (t) {
        w.fx.step[t.prop] ? w.fx.step[t.prop](t) : t.elem.style && (null != t.elem.style[w.cssProps[t.prop]] || w.cssHooks[t.prop]) ? w.style(t.elem, t.prop, t.now + t.unit) : t.elem[t.prop] = t.now
      }
    }
  }, ie.propHooks.scrollTop = ie.propHooks.scrollLeft = {
    set: function (t) {
      t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
    }
  }, w.easing = {
    linear: function (t) {
      return t
    },
    swing: function (t) {
      return .5 - Math.cos(t * Math.PI) / 2
    }
  }, w.fx = ie.prototype.init, w.fx.step = {};
  var se, ne, ae, oe = /^(?:toggle|show|hide)$/,
    re = new RegExp("^(?:([+-])=|)(" + V + ")([a-z%]*)$", "i"),
    le = /queueHooks$/,
    ce = [function (e, t, i) {
      var s, n, a, o, r, l, c, d, h = this,
        u = {},
        p = e.style,
        f = e.nodeType && W(e),
        m = w._data(e, "fxshow");
      for (s in i.queue || (null == (r = w._queueHooks(e, "fx")).unqueued && (r.unqueued = 0, l = r.empty.fire, r.empty.fire = function () {
          r.unqueued || l()
        }), r.unqueued++, h.always(function () {
          h.always(function () {
            r.unqueued--, w.queue(e, "fx").length || r.empty.fire()
          })
        })), 1 === e.nodeType && ("height" in t || "width" in t) && (i.overflow = [p.overflow, p.overflowX, p.overflowY], c = w.css(e, "display"), d = Et(e.nodeName), "inline" === (c = "none" === c ? d : c) && "none" === w.css(e, "float") && (v.inlineBlockNeedsLayout && "inline" !== d ? p.zoom = 1 : p.display = "inline-block")), i.overflow && (p.overflow = "hidden", v.shrinkWrapBlocks() || h.always(function () {
          p.overflow = i.overflow[0], p.overflowX = i.overflow[1], p.overflowY = i.overflow[2]
        })), t)
        if (n = t[s], oe.exec(n)) {
          if (delete t[s], a = a || "toggle" === n, n === (f ? "hide" : "show")) {
            if ("show" !== n || !m || void 0 === m[s]) continue;
            f = !0
          }
          u[s] = m && m[s] || w.style(e, s)
        } if (!w.isEmptyObject(u))
        for (s in m ? "hidden" in m && (f = m.hidden) : m = w._data(e, "fxshow", {}), a && (m.hidden = !f), f ? w(e).show() : h.done(function () {
            w(e).hide()
          }), h.done(function () {
            for (var t in w._removeData(e, "fxshow"), u) w.style(e, t, u[t])
          }), u) o = pe(f ? m[s] : 0, s, h), s in m || (m[s] = o.start, f && (o.end = o.start, o.start = "width" === s || "height" === s ? 1 : 0))
    }],
    de = {
      "*": [function (t, e) {
        var i = this.createTween(t, e),
          s = i.cur(),
          e = re.exec(e),
          n = e && e[3] || (w.cssNumber[t] ? "" : "px"),
          a = (w.cssNumber[t] || "px" !== n && +s) && re.exec(w.css(i.elem, t)),
          o = 1,
          r = 20;
        if (a && a[3] !== n)
          for (n = n || a[3], e = e || [], a = +s || 1; w.style(i.elem, t, (a /= o = o || ".5") + n), o !== (o = i.cur() / s) && 1 !== o && --r;);
        return e && (a = i.start = +a || +s || 0, i.unit = n, i.end = e[1] ? a + (e[1] + 1) * e[2] : +e[2]), i
      }]
    };

  function he() {
    return setTimeout(function () {
      se = void 0
    }), se = w.now()
  }

  function ue(t, e) {
    var i, s = {
        height: t
      },
      n = 0;
    for (e = e ? 1 : 0; n < 4; n += 2 - e) s["margin" + (i = q[n])] = s["padding" + i] = t;
    return e && (s.opacity = s.width = t), s
  }

  function pe(t, e, i) {
    for (var s, n = (de[e] || []).concat(de["*"]), a = 0, o = n.length; a < o; a++)
      if (s = n[a].call(i, e, t)) return s
  }

  function fe(n, t, e) {
    var i, a, s = 0,
      o = ce.length,
      r = w.Deferred().always(function () {
        delete l.elem
      }),
      l = function () {
        if (a) return !1;
        for (var t = se || he(), t = Math.max(0, c.startTime + c.duration - t), e = 1 - (t / c.duration || 0), i = 0, s = c.tweens.length; i < s; i++) c.tweens[i].run(e);
        return r.notifyWith(n, [c, e, t]), e < 1 && s ? t : (r.resolveWith(n, [c]), !1)
      },
      c = r.promise({
        elem: n,
        props: w.extend({}, t),
        opts: w.extend(!0, {
          specialEasing: {}
        }, e),
        originalProperties: t,
        originalOptions: e,
        startTime: se || he(),
        duration: e.duration,
        tweens: [],
        createTween: function (t, e) {
          t = w.Tween(n, c.opts, t, e, c.opts.specialEasing[t] || c.opts.easing);
          return c.tweens.push(t), t
        },
        stop: function (t) {
          var e = 0,
            i = t ? c.tweens.length : 0;
          if (a) return this;
          for (a = !0; e < i; e++) c.tweens[e].run(1);
          return t ? r.resolveWith(n, [c, t]) : r.rejectWith(n, [c, t]), this
        }
      }),
      d = c.props;
    for (function (t, e) {
        var i, s, n, a, o;
        for (i in t)
          if (s = w.camelCase(i), n = e[s], a = t[i], w.isArray(a) && (n = a[1], a = t[i] = a[0]), i !== s && (t[s] = a, delete t[i]), o = w.cssHooks[s], o && "expand" in o)
            for (i in a = o.expand(a), delete t[s], a) i in t || (t[i] = a[i], e[i] = n);
          else e[s] = n
      }(d, c.opts.specialEasing); s < o; s++)
      if (i = ce[s].call(c, n, d, c.opts)) return i;
    return w.map(d, pe, c), w.isFunction(c.opts.start) && c.opts.start.call(n, c), w.fx.timer(w.extend(l, {
      elem: n,
      anim: c,
      queue: c.opts.queue
    })), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always)
  }
  w.Animation = w.extend(fe, {
    tweener: function (t, e) {
      for (var i, s = 0, n = (t = w.isFunction(t) ? (e = t, ["*"]) : t.split(" ")).length; s < n; s++) i = t[s], de[i] = de[i] || [], de[i].unshift(e)
    },
    prefilter: function (t, e) {
      e ? ce.unshift(t) : ce.push(t)
    }
  }), w.speed = function (t, e, i) {
    var s = t && "object" == typeof t ? w.extend({}, t) : {
      complete: i || !i && e || w.isFunction(t) && t,
      duration: t,
      easing: i && e || e && !w.isFunction(e) && e
    };
    return s.duration = w.fx.off ? 0 : "number" == typeof s.duration ? s.duration : s.duration in w.fx.speeds ? w.fx.speeds[s.duration] : w.fx.speeds._default, null != s.queue && !0 !== s.queue || (s.queue = "fx"), s.old = s.complete, s.complete = function () {
      w.isFunction(s.old) && s.old.call(this), s.queue && w.dequeue(this, s.queue)
    }, s
  }, w.fn.extend({
    fadeTo: function (t, e, i, s) {
      return this.filter(W).css("opacity", 0).show().end().animate({
        opacity: e
      }, t, i, s)
    },
    animate: function (e, t, i, s) {
      var n = w.isEmptyObject(e),
        a = w.speed(t, i, s),
        s = function () {
          var t = fe(this, w.extend({}, e), a);
          (n || w._data(this, "finish")) && t.stop(!0)
        };
      return s.finish = s, n || !1 === a.queue ? this.each(s) : this.queue(a.queue, s)
    },
    stop: function (n, t, a) {
      function o(t) {
        var e = t.stop;
        delete t.stop, e(a)
      }
      return "string" != typeof n && (a = t, t = n, n = void 0), t && !1 !== n && this.queue(n || "fx", []), this.each(function () {
        var t = !0,
          e = null != n && n + "queueHooks",
          i = w.timers,
          s = w._data(this);
        if (e) s[e] && s[e].stop && o(s[e]);
        else
          for (e in s) s[e] && s[e].stop && le.test(e) && o(s[e]);
        for (e = i.length; e--;) i[e].elem !== this || null != n && i[e].queue !== n || (i[e].anim.stop(a), t = !1, i.splice(e, 1));
        !t && a || w.dequeue(this, n)
      })
    },
    finish: function (o) {
      return !1 !== o && (o = o || "fx"), this.each(function () {
        var t, e = w._data(this),
          i = e[o + "queue"],
          s = e[o + "queueHooks"],
          n = w.timers,
          a = i ? i.length : 0;
        for (e.finish = !0, w.queue(this, o, []), s && s.stop && s.stop.call(this, !0), t = n.length; t--;) n[t].elem === this && n[t].queue === o && (n[t].anim.stop(!0), n.splice(t, 1));
        for (t = 0; t < a; t++) i[t] && i[t].finish && i[t].finish.call(this);
        delete e.finish
      })
    }
  }), w.each(["toggle", "show", "hide"], function (t, s) {
    var n = w.fn[s];
    w.fn[s] = function (t, e, i) {
      return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(ue(s, !0), t, e, i)
    }
  }), w.each({
    slideDown: ue("show"),
    slideUp: ue("hide"),
    slideToggle: ue("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (t, s) {
    w.fn[t] = function (t, e, i) {
      return this.animate(s, t, e, i)
    }
  }), w.timers = [], w.fx.tick = function () {
    var t, e = w.timers,
      i = 0;
    for (se = w.now(); i < e.length; i++)(t = e[i])() || e[i] !== t || e.splice(i--, 1);
    e.length || w.fx.stop(), se = void 0
  }, w.fx.timer = function (t) {
    w.timers.push(t), t() ? w.fx.start() : w.timers.pop()
  }, w.fx.interval = 13, w.fx.start = function () {
    ne = ne || setInterval(w.fx.tick, w.fx.interval)
  }, w.fx.stop = function () {
    clearInterval(ne), ne = null
  }, w.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  }, w.fn.delay = function (s, t) {
    return s = w.fx && w.fx.speeds[s] || s, this.queue(t = t || "fx", function (t, e) {
      var i = setTimeout(t, s);
      e.stop = function () {
        clearTimeout(i)
      }
    })
  }, (ae = k.createElement("div")).setAttribute("className", "t"), ae.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", Ge = ae.getElementsByTagName("a")[0], b = (o = k.createElement("select")).appendChild(k.createElement("option")), V = ae.getElementsByTagName("input")[0], Ge.style.cssText = "top:1px", v.getSetAttribute = "t" !== ae.className, v.style = /top/.test(Ge.getAttribute("style")), v.hrefNormalized = "/a" === Ge.getAttribute("href"), v.checkOn = !!V.value, v.optSelected = b.selected, v.enctype = !!k.createElement("form").enctype, o.disabled = !0, v.optDisabled = !b.disabled, (V = k.createElement("input")).setAttribute("value", ""), v.input = "" === V.getAttribute("value"), V.value = "t", V.setAttribute("type", "radio"), v.radioValue = "t" === V.value, Ge = V = o = ae = null;
  var me = /\r/g;
  w.fn.extend({
    val: function (e) {
      var i, t, s, n = this[0];
      return arguments.length ? (s = w.isFunction(e), this.each(function (t) {
        1 === this.nodeType && (null == (t = s ? e.call(this, t, w(this).val()) : e) ? t = "" : "number" == typeof t ? t += "" : w.isArray(t) && (t = w.map(t, function (t) {
          return null == t ? "" : t + ""
        })), (i = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()]) && "set" in i && void 0 !== i.set(this, t, "value") || (this.value = t))
      })) : n ? (i = w.valHooks[n.type] || w.valHooks[n.nodeName.toLowerCase()]) && "get" in i && void 0 !== (t = i.get(n, "value")) ? t : "string" == typeof (t = n.value) ? t.replace(me, "") : null == t ? "" : t : void 0
    }
  }), w.extend({
    valHooks: {
      option: {
        get: function (t) {
          var e = w.find.attr(t, "value");
          return null != e ? e : w.text(t)
        }
      },
      select: {
        get: function (t) {
          for (var e, i = t.options, s = t.selectedIndex, n = "select-one" === t.type || s < 0, a = n ? null : [], o = n ? s + 1 : i.length, r = s < 0 ? o : n ? s : 0; r < o; r++)
            if (!(!(e = i[r]).selected && r !== s || (v.optDisabled ? e.disabled : null !== e.getAttribute("disabled")) || e.parentNode.disabled && w.nodeName(e.parentNode, "optgroup"))) {
              if (e = w(e).val(), n) return e;
              a.push(e)
            } return a
        },
        set: function (t, e) {
          for (var i, s, n = t.options, a = w.makeArray(e), o = n.length; o--;)
            if (s = n[o], 0 <= w.inArray(w.valHooks.option.get(s), a)) try {
              s.selected = i = !0
            } catch (t) {
              s.scrollHeight
            } else s.selected = !1;
          return i || (t.selectedIndex = -1), n
        }
      }
    }
  }), w.each(["radio", "checkbox"], function () {
    w.valHooks[this] = {
      set: function (t, e) {
        return w.isArray(e) ? t.checked = 0 <= w.inArray(w(t).val(), e) : void 0
      }
    }, v.checkOn || (w.valHooks[this].get = function (t) {
      return null === t.getAttribute("value") ? "on" : t.value
    })
  });
  var ge, ve, be = w.expr.attrHandle,
    _e = /^(?:checked|selected)$/i,
    ye = v.getSetAttribute,
    we = v.input;
  w.fn.extend({
    attr: function (t, e) {
      return Y(this, w.attr, t, e, 1 < arguments.length)
    },
    removeAttr: function (t) {
      return this.each(function () {
        w.removeAttr(this, t)
      })
    }
  }), w.extend({
    attr: function (t, e, i) {
      var s, n, a = t.nodeType;
      if (t && 3 !== a && 8 !== a && 2 !== a) return typeof t.getAttribute === N ? w.prop(t, e, i) : (1 === a && w.isXMLDoc(t) || (e = e.toLowerCase(), s = w.attrHooks[e] || (w.expr.match.bool.test(e) ? ve : ge)), void 0 === i ? s && "get" in s && null !== (n = s.get(t, e)) ? n : null == (n = w.find.attr(t, e)) ? void 0 : n : null !== i ? s && "set" in s && void 0 !== (n = s.set(t, i, e)) ? n : (t.setAttribute(e, i + ""), i) : void w.removeAttr(t, e))
    },
    removeAttr: function (t, e) {
      var i, s, n = 0,
        a = e && e.match(P);
      if (a && 1 === t.nodeType)
        for (; i = a[n++];) s = w.propFix[i] || i, w.expr.match.bool.test(i) ? we && ye || !_e.test(i) ? t[s] = !1 : t[w.camelCase("default-" + i)] = t[s] = !1 : w.attr(t, i, ""), t.removeAttribute(ye ? i : s)
    },
    attrHooks: {
      type: {
        set: function (t, e) {
          if (!v.radioValue && "radio" === e && w.nodeName(t, "input")) {
            var i = t.value;
            return t.setAttribute("type", e), i && (t.value = i), e
          }
        }
      }
    }
  }), ve = {
    set: function (t, e, i) {
      return !1 === e ? w.removeAttr(t, i) : we && ye || !_e.test(i) ? t.setAttribute(!ye && w.propFix[i] || i, i) : t[w.camelCase("default-" + i)] = t[i] = !0, i
    }
  }, w.each(w.expr.match.bool.source.match(/\w+/g), function (t, e) {
    var a = be[e] || w.find.attr;
    be[e] = we && ye || !_e.test(e) ? function (t, e, i) {
      var s, n;
      return i || (n = be[e], be[e] = s, s = null != a(t, e, i) ? e.toLowerCase() : null, be[e] = n), s
    } : function (t, e, i) {
      return i ? void 0 : t[w.camelCase("default-" + e)] ? e.toLowerCase() : null
    }
  }), we && ye || (w.attrHooks.value = {
    set: function (t, e, i) {
      return w.nodeName(t, "input") ? void(t.defaultValue = e) : ge && ge.set(t, e, i)
    }
  }), ye || (ge = {
    set: function (t, e, i) {
      var s = t.getAttributeNode(i);
      return s || t.setAttributeNode(s = t.ownerDocument.createAttribute(i)), s.value = e += "", "value" === i || e === t.getAttribute(i) ? e : void 0
    }
  }, be.id = be.name = be.coords = function (t, e, i) {
    return i ? void 0 : (e = t.getAttributeNode(e)) && "" !== e.value ? e.value : null
  }, w.valHooks.button = {
    get: function (t, e) {
      e = t.getAttributeNode(e);
      return e && e.specified ? e.value : void 0
    },
    set: ge.set
  }, w.attrHooks.contenteditable = {
    set: function (t, e, i) {
      ge.set(t, "" !== e && e, i)
    }
  }, w.each(["width", "height"], function (t, i) {
    w.attrHooks[i] = {
      set: function (t, e) {
        return "" === e ? (t.setAttribute(i, "auto"), e) : void 0
      }
    }
  })), v.style || (w.attrHooks.style = {
    get: function (t) {
      return t.style.cssText || void 0
    },
    set: function (t, e) {
      return t.style.cssText = e + ""
    }
  });
  var xe = /^(?:input|select|textarea|button|object)$/i,
    Ce = /^(?:a|area)$/i;
  w.fn.extend({
    prop: function (t, e) {
      return Y(this, w.prop, t, e, 1 < arguments.length)
    },
    removeProp: function (t) {
      return t = w.propFix[t] || t, this.each(function () {
        try {
          this[t] = void 0, delete this[t]
        } catch (t) {}
      })
    }
  }), w.extend({
    propFix: {
      for: "htmlFor",
      class: "className"
    },
    prop: function (t, e, i) {
      var s, n, a = t.nodeType;
      if (t && 3 !== a && 8 !== a && 2 !== a) return (1 !== a || !w.isXMLDoc(t)) && (e = w.propFix[e] || e, n = w.propHooks[e]), void 0 !== i ? n && "set" in n && void 0 !== (s = n.set(t, i, e)) ? s : t[e] = i : n && "get" in n && null !== (s = n.get(t, e)) ? s : t[e]
    },
    propHooks: {
      tabIndex: {
        get: function (t) {
          var e = w.find.attr(t, "tabindex");
          return e ? parseInt(e, 10) : xe.test(t.nodeName) || Ce.test(t.nodeName) && t.href ? 0 : -1
        }
      }
    }
  }), v.hrefNormalized || w.each(["href", "src"], function (t, e) {
    w.propHooks[e] = {
      get: function (t) {
        return t.getAttribute(e, 4)
      }
    }
  }), v.optSelected || (w.propHooks.selected = {
    get: function (t) {
      t = t.parentNode;
      return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null
    }
  }), w.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    w.propFix[this.toLowerCase()] = this
  }), v.enctype || (w.propFix.enctype = "encoding");
  var ke = /[\t\r\n\f]/g;
  w.fn.extend({
    addClass: function (e) {
      var t, i, s, n, a, o, r = 0,
        l = this.length,
        c = "string" == typeof e && e;
      if (w.isFunction(e)) return this.each(function (t) {
        w(this).addClass(e.call(this, t, this.className))
      });
      if (c)
        for (t = (e || "").match(P) || []; r < l; r++)
          if (s = 1 === (i = this[r]).nodeType && (i.className ? (" " + i.className + " ").replace(ke, " ") : " ")) {
            for (a = 0; n = t[a++];) s.indexOf(" " + n + " ") < 0 && (s += n + " ");
            o = w.trim(s), i.className !== o && (i.className = o)
          } return this
    },
    removeClass: function (e) {
      var t, i, s, n, a, o, r = 0,
        l = this.length,
        c = 0 === arguments.length || "string" == typeof e && e;
      if (w.isFunction(e)) return this.each(function (t) {
        w(this).removeClass(e.call(this, t, this.className))
      });
      if (c)
        for (t = (e || "").match(P) || []; r < l; r++)
          if (s = 1 === (i = this[r]).nodeType && (i.className ? (" " + i.className + " ").replace(ke, " ") : "")) {
            for (a = 0; n = t[a++];)
              for (; 0 <= s.indexOf(" " + n + " ");) s = s.replace(" " + n + " ", " ");
            o = e ? w.trim(s) : "", i.className !== o && (i.className = o)
          } return this
    },
    toggleClass: function (n, e) {
      var a = typeof n;
      return "boolean" == typeof e && "string" == a ? e ? this.addClass(n) : this.removeClass(n) : this.each(w.isFunction(n) ? function (t) {
        w(this).toggleClass(n.call(this, t, this.className, e), e)
      } : function () {
        if ("string" == a)
          for (var t, e = 0, i = w(this), s = n.match(P) || []; t = s[e++];) i.hasClass(t) ? i.removeClass(t) : i.addClass(t);
        else a !== N && "boolean" != a || (this.className && w._data(this, "__className__", this.className), this.className = !this.className && !1 !== n && w._data(this, "__className__") || "")
      })
    },
    hasClass: function (t) {
      for (var e = " " + t + " ", i = 0, s = this.length; i < s; i++)
        if (1 === this[i].nodeType && 0 <= (" " + this[i].className + " ").replace(ke, " ").indexOf(e)) return !0;
      return !1
    }
  }), w.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (t, i) {
    w.fn[i] = function (t, e) {
      return 0 < arguments.length ? this.on(i, null, t, e) : this.trigger(i)
    }
  }), w.fn.extend({
    hover: function (t, e) {
      return this.mouseenter(t).mouseleave(e || t)
    },
    bind: function (t, e, i) {
      return this.on(t, null, e, i)
    },
    unbind: function (t, e) {
      return this.off(t, null, e)
    },
    delegate: function (t, e, i, s) {
      return this.on(e, t, i, s)
    },
    undelegate: function (t, e, i) {
      return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", i)
    }
  });
  var Te = w.now(),
    De = /\?/,
    Se = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
  w.parseJSON = function (t) {
    if (f.JSON && f.JSON.parse) return f.JSON.parse(t + "");
    var n, a = null,
      e = w.trim(t + "");
    return e && !w.trim(e.replace(Se, function (t, e, i, s) {
      return 0 === (a = n && e ? 0 : a) ? t : (n = i || e, a += !s - !i, "")
    })) ? Function("return " + e)() : w.error("Invalid JSON: " + t)
  }, w.parseXML = function (t) {
    var e;
    if (!t || "string" != typeof t) return null;
    try {
      f.DOMParser ? e = (new DOMParser).parseFromString(t, "text/xml") : ((e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t))
    } catch (t) {
      e = void 0
    }
    return e && e.documentElement && !e.getElementsByTagName("parsererror").length || w.error("Invalid XML: " + t), e
  };
  var Me, Ee, Ae = /#.*$/,
    Pe = /([?&])_=[^&]*/,
    Ie = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
    Oe = /^(?:GET|HEAD)$/,
    $e = /^\/\//,
    Le = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    Ne = {},
    He = {},
    Fe = "*/".concat("*");
  try {
    Ee = location.href
  } catch (t) {
    (Ee = k.createElement("a")).href = "", Ee = Ee.href
  }

  function ze(a) {
    return function (t, e) {
      "string" != typeof t && (e = t, t = "*");
      var i, s = 0,
        n = t.toLowerCase().match(P) || [];
      if (w.isFunction(e))
        for (; i = n[s++];) "+" === i.charAt(0) ? (i = i.slice(1) || "*", (a[i] = a[i] || []).unshift(e)) : (a[i] = a[i] || []).push(e)
    }
  }

  function Re(e, s, n, a) {
    var o = {},
      r = e === He;

    function l(t) {
      var i;
      return o[t] = !0, w.each(e[t] || [], function (t, e) {
        e = e(s, n, a);
        return "string" != typeof e || r || o[e] ? r ? !(i = e) : void 0 : (s.dataTypes.unshift(e), l(e), !1)
      }), i
    }
    return l(s.dataTypes[0]) || !o["*"] && l("*")
  }

  function Be(t, e) {
    var i, s, n = w.ajaxSettings.flatOptions || {};
    for (s in e) void 0 !== e[s] && ((n[s] ? t : i = i || {})[s] = e[s]);
    return i && w.extend(!0, t, i), t
  }
  Me = Le.exec(Ee.toLowerCase()) || [], w.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: Ee,
      type: "GET",
      isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Me[1]),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": Fe,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": w.parseJSON,
        "text xml": w.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function (t, e) {
      return e ? Be(Be(t, w.ajaxSettings), e) : Be(w.ajaxSettings, t)
    },
    ajaxPrefilter: ze(Ne),
    ajaxTransport: ze(He),
    ajax: function (t, e) {
      "object" == typeof t && (e = t, t = void 0);
      var i, l, c, d, h, u, s, p = w.ajaxSetup({}, e = e || {}),
        f = p.context || p,
        m = p.context && (f.nodeType || f.jquery) ? w(f) : w.event,
        g = w.Deferred(),
        v = w.Callbacks("once memory"),
        b = p.statusCode || {},
        n = {},
        a = {},
        _ = 0,
        o = "canceled",
        y = {
          readyState: 0,
          getResponseHeader: function (t) {
            var e;
            if (2 === _) {
              if (!s)
                for (s = {}; e = Ie.exec(c);) s[e[1].toLowerCase()] = e[2];
              e = s[t.toLowerCase()]
            }
            return null == e ? null : e
          },
          getAllResponseHeaders: function () {
            return 2 === _ ? c : null
          },
          setRequestHeader: function (t, e) {
            var i = t.toLowerCase();
            return _ || (t = a[i] = a[i] || t, n[t] = e), this
          },
          overrideMimeType: function (t) {
            return _ || (p.mimeType = t), this
          },
          statusCode: function (t) {
            if (t)
              if (_ < 2)
                for (var e in t) b[e] = [b[e], t[e]];
              else y.always(t[y.status]);
            return this
          },
          abort: function (t) {
            t = t || o;
            return u && u.abort(t), r(0, t), this
          }
        };
      if (g.promise(y).complete = v.add, y.success = y.done, y.error = y.fail, p.url = ((t || p.url || Ee) + "").replace(Ae, "").replace($e, Me[1] + "//"), p.type = e.method || e.type || p.method || p.type, p.dataTypes = w.trim(p.dataType || "*").toLowerCase().match(P) || [""], null == p.crossDomain && (t = Le.exec(p.url.toLowerCase()), p.crossDomain = !(!t || t[1] === Me[1] && t[2] === Me[2] && (t[3] || ("http:" === t[1] ? "80" : "443")) === (Me[3] || ("http:" === Me[1] ? "80" : "443")))), p.data && p.processData && "string" != typeof p.data && (p.data = w.param(p.data, p.traditional)), Re(Ne, p, e, y), 2 === _) return y;
      for (i in (h = p.global) && 0 == w.active++ && w.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Oe.test(p.type), l = p.url, p.hasContent || (p.data && (l = p.url += (De.test(l) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (p.url = Pe.test(l) ? l.replace(Pe, "$1_=" + Te++) : l + (De.test(l) ? "&" : "?") + "_=" + Te++)), p.ifModified && (w.lastModified[l] && y.setRequestHeader("If-Modified-Since", w.lastModified[l]), w.etag[l] && y.setRequestHeader("If-None-Match", w.etag[l])), (p.data && p.hasContent && !1 !== p.contentType || e.contentType) && y.setRequestHeader("Content-Type", p.contentType), y.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Fe + "; q=0.01" : "") : p.accepts["*"]), p.headers) y.setRequestHeader(i, p.headers[i]);
      if (p.beforeSend && (!1 === p.beforeSend.call(f, y, p) || 2 === _)) return y.abort();
      for (i in o = "abort", {
          success: 1,
          error: 1,
          complete: 1
        }) y[i](p[i]);
      if (u = Re(He, p, e, y)) {
        y.readyState = 1, h && m.trigger("ajaxSend", [y, p]), p.async && 0 < p.timeout && (d = setTimeout(function () {
          y.abort("timeout")
        }, p.timeout));
        try {
          _ = 1, u.send(n, r)
        } catch (t) {
          if (!(_ < 2)) throw t;
          r(-1, t)
        }
      } else r(-1, "No Transport");

      function r(t, e, i, s) {
        var n, a, o, r = e;
        2 !== _ && (_ = 2, d && clearTimeout(d), u = void 0, c = s || "", y.readyState = 0 < t ? 4 : 0, s = 200 <= t && t < 300 || 304 === t, i && (o = function (t, e, i) {
          for (var s, n, a, o, r = t.contents, l = t.dataTypes;
            "*" === l[0];) l.shift(), void 0 === n && (n = t.mimeType || e.getResponseHeader("Content-Type"));
          if (n)
            for (o in r)
              if (r[o] && r[o].test(n)) {
                l.unshift(o);
                break
              } if (l[0] in i) a = l[0];
          else {
            for (o in i) {
              if (!l[0] || t.converters[o + " " + l[0]]) {
                a = o;
                break
              }
              s = s || o
            }
            a = a || s
          }
          return a ? (a !== l[0] && l.unshift(a), i[a]) : void 0
        }(p, y, i)), o = function (t, e, i, s) {
          var n, a, o, r, l, c = {},
            d = t.dataTypes.slice();
          if (d[1])
            for (o in t.converters) c[o.toLowerCase()] = t.converters[o];
          for (a = d.shift(); a;)
            if (t.responseFields[a] && (i[t.responseFields[a]] = e), !l && s && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = a, a = d.shift())
              if ("*" === a) a = l;
              else if ("*" !== l && l !== a) {
            if (!(o = c[l + " " + a] || c["* " + a]))
              for (n in c)
                if (r = n.split(" "), r[1] === a && (o = c[l + " " + r[0]] || c["* " + r[0]])) {
                  !0 === o ? o = c[n] : !0 !== c[n] && (a = r[0], d.unshift(r[1]));
                  break
                } if (!0 !== o)
              if (o && t.throws) e = o(e);
              else try {
                e = o(e)
              } catch (t) {
                return {
                  state: "parsererror",
                  error: o ? t : "No conversion from " + l + " to " + a
                }
              }
          }
          return {
            state: "success",
            data: e
          }
        }(p, o, y, s), s ? (p.ifModified && ((i = y.getResponseHeader("Last-Modified")) && (w.lastModified[l] = i), (i = y.getResponseHeader("etag")) && (w.etag[l] = i)), 204 === t || "HEAD" === p.type ? r = "nocontent" : 304 === t ? r = "notmodified" : (r = o.state, n = o.data, s = !(a = o.error))) : (a = r, !t && r || (r = "error", t < 0 && (t = 0))), y.status = t, y.statusText = (e || r) + "", s ? g.resolveWith(f, [n, r, y]) : g.rejectWith(f, [y, r, a]), y.statusCode(b), b = void 0, h && m.trigger(s ? "ajaxSuccess" : "ajaxError", [y, p, s ? n : a]), v.fireWith(f, [y, r]), h && (m.trigger("ajaxComplete", [y, p]), --w.active || w.event.trigger("ajaxStop")))
      }
      return y
    },
    getJSON: function (t, e, i) {
      return w.get(t, e, i, "json")
    },
    getScript: function (t, e) {
      return w.get(t, void 0, e, "script")
    }
  }), w.each(["get", "post"], function (t, n) {
    w[n] = function (t, e, i, s) {
      return w.isFunction(e) && (s = s || i, i = e, e = void 0), w.ajax({
        url: t,
        type: n,
        dataType: s,
        data: e,
        success: i
      })
    }
  }), w.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (t, e) {
    w.fn[e] = function (t) {
      return this.on(e, t)
    }
  }), w._evalUrl = function (t) {
    return w.ajax({
      url: t,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      throws: !0
    })
  }, w.fn.extend({
    wrapAll: function (e) {
      return w.isFunction(e) ? this.each(function (t) {
        w(this).wrapAll(e.call(this, t))
      }) : (this[0] && (t = w(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function () {
        for (var t = this; t.firstChild && 1 === t.firstChild.nodeType;) t = t.firstChild;
        return t
      }).append(this)), this);
      var t
    },
    wrapInner: function (i) {
      return this.each(w.isFunction(i) ? function (t) {
        w(this).wrapInner(i.call(this, t))
      } : function () {
        var t = w(this),
          e = t.contents();
        e.length ? e.wrapAll(i) : t.append(i)
      })
    },
    wrap: function (e) {
      var i = w.isFunction(e);
      return this.each(function (t) {
        w(this).wrapAll(i ? e.call(this, t) : e)
      })
    },
    unwrap: function () {
      return this.parent().each(function () {
        w.nodeName(this, "body") || w(this).replaceWith(this.childNodes)
      }).end()
    }
  }), w.expr.filters.hidden = function (t) {
    return t.offsetWidth <= 0 && t.offsetHeight <= 0 || !v.reliableHiddenOffsets() && "none" === (t.style && t.style.display || w.css(t, "display"))
  }, w.expr.filters.visible = function (t) {
    return !w.expr.filters.hidden(t)
  };
  var je = /%20/g,
    We = /\[\]$/,
    Ve = /\r?\n/g,
    qe = /^(?:submit|button|image|reset|file)$/i,
    Ye = /^(?:input|select|textarea|keygen)/i;
  w.param = function (t, e) {
    function i(t, e) {
      e = w.isFunction(e) ? e() : null == e ? "" : e, n[n.length] = encodeURIComponent(t) + "=" + encodeURIComponent(e)
    }
    var s, n = [];
    if (void 0 === e && (e = w.ajaxSettings && w.ajaxSettings.traditional), w.isArray(t) || t.jquery && !w.isPlainObject(t)) w.each(t, function () {
      i(this.name, this.value)
    });
    else
      for (s in t) ! function i(s, t, n, a) {
        if (w.isArray(t)) w.each(t, function (t, e) {
          n || We.test(s) ? a(s, e) : i(s + "[" + ("object" == typeof e ? t : "") + "]", e, n, a)
        });
        else if (n || "object" !== w.type(t)) a(s, t);
        else
          for (var e in t) i(s + "[" + e + "]", t[e], n, a)
      }(s, t[s], e, i);
    return n.join("&").replace(je, "+")
  }, w.fn.extend({
    serialize: function () {
      return w.param(this.serializeArray())
    },
    serializeArray: function () {
      return this.map(function () {
        var t = w.prop(this, "elements");
        return t ? w.makeArray(t) : this
      }).filter(function () {
        var t = this.type;
        return this.name && !w(this).is(":disabled") && Ye.test(this.nodeName) && !qe.test(t) && (this.checked || !U.test(t))
      }).map(function (t, e) {
        var i = w(this).val();
        return null == i ? null : w.isArray(i) ? w.map(i, function (t) {
          return {
            name: e.name,
            value: t.replace(Ve, "\r\n")
          }
        }) : {
          name: e.name,
          value: i.replace(Ve, "\r\n")
        }
      }).get()
    }
  }), w.ajaxSettings.xhr = void 0 !== f.ActiveXObject ? function () {
    return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Ke() || function () {
      try {
        return new f.ActiveXObject("Microsoft.XMLHTTP")
      } catch (t) {}
    }()
  } : Ke;
  var Ue = 0,
    Xe = {},
    Ge = w.ajaxSettings.xhr();

  function Ke() {
    try {
      return new f.XMLHttpRequest
    } catch (t) {}
  }
  f.ActiveXObject && w(f).on("unload", function () {
    for (var t in Xe) Xe[t](void 0, !0)
  }), v.cors = !!Ge && "withCredentials" in Ge, (Ge = v.ajax = !!Ge) && w.ajaxTransport(function (l) {
    var c;
    if (!l.crossDomain || v.cors) return {
      send: function (t, a) {
        var e, o = l.xhr(),
          r = ++Ue;
        if (o.open(l.type, l.url, l.async, l.username, l.password), l.xhrFields)
          for (e in l.xhrFields) o[e] = l.xhrFields[e];
        for (e in l.mimeType && o.overrideMimeType && o.overrideMimeType(l.mimeType), l.crossDomain || t["X-Requested-With"] || (t["X-Requested-With"] = "XMLHttpRequest"), t) void 0 !== t[e] && o.setRequestHeader(e, t[e] + "");
        o.send(l.hasContent && l.data || null), c = function (t, e) {
          var i, s, n;
          if (c && (e || 4 === o.readyState))
            if (delete Xe[r], c = void 0, o.onreadystatechange = w.noop, e) 4 !== o.readyState && o.abort();
            else {
              n = {}, i = o.status, "string" == typeof o.responseText && (n.text = o.responseText);
              try {
                s = o.statusText
              } catch (t) {
                s = ""
              }
              i || !l.isLocal || l.crossDomain ? 1223 === i && (i = 204) : i = n.text ? 200 : 404
            } n && a(i, s, n, o.getAllResponseHeaders())
        }, l.async ? 4 === o.readyState ? setTimeout(c) : o.onreadystatechange = Xe[r] = c : c()
      },
      abort: function () {
        c && c(void 0, !0)
      }
    }
  }), w.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function (t) {
        return w.globalEval(t), t
      }
    }
  }), w.ajaxPrefilter("script", function (t) {
    void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET", t.global = !1)
  }), w.ajaxTransport("script", function (e) {
    if (e.crossDomain) {
      var s, n = k.head || w("head")[0] || k.documentElement;
      return {
        send: function (t, i) {
          (s = k.createElement("script")).async = !0, e.scriptCharset && (s.charset = e.scriptCharset), s.src = e.url, s.onload = s.onreadystatechange = function (t, e) {
            !e && s.readyState && !/loaded|complete/.test(s.readyState) || (s.onload = s.onreadystatechange = null, s.parentNode && s.parentNode.removeChild(s), s = null, e || i(200, "success"))
          }, n.insertBefore(s, n.firstChild)
        },
        abort: function () {
          s && s.onload(void 0, !0)
        }
      }
    }
  });
  var Qe = [],
    Je = /(=)\?(?=&|$)|\?\?/;
  w.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var t = Qe.pop() || w.expando + "_" + Te++;
      return this[t] = !0, t
    }
  }), w.ajaxPrefilter("json jsonp", function (t, e, i) {
    var s, n, a, o = !1 !== t.jsonp && (Je.test(t.url) ? "url" : "string" == typeof t.data && !(t.contentType || "").indexOf("application/x-www-form-urlencoded") && Je.test(t.data) && "data");
    return o || "jsonp" === t.dataTypes[0] ? (s = t.jsonpCallback = w.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, o ? t[o] = t[o].replace(Je, "$1" + s) : !1 !== t.jsonp && (t.url += (De.test(t.url) ? "&" : "?") + t.jsonp + "=" + s), t.converters["script json"] = function () {
      return a || w.error(s + " was not called"), a[0]
    }, t.dataTypes[0] = "json", n = f[s], f[s] = function () {
      a = arguments
    }, i.always(function () {
      f[s] = n, t[s] && (t.jsonpCallback = e.jsonpCallback, Qe.push(s)), a && w.isFunction(n) && n(a[0]), a = n = void 0
    }), "script") : void 0
  }), w.parseHTML = function (t, e, i) {
    if (!t || "string" != typeof t) return null;
    "boolean" == typeof e && (i = e, e = !1), e = e || k;
    var s = y.exec(t),
      i = !i && [];
    return s ? [e.createElement(s[1])] : (s = w.buildFragment([t], e, i), i && i.length && w(i).remove(), w.merge([], s.childNodes))
  };
  var Ze = w.fn.load;
  w.fn.load = function (t, e, i) {
    if ("string" != typeof t && Ze) return Ze.apply(this, arguments);
    var s, n, a, o = this,
      r = t.indexOf(" ");
    return 0 <= r && (s = t.slice(r, t.length), t = t.slice(0, r)), w.isFunction(e) ? (i = e, e = void 0) : e && "object" == typeof e && (a = "POST"), 0 < o.length && w.ajax({
      url: t,
      type: a,
      dataType: "html",
      data: e
    }).done(function (t) {
      n = arguments, o.html(s ? w("<div>").append(w.parseHTML(t)).find(s) : t)
    }).complete(i && function (t, e) {
      o.each(i, n || [t.responseText, e, t])
    }), this
  }, w.expr.filters.animated = function (e) {
    return w.grep(w.timers, function (t) {
      return e === t.elem
    }).length
  };
  var ti = f.document.documentElement;

  function ei(t) {
    return w.isWindow(t) ? t : 9 === t.nodeType && (t.defaultView || t.parentWindow)
  }
  w.offset = {
    setOffset: function (t, e, i) {
      var s, n, a, o, r = w.css(t, "position"),
        l = w(t),
        c = {};
      "static" === r && (t.style.position = "relative"), a = l.offset(), s = w.css(t, "top"), o = w.css(t, "left"), o = ("absolute" === r || "fixed" === r) && -1 < w.inArray("auto", [s, o]) ? (n = (r = l.position()).top, r.left) : (n = parseFloat(s) || 0, parseFloat(o) || 0), null != (e = w.isFunction(e) ? e.call(t, i, a) : e).top && (c.top = e.top - a.top + n), null != e.left && (c.left = e.left - a.left + o), "using" in e ? e.using.call(t, c) : l.css(c)
    }
  }, w.fn.extend({
    offset: function (e) {
      if (arguments.length) return void 0 === e ? this : this.each(function (t) {
        w.offset.setOffset(this, e, t)
      });
      var t, i = {
          top: 0,
          left: 0
        },
        s = this[0],
        n = s && s.ownerDocument;
      return n ? (t = n.documentElement, w.contains(t, s) ? (typeof s.getBoundingClientRect !== N && (i = s.getBoundingClientRect()), n = ei(n), {
        top: i.top + (n.pageYOffset || t.scrollTop) - (t.clientTop || 0),
        left: i.left + (n.pageXOffset || t.scrollLeft) - (t.clientLeft || 0)
      }) : i) : void 0
    },
    position: function () {
      if (this[0]) {
        var t, e, i = {
            top: 0,
            left: 0
          },
          s = this[0];
        return "fixed" === w.css(s, "position") ? e = s.getBoundingClientRect() : (t = this.offsetParent(), e = this.offset(), (i = !w.nodeName(t[0], "html") ? t.offset() : i).top += w.css(t[0], "borderTopWidth", !0), i.left += w.css(t[0], "borderLeftWidth", !0)), {
          top: e.top - i.top - w.css(s, "marginTop", !0),
          left: e.left - i.left - w.css(s, "marginLeft", !0)
        }
      }
    },
    offsetParent: function () {
      return this.map(function () {
        for (var t = this.offsetParent || ti; t && !w.nodeName(t, "html") && "static" === w.css(t, "position");) t = t.offsetParent;
        return t || ti
      })
    }
  }), w.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (e, n) {
    var a = /Y/.test(n);
    w.fn[e] = function (t) {
      return Y(this, function (t, e, i) {
        var s = ei(t);
        return void 0 === i ? s ? n in s ? s[n] : s.document.documentElement[e] : t[e] : void(s ? s.scrollTo(a ? w(s).scrollLeft() : i, a ? i : w(s).scrollTop()) : t[e] = i)
      }, e, t, arguments.length, null)
    }
  }), w.each(["top", "left"], function (t, i) {
    w.cssHooks[i] = Bt(v.pixelPosition, function (t, e) {
      return e ? (e = Pt(t, i), zt.test(e) ? w(t).position()[i] + "px" : e) : void 0
    })
  }), w.each({
    Height: "height",
    Width: "width"
  }, function (a, o) {
    w.each({
      padding: "inner" + a,
      content: o,
      "": "outer" + a
    }, function (s, t) {
      w.fn[t] = function (t, e) {
        var i = arguments.length && (s || "boolean" != typeof t),
          n = s || (!0 === t || !0 === e ? "margin" : "border");
        return Y(this, function (t, e, i) {
          var s;
          return w.isWindow(t) ? t.document.documentElement["client" + a] : 9 === t.nodeType ? (s = t.documentElement, Math.max(t.body["scroll" + a], s["scroll" + a], t.body["offset" + a], s["offset" + a], s["client" + a])) : void 0 === i ? w.css(t, e, n) : w.style(t, e, i, n)
        }, o, i ? t : void 0, i, null)
      }
    })
  }), w.fn.size = function () {
    return this.length
  }, w.fn.andSelf = w.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () {
    return w
  });
  var ii = f.jQuery,
    si = f.$;
  return w.noConflict = function (t) {
    return f.$ === w && (f.$ = si), t && f.jQuery === w && (f.jQuery = ii), w
  }, typeof t === N && (f.jQuery = f.$ = w), w
}),
function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports, require("jquery")) : "function" == typeof define && define.amd ? define(["exports", "jquery"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = {}, t.jQuery)
}(this, function (t, e) {
  "use strict";
  var i, d = (i = e) && "object" == typeof i && "default" in i ? i : {
    default: i
  };

  function s(t, e) {
    for (var i = 0; i < e.length; i++) {
      var s = e[i];
      s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
    }
  }

  function n(t, e, i) {
    return e && s(t.prototype, e), i && s(t, i), t
  }

  function a() {
    return (a = Object.assign || function (t) {
      for (var e = 1; e < arguments.length; e++) {
        var i, s = arguments[e];
        for (i in s) Object.prototype.hasOwnProperty.call(s, i) && (t[i] = s[i])
      }
      return t
    }).apply(this, arguments)
  }
  var h = {
    TRANSITION_END: "bsTransitionEnd",
    getUID: function (t) {
      for (; t += ~~(1e6 * Math.random()), document.getElementById(t););
      return t
    },
    getSelectorFromElement: function (t) {
      var e, i = t.getAttribute("data-target");
      i && "#" !== i || (i = (e = t.getAttribute("href")) && "#" !== e ? e.trim() : "");
      try {
        return document.querySelector(i) ? i : null
      } catch (t) {
        return null
      }
    },
    getTransitionDurationFromElement: function (t) {
      if (!t) return 0;
      var e = d.default(t).css("transition-duration"),
        i = d.default(t).css("transition-delay"),
        s = parseFloat(e),
        t = parseFloat(i);
      return s || t ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (parseFloat(e) + parseFloat(i))) : 0
    },
    reflow: function (t) {
      return t.offsetHeight
    },
    triggerTransitionEnd: function (t) {
      d.default(t).trigger("transitionend")
    },
    supportsTransitionEnd: function () {
      return Boolean("transitionend")
    },
    isElement: function (t) {
      return (t[0] || t).nodeType
    },
    typeCheckConfig: function (t, e, i) {
      for (var s in i)
        if (Object.prototype.hasOwnProperty.call(i, s)) {
          var n = i[s],
            a = e[s],
            a = a && h.isElement(a) ? "element" : null === a || void 0 === a ? "" + a : {}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase();
          if (!new RegExp(n).test(a)) throw new Error(t.toUpperCase() + ': Option "' + s + '" provided type "' + a + '" but expected type "' + n + '".')
        }
    },
    findShadowRoot: function (t) {
      if (!document.documentElement.attachShadow) return null;
      if ("function" != typeof t.getRootNode) return t instanceof ShadowRoot ? t : t.parentNode ? h.findShadowRoot(t.parentNode) : null;
      t = t.getRootNode();
      return t instanceof ShadowRoot ? t : null
    },
    jQueryDetection: function () {
      if (void 0 === d.default) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
      var t = d.default.fn.jquery.split(" ")[0].split(".");
      if (t[0] < 2 && t[1] < 9 || 1 === t[0] && 9 === t[1] && t[2] < 1 || 4 <= t[0]) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")
    }
  };
  h.jQueryDetection(), d.default.fn.emulateTransitionEnd = function (t) {
    var e = this,
      i = !1;
    return d.default(this).one(h.TRANSITION_END, function () {
      i = !0
    }), setTimeout(function () {
      i || h.triggerTransitionEnd(e)
    }, t), this
  }, d.default.event.special[h.TRANSITION_END] = {
    bindType: "transitionend",
    delegateType: "transitionend",
    handle: function (t) {
      if (d.default(t.target).is(this)) return t.handleObj.handler.apply(this, arguments)
    }
  };
  var o = "alert",
    r = d.default.fn[o],
    l = ((yt = c.prototype).close = function (t) {
      var e = this._element;
      t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e)
    }, yt.dispose = function () {
      d.default.removeData(this._element, "bs.alert"), this._element = null
    }, yt._getRootElement = function (t) {
      var e = h.getSelectorFromElement(t),
        i = !1;
      return i = (i = e ? document.querySelector(e) : i) || d.default(t).closest(".alert")[0]
    }, yt._triggerCloseEvent = function (t) {
      var e = d.default.Event("close.bs.alert");
      return d.default(t).trigger(e), e
    }, yt._removeElement = function (e) {
      var t, i = this;
      d.default(e).removeClass("show"), d.default(e).hasClass("fade") ? (t = h.getTransitionDurationFromElement(e), d.default(e).one(h.TRANSITION_END, function (t) {
        return i._destroyElement(e, t)
      }).emulateTransitionEnd(t)) : this._destroyElement(e)
    }, yt._destroyElement = function (t) {
      d.default(t).detach().trigger("closed.bs.alert").remove()
    }, c._jQueryInterface = function (i) {
      return this.each(function () {
        var t = d.default(this),
          e = t.data("bs.alert");
        e || (e = new c(this), t.data("bs.alert", e)), "close" === i && e[i](this)
      })
    }, c._handleDismiss = function (e) {
      return function (t) {
        t && t.preventDefault(), e.close(this)
      }
    }, n(c, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }]), c);

  function c(t) {
    this._element = t
  }
  d.default(document).on("click.bs.alert.data-api", '[data-dismiss="alert"]', l._handleDismiss(new l)), d.default.fn[o] = l._jQueryInterface, d.default.fn[o].Constructor = l, d.default.fn[o].noConflict = function () {
    return d.default.fn[o] = r, l._jQueryInterface
  };
  var u = d.default.fn.button,
    p = ((X = f.prototype).toggle = function () {
      var t, e = !0,
        i = !0,
        s = d.default(this._element).closest('[data-toggle="buttons"]')[0];
      !s || (t = this._element.querySelector('input:not([type="hidden"])')) && ("radio" === t.type && (t.checked && this._element.classList.contains("active") ? e = !1 : (s = s.querySelector(".active")) && d.default(s).removeClass("active")), e && ("checkbox" !== t.type && "radio" !== t.type || (t.checked = !this._element.classList.contains("active")), this.shouldAvoidTriggerChange || d.default(t).trigger("change")), t.focus(), i = !1), this._element.hasAttribute("disabled") || this._element.classList.contains("disabled") || (i && this._element.setAttribute("aria-pressed", !this._element.classList.contains("active")), e && d.default(this._element).toggleClass("active"))
    }, X.dispose = function () {
      d.default.removeData(this._element, "bs.button"), this._element = null
    }, f._jQueryInterface = function (i, s) {
      return this.each(function () {
        var t = d.default(this),
          e = t.data("bs.button");
        e || (e = new f(this), t.data("bs.button", e)), e.shouldAvoidTriggerChange = s, "toggle" === i && e[i]()
      })
    }, n(f, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }]), f);

  function f(t) {
    this._element = t, this.shouldAvoidTriggerChange = !1
  }
  d.default(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (t) {
    var e, i = t.target,
      s = i;
    !(i = !d.default(i).hasClass("btn") ? d.default(i).closest(".btn")[0] : i) || i.hasAttribute("disabled") || i.classList.contains("disabled") || (e = i.querySelector('input:not([type="hidden"])')) && (e.hasAttribute("disabled") || e.classList.contains("disabled")) ? t.preventDefault() : "INPUT" !== s.tagName && "LABEL" === i.tagName || p._jQueryInterface.call(d.default(i), "toggle", "INPUT" === s.tagName)
  }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (t) {
    var e = d.default(t.target).closest(".btn")[0];
    d.default(e).toggleClass("focus", /^focus(in)?$/.test(t.type))
  }), d.default(window).on("load.bs.button.data-api", function () {
    for (var t = [].slice.call(document.querySelectorAll('[data-toggle="buttons"] .btn')), e = 0, i = t.length; e < i; e++) {
      var s = t[e],
        n = s.querySelector('input:not([type="hidden"])');
      n.checked || n.hasAttribute("checked") ? s.classList.add("active") : s.classList.remove("active")
    }
    for (var a = 0, o = (t = [].slice.call(document.querySelectorAll('[data-toggle="button"]'))).length; a < o; a++) {
      var r = t[a];
      "true" === r.getAttribute("aria-pressed") ? r.classList.add("active") : r.classList.remove("active")
    }
  }), d.default.fn.button = p._jQueryInterface, d.default.fn.button.Constructor = p, d.default.fn.button.noConflict = function () {
    return d.default.fn.button = u, p._jQueryInterface
  };
  var m = "carousel",
    g = d.default.fn[m],
    v = {
      interval: 5e3,
      keyboard: !0,
      slide: !1,
      pause: "hover",
      wrap: !0,
      touch: !0
    },
    b = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      slide: "(boolean|string)",
      pause: "(string|boolean)",
      wrap: "boolean",
      touch: "boolean"
    },
    _ = {
      TOUCH: "touch",
      PEN: "pen"
    },
    y = ((vt = w.prototype).next = function () {
      this._isSliding || this._slide("next")
    }, vt.nextWhenVisible = function () {
      var t = d.default(this._element);
      !document.hidden && t.is(":visible") && "hidden" !== t.css("visibility") && this.next()
    }, vt.prev = function () {
      this._isSliding || this._slide("prev")
    }, vt.pause = function (t) {
      t || (this._isPaused = !0), this._element.querySelector(".carousel-item-next, .carousel-item-prev") && (h.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
    }, vt.cycle = function (t) {
      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
    }, vt.to = function (t) {
      var e = this;
      this._activeElement = this._element.querySelector(".active.carousel-item");
      var i = this._getItemIndex(this._activeElement);
      if (!(t > this._items.length - 1 || t < 0))
        if (this._isSliding) d.default(this._element).one("slid.bs.carousel", function () {
          return e.to(t)
        });
        else {
          if (i === t) return this.pause(), void this.cycle();
          this._slide(i < t ? "next" : "prev", this._items[t])
        }
    }, vt.dispose = function () {
      d.default(this._element).off(".bs.carousel"), d.default.removeData(this._element, "bs.carousel"), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null
    }, vt._getConfig = function (t) {
      return t = a({}, v, t), h.typeCheckConfig(m, t, b), t
    }, vt._handleSwipe = function () {
      var t = Math.abs(this.touchDeltaX);
      t <= 40 || (t = t / this.touchDeltaX, (this.touchDeltaX = 0) < t && this.prev(), t < 0 && this.next())
    }, vt._addEventListeners = function () {
      var e = this;
      this._config.keyboard && d.default(this._element).on("keydown.bs.carousel", function (t) {
        return e._keydown(t)
      }), "hover" === this._config.pause && d.default(this._element).on("mouseenter.bs.carousel", function (t) {
        return e.pause(t)
      }).on("mouseleave.bs.carousel", function (t) {
        return e.cycle(t)
      }), this._config.touch && this._addTouchEventListeners()
    }, vt._addTouchEventListeners = function () {
      var t, e, i = this;
      this._touchSupported && (t = function (t) {
        i._pointerEvent && _[t.originalEvent.pointerType.toUpperCase()] ? i.touchStartX = t.originalEvent.clientX : i._pointerEvent || (i.touchStartX = t.originalEvent.touches[0].clientX)
      }, e = function (t) {
        i._pointerEvent && _[t.originalEvent.pointerType.toUpperCase()] && (i.touchDeltaX = t.originalEvent.clientX - i.touchStartX), i._handleSwipe(), "hover" === i._config.pause && (i.pause(), i.touchTimeout && clearTimeout(i.touchTimeout), i.touchTimeout = setTimeout(function (t) {
          return i.cycle(t)
        }, 500 + i._config.interval))
      }, d.default(this._element.querySelectorAll(".carousel-item img")).on("dragstart.bs.carousel", function (t) {
        return t.preventDefault()
      }), this._pointerEvent ? (d.default(this._element).on("pointerdown.bs.carousel", t), d.default(this._element).on("pointerup.bs.carousel", e), this._element.classList.add("pointer-event")) : (d.default(this._element).on("touchstart.bs.carousel", t), d.default(this._element).on("touchmove.bs.carousel", function (t) {
        (t = t).originalEvent.touches && 1 < t.originalEvent.touches.length ? i.touchDeltaX = 0 : i.touchDeltaX = t.originalEvent.touches[0].clientX - i.touchStartX
      }), d.default(this._element).on("touchend.bs.carousel", e)))
    }, vt._keydown = function (t) {
      if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) {
        case 37:
          t.preventDefault(), this.prev();
          break;
        case 39:
          t.preventDefault(), this.next()
      }
    }, vt._getItemIndex = function (t) {
      return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(".carousel-item")) : [], this._items.indexOf(t)
    }, vt._getItemByDirection = function (t, e) {
      var i = "next" === t,
        s = "prev" === t,
        n = this._getItemIndex(e),
        a = this._items.length - 1;
      if ((s && 0 === n || i && n === a) && !this._config.wrap) return e;
      t = (n + ("prev" === t ? -1 : 1)) % this._items.length;
      return -1 == t ? this._items[this._items.length - 1] : this._items[t]
    }, vt._triggerSlideEvent = function (t, e) {
      var i = this._getItemIndex(t),
        s = this._getItemIndex(this._element.querySelector(".active.carousel-item")),
        i = d.default.Event("slide.bs.carousel", {
          relatedTarget: t,
          direction: e,
          from: s,
          to: i
        });
      return d.default(this._element).trigger(i), i
    }, vt._setActiveIndicatorElement = function (t) {
      var e;
      this._indicatorsElement && (e = [].slice.call(this._indicatorsElement.querySelectorAll(".active")), d.default(e).removeClass("active"), (t = this._indicatorsElement.children[this._getItemIndex(t)]) && d.default(t).addClass("active"))
    }, vt._slide = function (t, e) {
      var i, s, n, a = this,
        o = this._element.querySelector(".active.carousel-item"),
        r = this._getItemIndex(o),
        l = e || o && this._getItemByDirection(t, o),
        c = this._getItemIndex(l),
        e = Boolean(this._interval),
        t = "next" === t ? (i = "carousel-item-left", s = "carousel-item-next", "left") : (i = "carousel-item-right", s = "carousel-item-prev", "right");
      l && d.default(l).hasClass("active") ? this._isSliding = !1 : !this._triggerSlideEvent(l, t).isDefaultPrevented() && o && l && (this._isSliding = !0, e && this.pause(), this._setActiveIndicatorElement(l), n = d.default.Event("slid.bs.carousel", {
        relatedTarget: l,
        direction: t,
        from: r,
        to: c
      }), d.default(this._element).hasClass("slide") ? (d.default(l).addClass(s), h.reflow(l), d.default(o).addClass(i), d.default(l).addClass(i), (c = parseInt(l.getAttribute("data-interval"), 10)) ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = c) : this._config.interval = this._config.defaultInterval || this._config.interval, c = h.getTransitionDurationFromElement(o), d.default(o).one(h.TRANSITION_END, function () {
        d.default(l).removeClass(i + " " + s).addClass("active"), d.default(o).removeClass("active " + s + " " + i), a._isSliding = !1, setTimeout(function () {
          return d.default(a._element).trigger(n)
        }, 0)
      }).emulateTransitionEnd(c)) : (d.default(o).removeClass("active"), d.default(l).addClass("active"), this._isSliding = !1, d.default(this._element).trigger(n)), e && this.cycle())
    }, w._jQueryInterface = function (s) {
      return this.each(function () {
        var t = d.default(this).data("bs.carousel"),
          e = a({}, v, d.default(this).data());
        "object" == typeof s && (e = a({}, e, s));
        var i = "string" == typeof s ? s : e.slide;
        if (t || (t = new w(this, e), d.default(this).data("bs.carousel", t)), "number" == typeof s) t.to(s);
        else if ("string" == typeof i) {
          if (void 0 === t[i]) throw new TypeError('No method named "' + i + '"');
          t[i]()
        } else e.interval && e.ride && (t.pause(), t.cycle())
      })
    }, w._dataApiClickHandler = function (t) {
      var e, i, s = h.getSelectorFromElement(this);
      !s || (e = d.default(s)[0]) && d.default(e).hasClass("carousel") && (i = a({}, d.default(e).data(), d.default(this).data()), (s = this.getAttribute("data-slide-to")) && (i.interval = !1), w._jQueryInterface.call(d.default(e), i), s && d.default(e).data("bs.carousel").to(s), t.preventDefault())
    }, n(w, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }, {
      key: "Default",
      get: function () {
        return v
      }
    }]), w);

  function w(t, e) {
    this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector(".carousel-indicators"), this._touchSupported = "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners()
  }
  d.default(document).on("click.bs.carousel.data-api", "[data-slide], [data-slide-to]", y._dataApiClickHandler), d.default(window).on("load.bs.carousel.data-api", function () {
    for (var t = [].slice.call(document.querySelectorAll('[data-ride="carousel"]')), e = 0, i = t.length; e < i; e++) {
      var s = d.default(t[e]);
      y._jQueryInterface.call(s, s.data())
    }
  }), d.default.fn[m] = y._jQueryInterface, d.default.fn[m].Constructor = y, d.default.fn[m].noConflict = function () {
    return d.default.fn[m] = g, y._jQueryInterface
  };
  var x = "collapse",
    C = d.default.fn[x],
    k = {
      toggle: !0,
      parent: ""
    },
    T = {
      toggle: "boolean",
      parent: "(string|element)"
    },
    D = ((yt = S.prototype).toggle = function () {
      d.default(this._element).hasClass("show") ? this.hide() : this.show()
    }, yt.show = function () {
      var t, e, i, s, n = this;
      this._isTransitioning || d.default(this._element).hasClass("show") || (s = this._parent && 0 === (s = [].slice.call(this._parent.querySelectorAll(".show, .collapsing")).filter(function (t) {
        return "string" == typeof n._config.parent ? t.getAttribute("data-parent") === n._config.parent : t.classList.contains("collapse")
      })).length ? null : s) && (i = d.default(s).not(this._selector).data("bs.collapse")) && i._isTransitioning || (t = d.default.Event("show.bs.collapse"), d.default(this._element).trigger(t), t.isDefaultPrevented() || (s && (S._jQueryInterface.call(d.default(s).not(this._selector), "hide"), i || d.default(s).data("bs.collapse", null)), e = this._getDimension(), d.default(this._element).removeClass("collapse").addClass("collapsing"), this._element.style[e] = 0, this._triggerArray.length && d.default(this._triggerArray).removeClass("collapsed").attr("aria-expanded", !0), this.setTransitioning(!0), i = "scroll" + (e[0].toUpperCase() + e.slice(1)), s = h.getTransitionDurationFromElement(this._element), d.default(this._element).one(h.TRANSITION_END, function () {
        d.default(n._element).removeClass("collapsing").addClass("collapse show"), n._element.style[e] = "", n.setTransitioning(!1), d.default(n._element).trigger("shown.bs.collapse")
      }).emulateTransitionEnd(s), this._element.style[e] = this._element[i] + "px"))
    }, yt.hide = function () {
      var t = this;
      if (!this._isTransitioning && d.default(this._element).hasClass("show")) {
        var e = d.default.Event("hide.bs.collapse");
        if (d.default(this._element).trigger(e), !e.isDefaultPrevented()) {
          e = this._getDimension();
          this._element.style[e] = this._element.getBoundingClientRect()[e] + "px", h.reflow(this._element), d.default(this._element).addClass("collapsing").removeClass("collapse show");
          var i = this._triggerArray.length;
          if (0 < i)
            for (var s = 0; s < i; s++) {
              var n = this._triggerArray[s],
                a = h.getSelectorFromElement(n);
              null !== a && (d.default([].slice.call(document.querySelectorAll(a))).hasClass("show") || d.default(n).addClass("collapsed").attr("aria-expanded", !1))
            }
          this.setTransitioning(!0), this._element.style[e] = "";
          e = h.getTransitionDurationFromElement(this._element);
          d.default(this._element).one(h.TRANSITION_END, function () {
            t.setTransitioning(!1), d.default(t._element).removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
          }).emulateTransitionEnd(e)
        }
      }
    }, yt.setTransitioning = function (t) {
      this._isTransitioning = t
    }, yt.dispose = function () {
      d.default.removeData(this._element, "bs.collapse"), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null
    }, yt._getConfig = function (t) {
      return (t = a({}, k, t)).toggle = Boolean(t.toggle), h.typeCheckConfig(x, t, T), t
    }, yt._getDimension = function () {
      return d.default(this._element).hasClass("width") ? "width" : "height"
    }, yt._getParent = function () {
      var t, i = this;
      h.isElement(this._config.parent) ? (t = this._config.parent, void 0 !== this._config.parent.jquery && (t = this._config.parent[0])) : t = document.querySelector(this._config.parent);
      var e = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]',
        e = [].slice.call(t.querySelectorAll(e));
      return d.default(e).each(function (t, e) {
        i._addAriaAndCollapsedClass(S._getTargetFromElement(e), [e])
      }), t
    }, yt._addAriaAndCollapsedClass = function (t, e) {
      t = d.default(t).hasClass("show");
      e.length && d.default(e).toggleClass("collapsed", !t).attr("aria-expanded", t)
    }, S._getTargetFromElement = function (t) {
      t = h.getSelectorFromElement(t);
      return t ? document.querySelector(t) : null
    }, S._jQueryInterface = function (s) {
      return this.each(function () {
        var t = d.default(this),
          e = t.data("bs.collapse"),
          i = a({}, k, t.data(), "object" == typeof s && s ? s : {});
        if (!e && i.toggle && "string" == typeof s && /show|hide/.test(s) && (i.toggle = !1), e || (e = new S(this, i), t.data("bs.collapse", e)), "string" == typeof s) {
          if (void 0 === e[s]) throw new TypeError('No method named "' + s + '"');
          e[s]()
        }
      })
    }, n(S, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }, {
      key: "Default",
      get: function () {
        return k
      }
    }]), S);

  function S(e, t) {
    this._isTransitioning = !1, this._element = e, this._config = this._getConfig(t), this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + e.id + '"],[data-toggle="collapse"][data-target="#' + e.id + '"]'));
    for (var i = [].slice.call(document.querySelectorAll('[data-toggle="collapse"]')), s = 0, n = i.length; s < n; s++) {
      var a = i[s],
        o = h.getSelectorFromElement(a),
        r = [].slice.call(document.querySelectorAll(o)).filter(function (t) {
          return t === e
        });
      null !== o && 0 < r.length && (this._selector = o, this._triggerArray.push(a))
    }
    this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle()
  }
  d.default(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (t) {
    "A" === t.currentTarget.tagName && t.preventDefault();
    var i = d.default(this),
      t = h.getSelectorFromElement(this),
      t = [].slice.call(document.querySelectorAll(t));
    d.default(t).each(function () {
      var t = d.default(this),
        e = t.data("bs.collapse") ? "toggle" : i.data();
      D._jQueryInterface.call(t, e)
    })
  }), d.default.fn[x] = D._jQueryInterface, d.default.fn[x].Constructor = D, d.default.fn[x].noConflict = function () {
    return d.default.fn[x] = C, D._jQueryInterface
  };
  var M = "undefined" != typeof window && "undefined" != typeof document && "undefined" != typeof navigator,
    E = function () {
      for (var t = ["Edge", "Trident", "Firefox"], e = 0; e < t.length; e += 1)
        if (M && 0 <= navigator.userAgent.indexOf(t[e])) return 1;
      return 0
    }(),
    A = M && window.Promise ? function (t) {
      var e = !1;
      return function () {
        e || (e = !0, window.Promise.resolve().then(function () {
          e = !1, t()
        }))
      }
    } : function (t) {
      var e = !1;
      return function () {
        e || (e = !0, setTimeout(function () {
          e = !1, t()
        }, E))
      }
    };

  function P(t) {
    return t && "[object Function]" === {}.toString.call(t)
  }

  function I(t, e) {
    if (1 !== t.nodeType) return [];
    t = t.ownerDocument.defaultView.getComputedStyle(t, null);
    return e ? t[e] : t
  }

  function O(t) {
    return "HTML" === t.nodeName ? t : t.parentNode || t.host
  }

  function $(t) {
    if (!t) return document.body;
    switch (t.nodeName) {
      case "HTML":
      case "BODY":
        return t.ownerDocument.body;
      case "#document":
        return t.body
    }
    var e = I(t),
      i = e.overflow,
      s = e.overflowX,
      e = e.overflowY;
    return /(auto|scroll|overlay)/.test(i + e + s) ? t : $(O(t))
  }

  function L(t) {
    return t && t.referenceNode ? t.referenceNode : t
  }
  var N = M && !(!window.MSInputMethodContext || !document.documentMode),
    H = M && /MSIE 10/.test(navigator.userAgent);

  function F(t) {
    return 11 === t ? N : 10 !== t && N || H
  }

  function z(t) {
    if (!t) return document.documentElement;
    for (var e = F(10) ? document.body : null, i = t.offsetParent || null; i === e && t.nextElementSibling;) i = (t = t.nextElementSibling).offsetParent;
    var s = i && i.nodeName;
    return s && "BODY" !== s && "HTML" !== s ? -1 !== ["TH", "TD", "TABLE"].indexOf(i.nodeName) && "static" === I(i, "position") ? z(i) : i : (t ? t.ownerDocument : document).documentElement
  }

  function R(t) {
    return null !== t.parentNode ? R(t.parentNode) : t
  }

  function B(t, e) {
    if (!(t && t.nodeType && e && e.nodeType)) return document.documentElement;
    var i = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING,
      s = i ? t : e,
      n = i ? e : t,
      i = document.createRange();
    i.setStart(s, 0), i.setEnd(n, 0);
    i = i.commonAncestorContainer;
    if (t !== i && e !== i || s.contains(n)) return "BODY" === (n = (s = i).nodeName) || "HTML" !== n && z(s.firstElementChild) !== s ? z(i) : i;
    i = R(t);
    return i.host ? B(i.host, e) : B(t, R(e).host)
  }

  function j(t, e) {
    var i = "top" === (1 < arguments.length && void 0 !== e ? e : "top") ? "scrollTop" : "scrollLeft",
      e = t.nodeName;
    if ("BODY" !== e && "HTML" !== e) return t[i];
    e = t.ownerDocument.documentElement;
    return (t.ownerDocument.scrollingElement || e)[i]
  }

  function W(t, e) {
    var i = "x" === e ? "Left" : "Top",
      e = "Left" == i ? "Right" : "Bottom";
    return parseFloat(t["border" + i + "Width"]) + parseFloat(t["border" + e + "Width"])
  }

  function V(t, e, i, s) {
    return Math.max(e["offset" + t], e["scroll" + t], i["client" + t], i["offset" + t], i["scroll" + t], F(10) ? parseInt(i["offset" + t]) + parseInt(s["margin" + ("Height" === t ? "Top" : "Left")]) + parseInt(s["margin" + ("Height" === t ? "Bottom" : "Right")]) : 0)
  }

  function q(t) {
    var e = t.body,
      i = t.documentElement,
      t = F(10) && getComputedStyle(i);
    return {
      height: V("Height", e, i, t),
      width: V("Width", e, i, t)
    }
  }

  function Y(t, e, i) {
    return e in t ? Object.defineProperty(t, e, {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : t[e] = i, t
  }
  var U = function (t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    },
    X = function (t, e, i) {
      return e && K(t.prototype, e), i && K(t, i), t
    },
    G = Object.assign || function (t) {
      for (var e = 1; e < arguments.length; e++) {
        var i, s = arguments[e];
        for (i in s) Object.prototype.hasOwnProperty.call(s, i) && (t[i] = s[i])
      }
      return t
    };

  function K(t, e) {
    for (var i = 0; i < e.length; i++) {
      var s = e[i];
      s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(t, s.key, s)
    }
  }

  function Q(t) {
    return G({}, t, {
      right: t.left + t.width,
      bottom: t.top + t.height
    })
  }

  function J(t) {
    var e = {};
    try {
      F(10) ? (e = t.getBoundingClientRect(), s = j(t, "top"), n = j(t, "left"), e.top += s, e.left += n, e.bottom += s, e.right += n) : e = t.getBoundingClientRect()
    } catch (t) {}
    var i = {
        left: e.left,
        top: e.top,
        width: e.right - e.left,
        height: e.bottom - e.top
      },
      s = "HTML" === t.nodeName ? q(t.ownerDocument) : {},
      n = s.width || t.clientWidth || i.width,
      e = s.height || t.clientHeight || i.height,
      s = t.offsetWidth - n,
      n = t.offsetHeight - e;
    return (s || n) && (s -= W(e = I(t), "x"), n -= W(e, "y"), i.width -= s, i.height -= n), Q(i)
  }

  function Z(t, e, i) {
    var s = 2 < arguments.length && void 0 !== i && i,
      n = F(10),
      a = "HTML" === e.nodeName,
      o = J(t),
      r = J(e),
      l = $(t),
      c = I(e),
      i = parseFloat(c.borderTopWidth),
      t = parseFloat(c.borderLeftWidth);
    s && a && (r.top = Math.max(r.top, 0), r.left = Math.max(r.left, 0));
    o = Q({
      top: o.top - r.top - i,
      left: o.left - r.left - t,
      width: o.width,
      height: o.height
    });
    return o.marginTop = 0, o.marginLeft = 0, !n && a && (a = parseFloat(c.marginTop), c = parseFloat(c.marginLeft), o.top -= i - a, o.bottom -= i - a, o.left -= t - c, o.right -= t - c, o.marginTop = a, o.marginLeft = c), o = (n && !s ? e.contains(l) : e === l && "BODY" !== l.nodeName) ? function (t, e, i) {
      var s = 2 < arguments.length && void 0 !== i && i,
        i = j(e, "top"),
        e = j(e, "left"),
        s = s ? -1 : 1;
      return t.top += i * s, t.bottom += i * s, t.left += e * s, t.right += e * s, t
    }(o, e) : o
  }

  function tt(t) {
    if (!t || !t.parentElement || F()) return document.documentElement;
    for (var e = t.parentElement; e && "none" === I(e, "transform");) e = e.parentElement;
    return e || document.documentElement
  }

  function et(t, e, i, s, n) {
    var a = 4 < arguments.length && void 0 !== n && n,
      o = {
        top: 0,
        left: 0
      },
      r = a ? tt(t) : B(t, L(e));
    "viewport" === s ? o = function (t, e) {
      var i = 1 < arguments.length && void 0 !== e && e,
        s = t.ownerDocument.documentElement,
        n = Z(t, s),
        a = Math.max(s.clientWidth, window.innerWidth || 0),
        e = Math.max(s.clientHeight, window.innerHeight || 0),
        t = i ? 0 : j(s),
        s = i ? 0 : j(s, "left");
      return Q({
        top: t - n.top + n.marginTop,
        left: s - n.left + n.marginLeft,
        width: a,
        height: e
      })
    }(r, a) : (n = void 0, "scrollParent" === s ? "BODY" === (n = $(O(e))).nodeName && (n = t.ownerDocument.documentElement) : n = "window" === s ? t.ownerDocument.documentElement : s, l = Z(n, r, a), "HTML" !== n.nodeName || function t(e) {
      var i = e.nodeName;
      if ("BODY" === i || "HTML" === i) return !1;
      if ("fixed" === I(e, "position")) return !0;
      e = O(e);
      return !!e && t(e)
    }(r) ? o = l : (t = (r = q(t.ownerDocument)).height, r = r.width, o.top += l.top - l.marginTop, o.bottom = t + l.top, o.left += l.left - l.marginLeft, o.right = r + l.left));
    var l = "number" == typeof (i = i || 0);
    return o.left += l ? i : i.left || 0, o.top += l ? i : i.top || 0, o.right -= l ? i : i.right || 0, o.bottom -= l ? i : i.bottom || 0, o
  }

  function it(t, e, i, s, n, a) {
    a = 5 < arguments.length && void 0 !== a ? a : 0;
    if (-1 === t.indexOf("auto")) return t;
    var n = et(i, s, a, n),
      o = {
        top: {
          width: n.width,
          height: e.top - n.top
        },
        right: {
          width: n.right - e.right,
          height: n.height
        },
        bottom: {
          width: n.width,
          height: n.bottom - e.bottom
        },
        left: {
          width: e.left - n.left,
          height: n.height
        }
      },
      e = Object.keys(o).map(function (t) {
        return G({
          key: t
        }, o[t], {
          area: (t = o[t]).width * t.height
        })
      }).sort(function (t, e) {
        return e.area - t.area
      }),
      n = e.filter(function (t) {
        var e = t.width,
          t = t.height;
        return e >= i.clientWidth && t >= i.clientHeight
      }),
      e = (0 < n.length ? n : e)[0].key,
      t = t.split("-")[1];
    return e + (t ? "-" + t : "")
  }

  function st(t, e, i, s) {
    s = 3 < arguments.length && void 0 !== s ? s : null;
    return Z(i, s ? tt(e) : B(e, L(i)), s)
  }

  function nt(t) {
    var e = t.ownerDocument.defaultView.getComputedStyle(t),
      i = parseFloat(e.marginTop || 0) + parseFloat(e.marginBottom || 0),
      e = parseFloat(e.marginLeft || 0) + parseFloat(e.marginRight || 0);
    return {
      width: t.offsetWidth + e,
      height: t.offsetHeight + i
    }
  }

  function at(t) {
    var e = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    return t.replace(/left|right|bottom|top/g, function (t) {
      return e[t]
    })
  }

  function ot(t, e, i) {
    i = i.split("-")[0];
    var s = nt(t),
      n = {
        width: s.width,
        height: s.height
      },
      a = -1 !== ["right", "left"].indexOf(i),
      o = a ? "top" : "left",
      r = a ? "left" : "top",
      t = a ? "height" : "width",
      a = a ? "width" : "height";
    return n[o] = e[o] + e[t] / 2 - s[t] / 2, n[r] = i === r ? e[r] - s[a] : e[at(r)], n
  }

  function rt(t, e) {
    return Array.prototype.find ? t.find(e) : t.filter(e)[0]
  }

  function lt(t, i, e) {
    return (void 0 === e ? t : t.slice(0, function (t, e) {
      if (Array.prototype.findIndex) return t.findIndex(function (t) {
        return t.name === e
      });
      var i = rt(t, function (t) {
        return t.name === e
      });
      return t.indexOf(i)
    }(t, e))).forEach(function (t) {
      t.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
      var e = t.function || t.fn;
      t.enabled && P(e) && (i.offsets.popper = Q(i.offsets.popper), i.offsets.reference = Q(i.offsets.reference), i = e(i, t))
    }), i
  }

  function ct(t, i) {
    return t.some(function (t) {
      var e = t.name;
      return t.enabled && e === i
    })
  }

  function dt(t) {
    for (var e = [!1, "ms", "Webkit", "Moz", "O"], i = t.charAt(0).toUpperCase() + t.slice(1), s = 0; s < e.length; s++) {
      var n = e[s],
        n = n ? "" + n + i : t;
      if (void 0 !== document.body.style[n]) return n
    }
    return null
  }

  function ht(t) {
    t = t.ownerDocument;
    return t ? t.defaultView : window
  }

  function ut() {
    var t, e, i;
    this.state.eventsEnabled || (this.state = (t = this.reference, this.options, e = this.state, i = this.scheduleUpdate, e.updateBound = i, ht(t).addEventListener("resize", e.updateBound, {
      passive: !0
    }), function t(e, i, s, n) {
      var a = "BODY" === e.nodeName,
        e = a ? e.ownerDocument.defaultView : e;
      e.addEventListener(i, s, {
        passive: !0
      }), a || t($(e.parentNode), i, s, n), n.push(e)
    }(t = $(t), "scroll", e.updateBound, e.scrollParents), e.scrollElement = t, e.eventsEnabled = !0, e))
  }

  function pt(t) {
    return "" !== t && !isNaN(parseFloat(t)) && isFinite(t)
  }

  function ft(i, s) {
    Object.keys(s).forEach(function (t) {
      var e = ""; - 1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(t) && pt(s[t]) && (e = "px"), i.style[t] = s[t] + e
    })
  }
  var mt = M && /Firefox/i.test(navigator.userAgent);

  function gt(t, e, i) {
    var s = rt(t, function (t) {
        return t.name === e
      }),
      n = !!s && t.some(function (t) {
        return t.name === i && t.enabled && t.order < s.order
      });
    return n || (t = "`" + e + "`", console.warn("`" + i + "`" + " modifier is required by " + t + " modifier in order to work, be sure to include it before " + t + "!")), n
  }
  var vt = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"],
    bt = vt.slice(3);

  function _t(t, e) {
    e = 1 < arguments.length && void 0 !== e && e, t = bt.indexOf(t), t = bt.slice(t + 1).concat(bt.slice(0, t));
    return e ? t.reverse() : t
  }
  var yt = {
      placement: "bottom",
      positionFixed: !1,
      eventsEnabled: !0,
      removeOnDestroy: !1,
      onCreate: function () {},
      onUpdate: function () {},
      modifiers: {
        shift: {
          order: 100,
          enabled: !0,
          fn: function (t) {
            var e, i, s = t.placement,
              n = s.split("-")[0],
              a = s.split("-")[1];
            return a && (e = (i = t.offsets).reference, s = i.popper, n = (i = -1 !== ["bottom", "top"].indexOf(n)) ? "width" : "height", n = {
              start: Y({}, i = i ? "left" : "top", e[i]),
              end: Y({}, i, e[i] + e[n] - s[n])
            }, t.offsets.popper = G({}, s, n[a])), t
          }
        },
        offset: {
          order: 200,
          enabled: !0,
          fn: function (t, e) {
            var n, a, o, r, i = e.offset,
              s = t.placement,
              l = t.offsets,
              c = l.popper,
              d = l.reference,
              e = s.split("-")[0],
              l = pt(+i) ? [+i, 0] : (s = i, n = c, a = d, o = [0, 0], r = -1 !== ["right", "left"].indexOf(i = e), d = s.split(/(\+|\-)/).map(function (t) {
                return t.trim()
              }), i = d.indexOf(rt(d, function (t) {
                return -1 !== t.search(/,|\s/)
              })), d[i] && -1 === d[i].indexOf(",") && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead."), s = /\s*,\s*|\s+/, (-1 !== i ? [d.slice(0, i).concat([d[i].split(s)[0]]), [d[i].split(s)[1]].concat(d.slice(i + 1))] : [d]).map(function (t, e) {
                var i = (1 === e ? !r : r) ? "height" : "width",
                  s = !1;
                return t.reduce(function (t, e) {
                  return "" === t[t.length - 1] && -1 !== ["+", "-"].indexOf(e) ? (t[t.length - 1] = e, s = !0, t) : s ? (t[t.length - 1] += e, s = !1, t) : t.concat(e)
                }, []).map(function (t) {
                  return function (t, e, i, s) {
                    var n = t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),
                      a = +n[1],
                      n = n[2];
                    if (!a) return t;
                    if (0 !== n.indexOf("%")) return "vh" === n || "vw" === n ? ("vh" === n ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * a : a;
                    var o = void 0;
                    switch (n) {
                      case "%p":
                        o = i;
                        break;
                      case "%":
                      case "%r":
                      default:
                        o = s
                    }
                    return Q(o)[e] / 100 * a
                  }(t, i, n, a)
                })
              }).forEach(function (i, s) {
                i.forEach(function (t, e) {
                  pt(t) && (o[s] += t * ("-" === i[e - 1] ? -1 : 1))
                })
              }), o);
            return "left" === e ? (c.top += l[0], c.left -= l[1]) : "right" === e ? (c.top += l[0], c.left += l[1]) : "top" === e ? (c.left += l[0], c.top -= l[1]) : "bottom" === e && (c.left += l[0], c.top += l[1]), t.popper = c, t
          },
          offset: 0
        },
        preventOverflow: {
          order: 300,
          enabled: !0,
          fn: function (t, s) {
            var e = s.boundariesElement || z(t.instance.popper);
            t.instance.reference === e && (e = z(e));
            var i = dt("transform"),
              n = t.instance.popper.style,
              a = n.top,
              o = n.left,
              r = n[i];
            n.top = "", n.left = "", n[i] = "";
            var l = et(t.instance.popper, t.instance.reference, s.padding, e, t.positionFixed);
            n.top = a, n.left = o, n[i] = r, s.boundaries = l;
            var r = s.priority,
              c = t.offsets.popper,
              d = {
                primary: function (t) {
                  var e = c[t];
                  return c[t] < l[t] && !s.escapeWithReference && (e = Math.max(c[t], l[t])), Y({}, t, e)
                },
                secondary: function (t) {
                  var e = "right" === t ? "left" : "top",
                    i = c[e];
                  return c[t] > l[t] && !s.escapeWithReference && (i = Math.min(c[e], l[t] - ("right" === t ? c.width : c.height))), Y({}, e, i)
                }
              };
            return r.forEach(function (t) {
              var e = -1 !== ["left", "top"].indexOf(t) ? "primary" : "secondary";
              c = G({}, c, d[e](t))
            }), t.offsets.popper = c, t
          },
          priority: ["left", "right", "top", "bottom"],
          padding: 5,
          boundariesElement: "scrollParent"
        },
        keepTogether: {
          order: 400,
          enabled: !0,
          fn: function (t) {
            var e = t.offsets,
              i = e.popper,
              s = e.reference,
              n = t.placement.split("-")[0],
              a = Math.floor,
              o = -1 !== ["top", "bottom"].indexOf(n),
              e = o ? "right" : "bottom",
              n = o ? "left" : "top",
              o = o ? "width" : "height";
            return i[e] < a(s[n]) && (t.offsets.popper[n] = a(s[n]) - i[o]), i[n] > a(s[e]) && (t.offsets.popper[n] = a(s[e])), t
          }
        },
        arrow: {
          order: 500,
          enabled: !0,
          fn: function (t, e) {
            if (!gt(t.instance.modifiers, "arrow", "keepTogether")) return t;
            var i = e.element;
            if ("string" == typeof i) {
              if (!(i = t.instance.popper.querySelector(i))) return t
            } else if (!t.instance.popper.contains(i)) return console.warn("WARNING: `arrow.element` must be child of its popper element!"), t;
            var s = t.placement.split("-")[0],
              n = t.offsets,
              a = n.popper,
              o = n.reference,
              r = -1 !== ["left", "right"].indexOf(s),
              l = r ? "height" : "width",
              c = r ? "Top" : "Left",
              d = c.toLowerCase(),
              e = r ? "left" : "top",
              n = r ? "bottom" : "right",
              s = nt(i)[l];
            o[n] - s < a[d] && (t.offsets.popper[d] -= a[d] - (o[n] - s)), o[d] + s > a[n] && (t.offsets.popper[d] += o[d] + s - a[n]), t.offsets.popper = Q(t.offsets.popper);
            r = o[d] + o[l] / 2 - s / 2, n = I(t.instance.popper), o = parseFloat(n["margin" + c]), c = parseFloat(n["border" + c + "Width"]), c = r - t.offsets.popper[d] - o - c, c = Math.max(Math.min(a[l] - s, c), 0);
            return t.arrowElement = i, t.offsets.arrow = (Y(i = {}, d, Math.round(c)), Y(i, e, ""), i), t
          },
          element: "[x-arrow]"
        },
        flip: {
          order: 600,
          enabled: !0,
          fn: function (c, d) {
            if (ct(c.instance.modifiers, "inner")) return c;
            if (c.flipped && c.placement === c.originalPlacement) return c;
            var h = et(c.instance.popper, c.instance.reference, d.padding, d.boundariesElement, c.positionFixed),
              u = c.placement.split("-")[0],
              p = at(u),
              f = c.placement.split("-")[1] || "",
              m = [];
            switch (d.behavior) {
              case "flip":
                m = [u, p];
                break;
              case "clockwise":
                m = _t(u);
                break;
              case "counterclockwise":
                m = _t(u, !0);
                break;
              default:
                m = d.behavior
            }
            return m.forEach(function (t, e) {
              if (u !== t || m.length === e + 1) return c;
              u = c.placement.split("-")[0], p = at(u);
              var i = c.offsets.popper,
                s = c.offsets.reference,
                n = Math.floor,
                a = "left" === u && n(i.right) > n(s.left) || "right" === u && n(i.left) < n(s.right) || "top" === u && n(i.bottom) > n(s.top) || "bottom" === u && n(i.top) < n(s.bottom),
                o = n(i.left) < n(h.left),
                r = n(i.right) > n(h.right),
                l = n(i.top) < n(h.top),
                t = n(i.bottom) > n(h.bottom),
                s = "left" === u && o || "right" === u && r || "top" === u && l || "bottom" === u && t,
                i = -1 !== ["top", "bottom"].indexOf(u),
                n = !!d.flipVariations && (i && "start" === f && o || i && "end" === f && r || !i && "start" === f && l || !i && "end" === f && t),
                l = !!d.flipVariationsByContent && (i && "start" === f && r || i && "end" === f && o || !i && "start" === f && t || !i && "end" === f && l),
                l = n || l;
              (a || s || l) && (c.flipped = !0, (a || s) && (u = m[e + 1]), l && (f = "end" === f ? "start" : "start" === f ? "end" : f), c.placement = u + (f ? "-" + f : ""), c.offsets.popper = G({}, c.offsets.popper, ot(c.instance.popper, c.offsets.reference, c.placement)), c = lt(c.instance.modifiers, c, "flip"))
            }), c
          },
          behavior: "flip",
          padding: 5,
          boundariesElement: "viewport",
          flipVariations: !1,
          flipVariationsByContent: !1
        },
        inner: {
          order: 700,
          enabled: !1,
          fn: function (t) {
            var e = t.placement,
              i = e.split("-")[0],
              s = t.offsets,
              n = s.popper,
              a = s.reference,
              o = -1 !== ["left", "right"].indexOf(i),
              s = -1 === ["top", "left"].indexOf(i);
            return n[o ? "left" : "top"] = a[i] - (s ? n[o ? "width" : "height"] : 0), t.placement = at(e), t.offsets.popper = Q(n), t
          }
        },
        hide: {
          order: 800,
          enabled: !0,
          fn: function (t) {
            if (!gt(t.instance.modifiers, "hide", "preventOverflow")) return t;
            var e = t.offsets.reference,
              i = rt(t.instance.modifiers, function (t) {
                return "preventOverflow" === t.name
              }).boundaries;
            if (e.bottom < i.top || e.left > i.right || e.top > i.bottom || e.right < i.left) {
              if (!0 === t.hide) return t;
              t.hide = !0, t.attributes["x-out-of-boundaries"] = ""
            } else {
              if (!1 === t.hide) return t;
              t.hide = !1, t.attributes["x-out-of-boundaries"] = !1
            }
            return t
          }
        },
        computeStyle: {
          order: 850,
          enabled: !0,
          fn: function (t, e) {
            var i = e.x,
              s = e.y,
              n = t.offsets.popper,
              a = rt(t.instance.modifiers, function (t) {
                return "applyStyle" === t.name
              }).gpuAcceleration;
            void 0 !== a && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
            var o, r, l, c, d, h, u = void 0 !== a ? a : e.gpuAcceleration,
              p = z(t.instance.popper),
              f = J(p),
              m = {
                position: n.position
              },
              r = (o = t, r = window.devicePixelRatio < 2 || !mt, l = o.offsets, h = l.popper, c = l.reference, d = Math.round, a = Math.floor, e = function (t) {
                return t
              }, n = d(c.width), l = d(h.width), c = -1 !== ["left", "right"].indexOf(o.placement), o = -1 !== o.placement.indexOf("-"), a = r ? c || o || n % 2 == l % 2 ? d : a : e, e = r ? d : e, {
                left: a(n % 2 == 1 && l % 2 == 1 && !o && r ? h.left - 1 : h.left),
                top: e(h.top),
                bottom: e(h.bottom),
                right: a(h.right)
              }),
              e = "bottom" === i ? "top" : "bottom",
              a = "right" === s ? "left" : "right",
              h = dt("transform"),
              s = "bottom" == e ? "HTML" === p.nodeName ? -p.clientHeight + r.bottom : -f.height + r.bottom : r.top,
              i = "right" == a ? "HTML" === p.nodeName ? -p.clientWidth + r.right : -f.width + r.right : r.left;
            u && h ? (m[h] = "translate3d(" + i + "px, " + s + "px, 0)", m[e] = 0, m[a] = 0, m.willChange = "transform") : (h = "right" == a ? -1 : 1, m[e] = s * ("bottom" == e ? -1 : 1), m[a] = i * h, m.willChange = e + ", " + a);
            a = {
              "x-placement": t.placement
            };
            return t.attributes = G({}, a, t.attributes), t.styles = G({}, m, t.styles), t.arrowStyles = G({}, t.offsets.arrow, t.arrowStyles), t
          },
          gpuAcceleration: !0,
          x: "bottom",
          y: "right"
        },
        applyStyle: {
          order: 900,
          enabled: !0,
          fn: function (t) {
            var e, i;
            return ft(t.instance.popper, t.styles), e = t.instance.popper, i = t.attributes, Object.keys(i).forEach(function (t) {
              !1 !== i[t] ? e.setAttribute(t, i[t]) : e.removeAttribute(t)
            }), t.arrowElement && Object.keys(t.arrowStyles).length && ft(t.arrowElement, t.arrowStyles), t
          },
          onLoad: function (t, e, i, s, n) {
            n = st(n, e, t, i.positionFixed), t = it(i.placement, n, e, t, i.modifiers.flip.boundariesElement, i.modifiers.flip.padding);
            return e.setAttribute("x-placement", t), ft(e, {
              position: i.positionFixed ? "fixed" : "absolute"
            }), i
          },
          gpuAcceleration: void 0
        }
      }
    },
    wt = (X(xt, [{
      key: "update",
      value: function () {
        return function () {
          var t;
          this.state.isDestroyed || ((t = {
            instance: this,
            styles: {},
            arrowStyles: {},
            attributes: {},
            flipped: !1,
            offsets: {}
          }).offsets.reference = st(this.state, this.popper, this.reference, this.options.positionFixed), t.placement = it(this.options.placement, t.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), t.originalPlacement = t.placement, t.positionFixed = this.options.positionFixed, t.offsets.popper = ot(this.popper, t.offsets.reference, t.placement), t.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute", t = lt(this.modifiers, t), this.state.isCreated ? this.options.onUpdate(t) : (this.state.isCreated = !0, this.options.onCreate(t)))
        }.call(this)
      }
    }, {
      key: "destroy",
      value: function () {
        return function () {
          return this.state.isDestroyed = !0, ct(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[dt("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this
        }.call(this)
      }
    }, {
      key: "enableEventListeners",
      value: function () {
        return ut.call(this)
      }
    }, {
      key: "disableEventListeners",
      value: function () {
        return function () {
          var t, e;
          this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = (t = this.reference, e = this.state, ht(t).removeEventListener("resize", e.updateBound), e.scrollParents.forEach(function (t) {
            t.removeEventListener("scroll", e.updateBound)
          }), e.updateBound = null, e.scrollParents = [], e.scrollElement = null, e.eventsEnabled = !1, e))
        }.call(this)
      }
    }]), xt);

  function xt(t, e) {
    var i = this,
      s = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};
    U(this, xt), this.scheduleUpdate = function () {
      return requestAnimationFrame(i.update)
    }, this.update = A(this.update.bind(this)), this.options = G({}, xt.Defaults, s), this.state = {
      isDestroyed: !1,
      isCreated: !1,
      scrollParents: []
    }, this.reference = t && t.jquery ? t[0] : t, this.popper = e && e.jquery ? e[0] : e, this.options.modifiers = {}, Object.keys(G({}, xt.Defaults.modifiers, s.modifiers)).forEach(function (t) {
      i.options.modifiers[t] = G({}, xt.Defaults.modifiers[t] || {}, s.modifiers ? s.modifiers[t] : {})
    }), this.modifiers = Object.keys(this.options.modifiers).map(function (t) {
      return G({
        name: t
      }, i.options.modifiers[t])
    }).sort(function (t, e) {
      return t.order - e.order
    }), this.modifiers.forEach(function (t) {
      t.enabled && P(t.onLoad) && t.onLoad(i.reference, i.popper, i.options, t, i.state)
    }), this.update();
    e = this.options.eventsEnabled;
    e && this.enableEventListeners(), this.state.eventsEnabled = e
  }
  wt.Utils = ("undefined" != typeof window ? window : global).PopperUtils, wt.placements = vt, wt.Defaults = yt;
  var Ct = "dropdown",
    kt = d.default.fn[Ct],
    Tt = new RegExp("38|40|27"),
    Dt = {
      offset: 0,
      flip: !0,
      boundary: "scrollParent",
      reference: "toggle",
      display: "dynamic",
      popperConfig: null
    },
    St = {
      offset: "(number|string|function)",
      flip: "boolean",
      boundary: "(string|element)",
      reference: "(string|element)",
      display: "string",
      popperConfig: "(null|object)"
    },
    Mt = ((yt = Et.prototype).toggle = function () {
      var t;
      this._element.disabled || d.default(this._element).hasClass("disabled") || (t = d.default(this._menu).hasClass("show"), Et._clearMenus(), t || this.show(!0))
    }, yt.show = function (t) {
      if (void 0 === t && (t = !1), !(this._element.disabled || d.default(this._element).hasClass("disabled") || d.default(this._menu).hasClass("show"))) {
        var e = {
            relatedTarget: this._element
          },
          i = d.default.Event("show.bs.dropdown", e),
          s = Et._getParentFromElement(this._element);
        if (d.default(s).trigger(i), !i.isDefaultPrevented()) {
          if (!this._inNavbar && t) {
            if (void 0 === wt) throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");
            t = this._element;
            "parent" === this._config.reference ? t = s : h.isElement(this._config.reference) && (t = this._config.reference, void 0 !== this._config.reference.jquery && (t = this._config.reference[0])), "scrollParent" !== this._config.boundary && d.default(s).addClass("position-static"), this._popper = new wt(t, this._menu, this._getPopperConfig())
          }
          "ontouchstart" in document.documentElement && 0 === d.default(s).closest(".navbar-nav").length && d.default(document.body).children().on("mouseover", null, d.default.noop), this._element.focus(), this._element.setAttribute("aria-expanded", !0), d.default(this._menu).toggleClass("show"), d.default(s).toggleClass("show").trigger(d.default.Event("shown.bs.dropdown", e))
        }
      }
    }, yt.hide = function () {
      var t, e, i;
      this._element.disabled || d.default(this._element).hasClass("disabled") || !d.default(this._menu).hasClass("show") || (t = {
        relatedTarget: this._element
      }, e = d.default.Event("hide.bs.dropdown", t), i = Et._getParentFromElement(this._element), d.default(i).trigger(e), e.isDefaultPrevented() || (this._popper && this._popper.destroy(), d.default(this._menu).toggleClass("show"), d.default(i).toggleClass("show").trigger(d.default.Event("hidden.bs.dropdown", t))))
    }, yt.dispose = function () {
      d.default.removeData(this._element, "bs.dropdown"), d.default(this._element).off(".bs.dropdown"), this._element = null, (this._menu = null) !== this._popper && (this._popper.destroy(), this._popper = null)
    }, yt.update = function () {
      this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate()
    }, yt._addEventListeners = function () {
      var e = this;
      d.default(this._element).on("click.bs.dropdown", function (t) {
        t.preventDefault(), t.stopPropagation(), e.toggle()
      })
    }, yt._getConfig = function (t) {
      return t = a({}, this.constructor.Default, d.default(this._element).data(), t), h.typeCheckConfig(Ct, t, this.constructor.DefaultType), t
    }, yt._getMenuElement = function () {
      var t;
      return this._menu || (t = Et._getParentFromElement(this._element)) && (this._menu = t.querySelector(".dropdown-menu")), this._menu
    }, yt._getPlacement = function () {
      var t = d.default(this._element.parentNode),
        e = "bottom-start";
      return t.hasClass("dropup") ? e = d.default(this._menu).hasClass("dropdown-menu-right") ? "top-end" : "top-start" : t.hasClass("dropright") ? e = "right-start" : t.hasClass("dropleft") ? e = "left-start" : d.default(this._menu).hasClass("dropdown-menu-right") && (e = "bottom-end"), e
    }, yt._detectNavbar = function () {
      return 0 < d.default(this._element).closest(".navbar").length
    }, yt._getOffset = function () {
      var e = this,
        t = {};
      return "function" == typeof this._config.offset ? t.fn = function (t) {
        return t.offsets = a({}, t.offsets, e._config.offset(t.offsets, e._element) || {}), t
      } : t.offset = this._config.offset, t
    }, yt._getPopperConfig = function () {
      var t = {
        placement: this._getPlacement(),
        modifiers: {
          offset: this._getOffset(),
          flip: {
            enabled: this._config.flip
          },
          preventOverflow: {
            boundariesElement: this._config.boundary
          }
        }
      };
      return "static" === this._config.display && (t.modifiers.applyStyle = {
        enabled: !1
      }), a({}, t, this._config.popperConfig)
    }, Et._jQueryInterface = function (e) {
      return this.each(function () {
        var t = d.default(this).data("bs.dropdown");
        if (t || (t = new Et(this, "object" == typeof e ? e : null), d.default(this).data("bs.dropdown", t)), "string" == typeof e) {
          if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
          t[e]()
        }
      })
    }, Et._clearMenus = function (t) {
      if (!t || 3 !== t.which && ("keyup" !== t.type || 9 === t.which))
        for (var e = [].slice.call(document.querySelectorAll('[data-toggle="dropdown"]')), i = 0, s = e.length; i < s; i++) {
          var n, a, o = Et._getParentFromElement(e[i]),
            r = d.default(e[i]).data("bs.dropdown"),
            l = {
              relatedTarget: e[i]
            };
          t && "click" === t.type && (l.clickEvent = t), r && (n = r._menu, !d.default(o).hasClass("show") || t && ("click" === t.type && /input|textarea/i.test(t.target.tagName) || "keyup" === t.type && 9 === t.which) && d.default.contains(o, t.target) || (a = d.default.Event("hide.bs.dropdown", l), d.default(o).trigger(a), a.isDefaultPrevented() || ("ontouchstart" in document.documentElement && d.default(document.body).children().off("mouseover", null, d.default.noop), e[i].setAttribute("aria-expanded", "false"), r._popper && r._popper.destroy(), d.default(n).removeClass("show"), d.default(o).removeClass("show").trigger(d.default.Event("hidden.bs.dropdown", l)))))
        }
    }, Et._getParentFromElement = function (t) {
      var e, i = h.getSelectorFromElement(t);
      return (e = i ? document.querySelector(i) : e) || t.parentNode
    }, Et._dataApiKeydownHandler = function (t) {
      if (!(/input|textarea/i.test(t.target.tagName) ? 32 === t.which || 27 !== t.which && (40 !== t.which && 38 !== t.which || d.default(t.target).closest(".dropdown-menu").length) : !Tt.test(t.which)) && !this.disabled && !d.default(this).hasClass("disabled")) {
        var e = Et._getParentFromElement(this),
          i = d.default(e).hasClass("show");
        if (i || 27 !== t.which) {
          if (t.preventDefault(), t.stopPropagation(), !i || 27 === t.which || 32 === t.which) return 27 === t.which && d.default(e.querySelector('[data-toggle="dropdown"]')).trigger("focus"), void d.default(this).trigger("click");
          i = [].slice.call(e.querySelectorAll(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)")).filter(function (t) {
            return d.default(t).is(":visible")
          });
          0 !== i.length && (e = i.indexOf(t.target), 38 === t.which && 0 < e && e--, 40 === t.which && e < i.length - 1 && e++, i[e = e < 0 ? 0 : e].focus())
        }
      }
    }, n(Et, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }, {
      key: "Default",
      get: function () {
        return Dt
      }
    }, {
      key: "DefaultType",
      get: function () {
        return St
      }
    }]), Et);

  function Et(t, e) {
    this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners()
  }
  d.default(document).on("keydown.bs.dropdown.data-api", '[data-toggle="dropdown"]', Mt._dataApiKeydownHandler).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Mt._dataApiKeydownHandler).on("click.bs.dropdown.data-api keyup.bs.dropdown.data-api", Mt._clearMenus).on("click.bs.dropdown.data-api", '[data-toggle="dropdown"]', function (t) {
    t.preventDefault(), t.stopPropagation(), Mt._jQueryInterface.call(d.default(this), "toggle")
  }).on("click.bs.dropdown.data-api", ".dropdown form", function (t) {
    t.stopPropagation()
  }), d.default.fn[Ct] = Mt._jQueryInterface, d.default.fn[Ct].Constructor = Mt, d.default.fn[Ct].noConflict = function () {
    return d.default.fn[Ct] = kt, Mt._jQueryInterface
  };
  var At = d.default.fn.modal,
    Pt = {
      backdrop: !0,
      keyboard: !0,
      focus: !0,
      show: !0
    },
    It = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      focus: "boolean",
      show: "boolean"
    },
    Ot = ((yt = $t.prototype).toggle = function (t) {
      return this._isShown ? this.hide() : this.show(t)
    }, yt.show = function (t) {
      var e, i = this;
      this._isShown || this._isTransitioning || (d.default(this._element).hasClass("fade") && (this._isTransitioning = !0), e = d.default.Event("show.bs.modal", {
        relatedTarget: t
      }), d.default(this._element).trigger(e), this._isShown || e.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), d.default(this._element).on("click.dismiss.bs.modal", '[data-dismiss="modal"]', function (t) {
        return i.hide(t)
      }), d.default(this._dialog).on("mousedown.dismiss.bs.modal", function () {
        d.default(i._element).one("mouseup.dismiss.bs.modal", function (t) {
          d.default(t.target).is(i._element) && (i._ignoreBackdropClick = !0)
        })
      }), this._showBackdrop(function () {
        return i._showElement(t)
      })))
    }, yt.hide = function (t) {
      var e = this;
      t && t.preventDefault(), this._isShown && !this._isTransitioning && (t = d.default.Event("hide.bs.modal"), d.default(this._element).trigger(t), this._isShown && !t.isDefaultPrevented() && (this._isShown = !1, (t = d.default(this._element).hasClass("fade")) && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), d.default(document).off("focusin.bs.modal"), d.default(this._element).removeClass("show"), d.default(this._element).off("click.dismiss.bs.modal"), d.default(this._dialog).off("mousedown.dismiss.bs.modal"), t ? (t = h.getTransitionDurationFromElement(this._element), d.default(this._element).one(h.TRANSITION_END, function (t) {
        return e._hideModal(t)
      }).emulateTransitionEnd(t)) : this._hideModal()))
    }, yt.dispose = function () {
      [window, this._element, this._dialog].forEach(function (t) {
        return d.default(t).off(".bs.modal")
      }), d.default(document).off("focusin.bs.modal"), d.default.removeData(this._element, "bs.modal"), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null
    }, yt.handleUpdate = function () {
      this._adjustDialog()
    }, yt._getConfig = function (t) {
      return t = a({}, Pt, t), h.typeCheckConfig("modal", t, It), t
    }, yt._triggerBackdropTransition = function () {
      var t, e, i, s = this;
      "static" === this._config.backdrop ? (t = d.default.Event("hidePrevented.bs.modal"), d.default(this._element).trigger(t), t.isDefaultPrevented() || ((e = this._element.scrollHeight > document.documentElement.clientHeight) || (this._element.style.overflowY = "hidden"), this._element.classList.add("modal-static"), i = h.getTransitionDurationFromElement(this._dialog), d.default(this._element).off(h.TRANSITION_END), d.default(this._element).one(h.TRANSITION_END, function () {
        s._element.classList.remove("modal-static"), e || d.default(s._element).one(h.TRANSITION_END, function () {
          s._element.style.overflowY = ""
        }).emulateTransitionEnd(s._element, i)
      }).emulateTransitionEnd(i), this._element.focus())) : this.hide()
    }, yt._showElement = function (t) {
      var e = this,
        i = d.default(this._element).hasClass("fade"),
        s = this._dialog ? this._dialog.querySelector(".modal-body") : null;
      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), d.default(this._dialog).hasClass("modal-dialog-scrollable") && s ? s.scrollTop = 0 : this._element.scrollTop = 0, i && h.reflow(this._element), d.default(this._element).addClass("show"), this._config.focus && this._enforceFocus();
      var n = d.default.Event("shown.bs.modal", {
          relatedTarget: t
        }),
        t = function () {
          e._config.focus && e._element.focus(), e._isTransitioning = !1, d.default(e._element).trigger(n)
        };
      i ? (i = h.getTransitionDurationFromElement(this._dialog), d.default(this._dialog).one(h.TRANSITION_END, t).emulateTransitionEnd(i)) : t()
    }, yt._enforceFocus = function () {
      var e = this;
      d.default(document).off("focusin.bs.modal").on("focusin.bs.modal", function (t) {
        document !== t.target && e._element !== t.target && 0 === d.default(e._element).has(t.target).length && e._element.focus()
      })
    }, yt._setEscapeEvent = function () {
      var e = this;
      this._isShown ? d.default(this._element).on("keydown.dismiss.bs.modal", function (t) {
        e._config.keyboard && 27 === t.which ? (t.preventDefault(), e.hide()) : e._config.keyboard || 27 !== t.which || e._triggerBackdropTransition()
      }) : this._isShown || d.default(this._element).off("keydown.dismiss.bs.modal")
    }, yt._setResizeEvent = function () {
      var e = this;
      this._isShown ? d.default(window).on("resize.bs.modal", function (t) {
        return e.handleUpdate(t)
      }) : d.default(window).off("resize.bs.modal")
    }, yt._hideModal = function () {
      var t = this;
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._showBackdrop(function () {
        d.default(document.body).removeClass("modal-open"), t._resetAdjustments(), t._resetScrollbar(), d.default(t._element).trigger("hidden.bs.modal")
      })
    }, yt._removeBackdrop = function () {
      this._backdrop && (d.default(this._backdrop).remove(), this._backdrop = null)
    }, yt._showBackdrop = function (t) {
      var e, i = this,
        s = d.default(this._element).hasClass("fade") ? "fade" : "";
      this._isShown && this._config.backdrop ? (this._backdrop = document.createElement("div"), this._backdrop.className = "modal-backdrop", s && this._backdrop.classList.add(s), d.default(this._backdrop).appendTo(document.body), d.default(this._element).on("click.dismiss.bs.modal", function (t) {
        i._ignoreBackdropClick ? i._ignoreBackdropClick = !1 : t.target === t.currentTarget && i._triggerBackdropTransition()
      }), s && h.reflow(this._backdrop), d.default(this._backdrop).addClass("show"), t && (s ? (e = h.getTransitionDurationFromElement(this._backdrop), d.default(this._backdrop).one(h.TRANSITION_END, t).emulateTransitionEnd(e)) : t())) : !this._isShown && this._backdrop ? (d.default(this._backdrop).removeClass("show"), s = function () {
        i._removeBackdrop(), t && t()
      }, d.default(this._element).hasClass("fade") ? (e = h.getTransitionDurationFromElement(this._backdrop), d.default(this._backdrop).one(h.TRANSITION_END, s).emulateTransitionEnd(e)) : s()) : t && t()
    }, yt._adjustDialog = function () {
      var t = this._element.scrollHeight > document.documentElement.clientHeight;
      !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + "px")
    }, yt._resetAdjustments = function () {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
    }, yt._checkScrollbar = function () {
      var t = document.body.getBoundingClientRect();
      this._isBodyOverflowing = Math.round(t.left + t.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth()
    }, yt._setScrollbar = function () {
      var t, e, n = this;
      this._isBodyOverflowing && (t = [].slice.call(document.querySelectorAll(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top")), e = [].slice.call(document.querySelectorAll(".sticky-top")), d.default(t).each(function (t, e) {
        var i = e.style.paddingRight,
          s = d.default(e).css("padding-right");
        d.default(e).data("padding-right", i).css("padding-right", parseFloat(s) + n._scrollbarWidth + "px")
      }), d.default(e).each(function (t, e) {
        var i = e.style.marginRight,
          s = d.default(e).css("margin-right");
        d.default(e).data("margin-right", i).css("margin-right", parseFloat(s) - n._scrollbarWidth + "px")
      }), t = document.body.style.paddingRight, e = d.default(document.body).css("padding-right"), d.default(document.body).data("padding-right", t).css("padding-right", parseFloat(e) + this._scrollbarWidth + "px")), d.default(document.body).addClass("modal-open")
    }, yt._resetScrollbar = function () {
      var t = [].slice.call(document.querySelectorAll(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"));
      d.default(t).each(function (t, e) {
        var i = d.default(e).data("padding-right");
        d.default(e).removeData("padding-right"), e.style.paddingRight = i || ""
      });
      t = [].slice.call(document.querySelectorAll(".sticky-top"));
      d.default(t).each(function (t, e) {
        var i = d.default(e).data("margin-right");
        void 0 !== i && d.default(e).css("margin-right", i).removeData("margin-right")
      });
      t = d.default(document.body).data("padding-right");
      d.default(document.body).removeData("padding-right"), document.body.style.paddingRight = t || ""
    }, yt._getScrollbarWidth = function () {
      var t = document.createElement("div");
      t.className = "modal-scrollbar-measure", document.body.appendChild(t);
      var e = t.getBoundingClientRect().width - t.clientWidth;
      return document.body.removeChild(t), e
    }, $t._jQueryInterface = function (i, s) {
      return this.each(function () {
        var t = d.default(this).data("bs.modal"),
          e = a({}, Pt, d.default(this).data(), "object" == typeof i && i ? i : {});
        if (t || (t = new $t(this, e), d.default(this).data("bs.modal", t)), "string" == typeof i) {
          if (void 0 === t[i]) throw new TypeError('No method named "' + i + '"');
          t[i](s)
        } else e.show && t.show(s)
      })
    }, n($t, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }, {
      key: "Default",
      get: function () {
        return Pt
      }
    }]), $t);

  function $t(t, e) {
    this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(".modal-dialog"), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0
  }
  d.default(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (t) {
    var e, i = this,
      s = h.getSelectorFromElement(this);
    s && (e = document.querySelector(s));
    s = d.default(e).data("bs.modal") ? "toggle" : a({}, d.default(e).data(), d.default(this).data());
    "A" !== this.tagName && "AREA" !== this.tagName || t.preventDefault();
    var n = d.default(e).one("show.bs.modal", function (t) {
      t.isDefaultPrevented() || n.one("hidden.bs.modal", function () {
        d.default(i).is(":visible") && i.focus()
      })
    });
    Ot._jQueryInterface.call(d.default(e), s, this)
  }), d.default.fn.modal = Ot._jQueryInterface, d.default.fn.modal.Constructor = Ot, d.default.fn.modal.noConflict = function () {
    return d.default.fn.modal = At, Ot._jQueryInterface
  };
  var Lt = ["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"],
    Nt = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,
    Ht = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

  function Ft(t, n, e) {
    if (0 === t.length) return t;
    if (e && "function" == typeof e) return e(t);
    for (var t = (new window.DOMParser).parseFromString(t, "text/html"), a = Object.keys(n), o = [].slice.call(t.body.querySelectorAll("*")), i = 0, s = o.length; i < s; i++) ! function (t) {
      var e = o[t],
        i = e.nodeName.toLowerCase();
      if (-1 === a.indexOf(e.nodeName.toLowerCase())) return e.parentNode.removeChild(e);
      var t = [].slice.call(e.attributes),
        s = [].concat(n["*"] || [], n[i] || []);
      t.forEach(function (t) {
        ! function (t, e) {
          var i = t.nodeName.toLowerCase();
          if (-1 !== e.indexOf(i)) return -1 === Lt.indexOf(i) || Boolean(t.nodeValue.match(Nt) || t.nodeValue.match(Ht));
          for (var s = e.filter(function (t) {
              return t instanceof RegExp
            }), n = 0, a = s.length; n < a; n++)
            if (i.match(s[n])) return 1
        }(t, s) && e.removeAttribute(t.nodeName)
      })
    }(i);
    return t.body.innerHTML
  }
  var zt = "tooltip",
    Rt = d.default.fn[zt],
    Bt = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
    jt = ["sanitize", "whiteList", "sanitizeFn"],
    Wt = {
      animation: "boolean",
      template: "string",
      title: "(string|element|function)",
      trigger: "string",
      delay: "(number|object)",
      html: "boolean",
      selector: "(string|boolean)",
      placement: "(string|function)",
      offset: "(number|string|function)",
      container: "(string|element|boolean)",
      fallbackPlacement: "(string|array)",
      boundary: "(string|element)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      whiteList: "object",
      popperConfig: "(null|object)"
    },
    Vt = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: "right",
      BOTTOM: "bottom",
      LEFT: "left"
    },
    qt = {
      animation: !0,
      template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
      trigger: "hover focus",
      title: "",
      delay: 0,
      html: !1,
      selector: !1,
      placement: "top",
      offset: 0,
      container: !1,
      fallbackPlacement: "flip",
      boundary: "scrollParent",
      sanitize: !0,
      sanitizeFn: null,
      whiteList: {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
      },
      popperConfig: null
    },
    Yt = {
      HIDE: "hide.bs.tooltip",
      HIDDEN: "hidden.bs.tooltip",
      SHOW: "show.bs.tooltip",
      SHOWN: "shown.bs.tooltip",
      INSERTED: "inserted.bs.tooltip",
      CLICK: "click.bs.tooltip",
      FOCUSIN: "focusin.bs.tooltip",
      FOCUSOUT: "focusout.bs.tooltip",
      MOUSEENTER: "mouseenter.bs.tooltip",
      MOUSELEAVE: "mouseleave.bs.tooltip"
    },
    Ut = ((yt = Xt.prototype).enable = function () {
      this._isEnabled = !0
    }, yt.disable = function () {
      this._isEnabled = !1
    }, yt.toggleEnabled = function () {
      this._isEnabled = !this._isEnabled
    }, yt.toggle = function (t) {
      var e, i;
      this._isEnabled && (t ? (e = this.constructor.DATA_KEY, (i = d.default(t.currentTarget).data(e)) || (i = new this.constructor(t.currentTarget, this._getDelegateConfig()), d.default(t.currentTarget).data(e, i)), i._activeTrigger.click = !i._activeTrigger.click, i._isWithActiveTrigger() ? i._enter(null, i) : i._leave(null, i)) : d.default(this.getTipElement()).hasClass("show") ? this._leave(null, this) : this._enter(null, this))
    }, yt.dispose = function () {
      clearTimeout(this._timeout), d.default.removeData(this.element, this.constructor.DATA_KEY), d.default(this.element).off(this.constructor.EVENT_KEY), d.default(this.element).closest(".modal").off("hide.bs.modal", this._hideModalHandler), this.tip && d.default(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null
    }, yt.show = function () {
      var e = this;
      if ("none" === d.default(this.element).css("display")) throw new Error("Please use show on visible elements");
      var t, i, s = d.default.Event(this.constructor.Event.SHOW);
      this.isWithContent() && this._isEnabled && (d.default(this.element).trigger(s), i = h.findShadowRoot(this.element), t = d.default.contains(null !== i ? i : this.element.ownerDocument.documentElement, this.element), !s.isDefaultPrevented() && t && (i = this.getTipElement(), s = h.getUID(this.constructor.NAME), i.setAttribute("id", s), this.element.setAttribute("aria-describedby", s), this.setContent(), this.config.animation && d.default(i).addClass("fade"), t = "function" == typeof this.config.placement ? this.config.placement.call(this, i, this.element) : this.config.placement, s = this._getAttachment(t), this.addAttachmentClass(s), t = this._getContainer(), d.default(i).data(this.constructor.DATA_KEY, this), d.default.contains(this.element.ownerDocument.documentElement, this.tip) || d.default(i).appendTo(t), d.default(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new wt(this.element, i, this._getPopperConfig(s)), d.default(i).addClass("show"), "ontouchstart" in document.documentElement && d.default(document.body).children().on("mouseover", null, d.default.noop), s = function () {
        e.config.animation && e._fixTransition();
        var t = e._hoverState;
        e._hoverState = null, d.default(e.element).trigger(e.constructor.Event.SHOWN), "out" === t && e._leave(null, e)
      }, d.default(this.tip).hasClass("fade") ? (i = h.getTransitionDurationFromElement(this.tip), d.default(this.tip).one(h.TRANSITION_END, s).emulateTransitionEnd(i)) : s()))
    }, yt.hide = function (t) {
      function e() {
        "show" !== i._hoverState && s.parentNode && s.parentNode.removeChild(s), i._cleanTipClass(), i.element.removeAttribute("aria-describedby"), d.default(i.element).trigger(i.constructor.Event.HIDDEN), null !== i._popper && i._popper.destroy(), t && t()
      }
      var i = this,
        s = this.getTipElement(),
        n = d.default.Event(this.constructor.Event.HIDE);
      d.default(this.element).trigger(n), n.isDefaultPrevented() || (d.default(s).removeClass("show"), "ontouchstart" in document.documentElement && d.default(document.body).children().off("mouseover", null, d.default.noop), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, d.default(this.tip).hasClass("fade") ? (n = h.getTransitionDurationFromElement(s), d.default(s).one(h.TRANSITION_END, e).emulateTransitionEnd(n)) : e(), this._hoverState = "")
    }, yt.update = function () {
      null !== this._popper && this._popper.scheduleUpdate()
    }, yt.isWithContent = function () {
      return Boolean(this.getTitle())
    }, yt.addAttachmentClass = function (t) {
      d.default(this.getTipElement()).addClass("bs-tooltip-" + t)
    }, yt.getTipElement = function () {
      return this.tip = this.tip || d.default(this.config.template)[0], this.tip
    }, yt.setContent = function () {
      var t = this.getTipElement();
      this.setElementContent(d.default(t.querySelectorAll(".tooltip-inner")), this.getTitle()), d.default(t).removeClass("fade show")
    }, yt.setElementContent = function (t, e) {
      "object" != typeof e || !e.nodeType && !e.jquery ? this.config.html ? (this.config.sanitize && (e = Ft(e, this.config.whiteList, this.config.sanitizeFn)), t.html(e)) : t.text(e) : this.config.html ? d.default(e).parent().is(t) || t.empty().append(e) : t.text(d.default(e).text())
    }, yt.getTitle = function () {
      return this.element.getAttribute("data-original-title") || ("function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title)
    }, yt._getPopperConfig = function (t) {
      var e = this;
      return a({}, {
        placement: t,
        modifiers: {
          offset: this._getOffset(),
          flip: {
            behavior: this.config.fallbackPlacement
          },
          arrow: {
            element: ".arrow"
          },
          preventOverflow: {
            boundariesElement: this.config.boundary
          }
        },
        onCreate: function (t) {
          t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t)
        },
        onUpdate: function (t) {
          return e._handlePopperPlacementChange(t)
        }
      }, this.config.popperConfig)
    }, yt._getOffset = function () {
      var e = this,
        t = {};
      return "function" == typeof this.config.offset ? t.fn = function (t) {
        return t.offsets = a({}, t.offsets, e.config.offset(t.offsets, e.element) || {}), t
      } : t.offset = this.config.offset, t
    }, yt._getContainer = function () {
      return !1 === this.config.container ? document.body : h.isElement(this.config.container) ? d.default(this.config.container) : d.default(document).find(this.config.container)
    }, yt._getAttachment = function (t) {
      return Vt[t.toUpperCase()]
    }, yt._setListeners = function () {
      var i = this;
      this.config.trigger.split(" ").forEach(function (t) {
        var e;
        "click" === t ? d.default(i.element).on(i.constructor.Event.CLICK, i.config.selector, function (t) {
          return i.toggle(t)
        }) : "manual" !== t && (e = "hover" === t ? i.constructor.Event.MOUSEENTER : i.constructor.Event.FOCUSIN, t = "hover" === t ? i.constructor.Event.MOUSELEAVE : i.constructor.Event.FOCUSOUT, d.default(i.element).on(e, i.config.selector, function (t) {
          return i._enter(t)
        }).on(t, i.config.selector, function (t) {
          return i._leave(t)
        }))
      }), this._hideModalHandler = function () {
        i.element && i.hide()
      }, d.default(this.element).closest(".modal").on("hide.bs.modal", this._hideModalHandler), this.config.selector ? this.config = a({}, this.config, {
        trigger: "manual",
        selector: ""
      }) : this._fixTitle()
    }, yt._fixTitle = function () {
      var t = typeof this.element.getAttribute("data-original-title");
      !this.element.getAttribute("title") && "string" == t || (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), this.element.setAttribute("title", ""))
    }, yt._enter = function (t, e) {
      var i = this.constructor.DATA_KEY;
      (e = e || d.default(t.currentTarget).data(i)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), d.default(t.currentTarget).data(i, e)), t && (e._activeTrigger["focusin" === t.type ? "focus" : "hover"] = !0), d.default(e.getTipElement()).hasClass("show") || "show" === e._hoverState ? e._hoverState = "show" : (clearTimeout(e._timeout), e._hoverState = "show", e.config.delay && e.config.delay.show ? e._timeout = setTimeout(function () {
        "show" === e._hoverState && e.show()
      }, e.config.delay.show) : e.show())
    }, yt._leave = function (t, e) {
      var i = this.constructor.DATA_KEY;
      (e = e || d.default(t.currentTarget).data(i)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), d.default(t.currentTarget).data(i, e)), t && (e._activeTrigger["focusout" === t.type ? "focus" : "hover"] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = "out", e.config.delay && e.config.delay.hide ? e._timeout = setTimeout(function () {
        "out" === e._hoverState && e.hide()
      }, e.config.delay.hide) : e.hide())
    }, yt._isWithActiveTrigger = function () {
      for (var t in this._activeTrigger)
        if (this._activeTrigger[t]) return !0;
      return !1
    }, yt._getConfig = function (t) {
      var e = d.default(this.element).data();
      return Object.keys(e).forEach(function (t) {
        -1 !== jt.indexOf(t) && delete e[t]
      }), "number" == typeof (t = a({}, this.constructor.Default, e, "object" == typeof t && t ? t : {})).delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), h.typeCheckConfig(zt, t, this.constructor.DefaultType), t.sanitize && (t.template = Ft(t.template, t.whiteList, t.sanitizeFn)), t
    }, yt._getDelegateConfig = function () {
      var t = {};
      if (this.config)
        for (var e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);
      return t
    }, yt._cleanTipClass = function () {
      var t = d.default(this.getTipElement()),
        e = t.attr("class").match(Bt);
      null !== e && e.length && t.removeClass(e.join(""))
    }, yt._handlePopperPlacementChange = function (t) {
      this.tip = t.instance.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement))
    }, yt._fixTransition = function () {
      var t = this.getTipElement(),
        e = this.config.animation;
      null === t.getAttribute("x-placement") && (d.default(t).removeClass("fade"), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e)
    }, Xt._jQueryInterface = function (s) {
      return this.each(function () {
        var t = d.default(this),
          e = t.data("bs.tooltip"),
          i = "object" == typeof s && s;
        if ((e || !/dispose|hide/.test(s)) && (e || (e = new Xt(this, i), t.data("bs.tooltip", e)), "string" == typeof s)) {
          if (void 0 === e[s]) throw new TypeError('No method named "' + s + '"');
          e[s]()
        }
      })
    }, n(Xt, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }, {
      key: "Default",
      get: function () {
        return qt
      }
    }, {
      key: "NAME",
      get: function () {
        return zt
      }
    }, {
      key: "DATA_KEY",
      get: function () {
        return "bs.tooltip"
      }
    }, {
      key: "Event",
      get: function () {
        return Yt
      }
    }, {
      key: "EVENT_KEY",
      get: function () {
        return ".bs.tooltip"
      }
    }, {
      key: "DefaultType",
      get: function () {
        return Wt
      }
    }]), Xt);

  function Xt(t, e) {
    if (void 0 === wt) throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");
    this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners()
  }
  d.default.fn[zt] = Ut._jQueryInterface, d.default.fn[zt].Constructor = Ut, d.default.fn[zt].noConflict = function () {
    return d.default.fn[zt] = Rt, Ut._jQueryInterface
  };
  var Gt = "popover",
    Kt = d.default.fn[Gt],
    Qt = new RegExp("(^|\\s)bs-popover\\S+", "g"),
    Jt = a({}, Ut.Default, {
      placement: "right",
      trigger: "click",
      content: "",
      template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
    }),
    Zt = a({}, Ut.DefaultType, {
      content: "(string|element|function)"
    }),
    te = {
      HIDE: "hide.bs.popover",
      HIDDEN: "hidden.bs.popover",
      SHOW: "show.bs.popover",
      SHOWN: "shown.bs.popover",
      INSERTED: "inserted.bs.popover",
      CLICK: "click.bs.popover",
      FOCUSIN: "focusin.bs.popover",
      FOCUSOUT: "focusout.bs.popover",
      MOUSEENTER: "mouseenter.bs.popover",
      MOUSELEAVE: "mouseleave.bs.popover"
    },
    ee = function (t) {
      var e;

      function s() {
        return t.apply(this, arguments) || this
      }
      i = t, (e = s).prototype = Object.create(i.prototype), (e.prototype.constructor = e).__proto__ = i;
      var i = s.prototype;
      return i.isWithContent = function () {
        return this.getTitle() || this._getContent()
      }, i.addAttachmentClass = function (t) {
        d.default(this.getTipElement()).addClass("bs-popover-" + t)
      }, i.getTipElement = function () {
        return this.tip = this.tip || d.default(this.config.template)[0], this.tip
      }, i.setContent = function () {
        var t = d.default(this.getTipElement());
        this.setElementContent(t.find(".popover-header"), this.getTitle());
        var e = this._getContent();
        "function" == typeof e && (e = e.call(this.element)), this.setElementContent(t.find(".popover-body"), e), t.removeClass("fade show")
      }, i._getContent = function () {
        return this.element.getAttribute("data-content") || this.config.content
      }, i._cleanTipClass = function () {
        var t = d.default(this.getTipElement()),
          e = t.attr("class").match(Qt);
        null !== e && 0 < e.length && t.removeClass(e.join(""))
      }, s._jQueryInterface = function (i) {
        return this.each(function () {
          var t = d.default(this).data("bs.popover"),
            e = "object" == typeof i ? i : null;
          if ((t || !/dispose|hide/.test(i)) && (t || (t = new s(this, e), d.default(this).data("bs.popover", t)), "string" == typeof i)) {
            if (void 0 === t[i]) throw new TypeError('No method named "' + i + '"');
            t[i]()
          }
        })
      }, n(s, null, [{
        key: "VERSION",
        get: function () {
          return "4.5.3"
        }
      }, {
        key: "Default",
        get: function () {
          return Jt
        }
      }, {
        key: "NAME",
        get: function () {
          return Gt
        }
      }, {
        key: "DATA_KEY",
        get: function () {
          return "bs.popover"
        }
      }, {
        key: "Event",
        get: function () {
          return te
        }
      }, {
        key: "EVENT_KEY",
        get: function () {
          return ".bs.popover"
        }
      }, {
        key: "DefaultType",
        get: function () {
          return Zt
        }
      }]), s
    }(Ut);
  d.default.fn[Gt] = ee._jQueryInterface, d.default.fn[Gt].Constructor = ee, d.default.fn[Gt].noConflict = function () {
    return d.default.fn[Gt] = Kt, ee._jQueryInterface
  };
  var ie = "scrollspy",
    se = d.default.fn[ie],
    ne = {
      offset: 10,
      method: "auto",
      target: ""
    },
    ae = {
      offset: "number",
      method: "string",
      target: "(string|element)"
    },
    oe = ((yt = re.prototype).refresh = function () {
      var e = this,
        t = this._scrollElement === this._scrollElement.window ? "offset" : "position",
        s = "auto" === this._config.method ? t : this._config.method,
        n = "position" === s ? this._getScrollTop() : 0;
      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map(function (t) {
        var e, i = h.getSelectorFromElement(t);
        if (e = i ? document.querySelector(i) : e) {
          t = e.getBoundingClientRect();
          if (t.width || t.height) return [d.default(e)[s]().top + n, i]
        }
        return null
      }).filter(function (t) {
        return t
      }).sort(function (t, e) {
        return t[0] - e[0]
      }).forEach(function (t) {
        e._offsets.push(t[0]), e._targets.push(t[1])
      })
    }, yt.dispose = function () {
      d.default.removeData(this._element, "bs.scrollspy"), d.default(this._scrollElement).off(".bs.scrollspy"), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null
    }, yt._getConfig = function (t) {
      var e;
      return "string" != typeof (t = a({}, ne, "object" == typeof t && t ? t : {})).target && h.isElement(t.target) && ((e = d.default(t.target).attr("id")) || (e = h.getUID(ie), d.default(t.target).attr("id", e)), t.target = "#" + e), h.typeCheckConfig(ie, t, ae), t
    }, yt._getScrollTop = function () {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
    }, yt._getScrollHeight = function () {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
    }, yt._getOffsetHeight = function () {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
    }, yt._process = function () {
      var t = this._getScrollTop() + this._config.offset,
        e = this._getScrollHeight(),
        i = this._config.offset + e - this._getOffsetHeight();
      if (this._scrollHeight !== e && this.refresh(), i <= t) {
        i = this._targets[this._targets.length - 1];
        this._activeTarget !== i && this._activate(i)
      } else {
        if (this._activeTarget && t < this._offsets[0] && 0 < this._offsets[0]) return this._activeTarget = null, void this._clear();
        for (var s = this._offsets.length; s--;) this._activeTarget !== this._targets[s] && t >= this._offsets[s] && (void 0 === this._offsets[s + 1] || t < this._offsets[s + 1]) && this._activate(this._targets[s])
      }
    }, yt._activate = function (e) {
      this._activeTarget = e, this._clear();
      var t = this._selector.split(",").map(function (t) {
          return t + '[data-target="' + e + '"],' + t + '[href="' + e + '"]'
        }),
        t = d.default([].slice.call(document.querySelectorAll(t.join(","))));
      t.hasClass("dropdown-item") ? (t.closest(".dropdown").find(".dropdown-toggle").addClass("active"), t.addClass("active")) : (t.addClass("active"), t.parents(".nav, .list-group").prev(".nav-link, .list-group-item").addClass("active"), t.parents(".nav, .list-group").prev(".nav-item").children(".nav-link").addClass("active")), d.default(this._scrollElement).trigger("activate.bs.scrollspy", {
        relatedTarget: e
      })
    }, yt._clear = function () {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (t) {
        return t.classList.contains("active")
      }).forEach(function (t) {
        return t.classList.remove("active")
      })
    }, re._jQueryInterface = function (e) {
      return this.each(function () {
        var t = d.default(this).data("bs.scrollspy");
        if (t || (t = new re(this, "object" == typeof e && e), d.default(this).data("bs.scrollspy", t)), "string" == typeof e) {
          if (void 0 === t[e]) throw new TypeError('No method named "' + e + '"');
          t[e]()
        }
      })
    }, n(re, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }, {
      key: "Default",
      get: function () {
        return ne
      }
    }]), re);

  function re(t, e) {
    var i = this;
    this._element = t, this._scrollElement = "BODY" === t.tagName ? window : t, this._config = this._getConfig(e), this._selector = this._config.target + " .nav-link," + this._config.target + " .list-group-item," + this._config.target + " .dropdown-item", this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, d.default(this._scrollElement).on("scroll.bs.scrollspy", function (t) {
      return i._process(t)
    }), this.refresh(), this._process()
  }
  d.default(window).on("load.bs.scrollspy.data-api", function () {
    for (var t = [].slice.call(document.querySelectorAll('[data-spy="scroll"]')), e = t.length; e--;) {
      var i = d.default(t[e]);
      oe._jQueryInterface.call(i, i.data())
    }
  }), d.default.fn[ie] = oe._jQueryInterface, d.default.fn[ie].Constructor = oe, d.default.fn[ie].noConflict = function () {
    return d.default.fn[ie] = se, oe._jQueryInterface
  };
  var le = d.default.fn.tab,
    ce = ((yt = de.prototype).show = function () {
      var t, e, i, s, n, a, o = this;
      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && d.default(this._element).hasClass("active") || d.default(this._element).hasClass("disabled") || (a = d.default(this._element).closest(".nav, .list-group")[0], e = h.getSelectorFromElement(this._element), a && (n = "UL" === a.nodeName || "OL" === a.nodeName ? "> li > .active" : ".active", i = (i = d.default.makeArray(d.default(a).find(n)))[i.length - 1]), s = d.default.Event("hide.bs.tab", {
        relatedTarget: this._element
      }), n = d.default.Event("show.bs.tab", {
        relatedTarget: i
      }), i && d.default(i).trigger(s), d.default(this._element).trigger(n), n.isDefaultPrevented() || s.isDefaultPrevented() || (e && (t = document.querySelector(e)), this._activate(this._element, a), a = function () {
        var t = d.default.Event("hidden.bs.tab", {
            relatedTarget: o._element
          }),
          e = d.default.Event("shown.bs.tab", {
            relatedTarget: i
          });
        d.default(i).trigger(t), d.default(o._element).trigger(e)
      }, t ? this._activate(t, t.parentNode, a) : a()))
    }, yt.dispose = function () {
      d.default.removeData(this._element, "bs.tab"), this._element = null
    }, yt._activate = function (t, e, i) {
      var s = this,
        n = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? d.default(e).children(".active") : d.default(e).find("> li > .active"))[0],
        a = i && n && d.default(n).hasClass("fade"),
        e = function () {
          return s._transitionComplete(t, n, i)
        };
      n && a ? (a = h.getTransitionDurationFromElement(n), d.default(n).removeClass("show").one(h.TRANSITION_END, e).emulateTransitionEnd(a)) : e()
    }, yt._transitionComplete = function (t, e, i) {
      var s;
      e && (d.default(e).removeClass("active"), (s = d.default(e.parentNode).find("> .dropdown-menu .active")[0]) && d.default(s).removeClass("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1)), d.default(t).addClass("active"), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), h.reflow(t), t.classList.contains("fade") && t.classList.add("show"), t.parentNode && d.default(t.parentNode).hasClass("dropdown-menu") && ((e = d.default(t).closest(".dropdown")[0]) && (e = [].slice.call(e.querySelectorAll(".dropdown-toggle")), d.default(e).addClass("active")), t.setAttribute("aria-expanded", !0)), i && i()
    }, de._jQueryInterface = function (i) {
      return this.each(function () {
        var t = d.default(this),
          e = t.data("bs.tab");
        if (e || (e = new de(this), t.data("bs.tab", e)), "string" == typeof i) {
          if (void 0 === e[i]) throw new TypeError('No method named "' + i + '"');
          e[i]()
        }
      })
    }, n(de, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }]), de);

  function de(t) {
    this._element = t
  }
  d.default(document).on("click.bs.tab.data-api", '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]', function (t) {
    t.preventDefault(), ce._jQueryInterface.call(d.default(this), "show")
  }), d.default.fn.tab = ce._jQueryInterface, d.default.fn.tab.Constructor = ce, d.default.fn.tab.noConflict = function () {
    return d.default.fn.tab = le, ce._jQueryInterface
  };
  var he = d.default.fn.toast,
    ue = {
      animation: "boolean",
      autohide: "boolean",
      delay: "number"
    },
    pe = {
      animation: !0,
      autohide: !0,
      delay: 500
    },
    fe = ((yt = me.prototype).show = function () {
      var t, e = this,
        i = d.default.Event("show.bs.toast");
      d.default(this._element).trigger(i), i.isDefaultPrevented() || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), t = function () {
        e._element.classList.remove("showing"), e._element.classList.add("show"), d.default(e._element).trigger("shown.bs.toast"), e._config.autohide && (e._timeout = setTimeout(function () {
          e.hide()
        }, e._config.delay))
      }, this._element.classList.remove("hide"), h.reflow(this._element), this._element.classList.add("showing"), this._config.animation ? (i = h.getTransitionDurationFromElement(this._element), d.default(this._element).one(h.TRANSITION_END, t).emulateTransitionEnd(i)) : t())
    }, yt.hide = function () {
      var t;
      this._element.classList.contains("show") && (t = d.default.Event("hide.bs.toast"), d.default(this._element).trigger(t), t.isDefaultPrevented() || this._close())
    }, yt.dispose = function () {
      this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), d.default(this._element).off("click.dismiss.bs.toast"), d.default.removeData(this._element, "bs.toast"), this._element = null, this._config = null
    }, yt._getConfig = function (t) {
      return t = a({}, pe, d.default(this._element).data(), "object" == typeof t && t ? t : {}), h.typeCheckConfig("toast", t, this.constructor.DefaultType), t
    }, yt._setListeners = function () {
      var t = this;
      d.default(this._element).on("click.dismiss.bs.toast", '[data-dismiss="toast"]', function () {
        return t.hide()
      })
    }, yt._close = function () {
      function t() {
        i._element.classList.add("hide"), d.default(i._element).trigger("hidden.bs.toast")
      }
      var e, i = this;
      this._element.classList.remove("show"), this._config.animation ? (e = h.getTransitionDurationFromElement(this._element), d.default(this._element).one(h.TRANSITION_END, t).emulateTransitionEnd(e)) : t()
    }, yt._clearTimeout = function () {
      clearTimeout(this._timeout), this._timeout = null
    }, me._jQueryInterface = function (i) {
      return this.each(function () {
        var t = d.default(this),
          e = t.data("bs.toast");
        if (e || (e = new me(this, "object" == typeof i && i), t.data("bs.toast", e)), "string" == typeof i) {
          if (void 0 === e[i]) throw new TypeError('No method named "' + i + '"');
          e[i](this)
        }
      })
    }, n(me, null, [{
      key: "VERSION",
      get: function () {
        return "4.5.3"
      }
    }, {
      key: "DefaultType",
      get: function () {
        return ue
      }
    }, {
      key: "Default",
      get: function () {
        return pe
      }
    }]), me);

  function me(t, e) {
    this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners()
  }
  d.default.fn.toast = fe._jQueryInterface, d.default.fn.toast.Constructor = fe, d.default.fn.toast.noConflict = function () {
    return d.default.fn.toast = he, fe._jQueryInterface
  }, t.Alert = l, t.Button = p, t.Carousel = y, t.Collapse = D, t.Dropdown = Mt, t.Modal = Ot, t.Popover = ee, t.Scrollspy = oe, t.Tab = ce, t.Toast = fe, t.Tooltip = Ut, t.Util = h, Object.defineProperty(t, "__esModule", {
    value: !0
  })
}),
function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e()
}(this, function () {
  "use strict";
  const p = {
      find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
      findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
      children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),
      parents(t, e) {
        const i = [];
        let s = t.parentNode;
        for (; s && s.nodeType === Node.ELEMENT_NODE && 3 !== s.nodeType;) s.matches(e) && i.push(s), s = s.parentNode;
        return i
      },
      prev(t, e) {
        let i = t.previousElementSibling;
        for (; i;) {
          if (i.matches(e)) return [i];
          i = i.previousElementSibling
        }
        return []
      },
      next(t, e) {
        let i = t.nextElementSibling;
        for (; i;) {
          if (i.matches(e)) return [i];
          i = i.nextElementSibling
        }
        return []
      }
    },
    l = t => {
      for (; t += Math.floor(1e6 * Math.random()), document.getElementById(t););
      return t
    },
    e = e => {
      let i = e.getAttribute("data-bs-target");
      if (!i || "#" === i) {
        let t = e.getAttribute("href");
        if (!t || !t.includes("#") && !t.startsWith(".")) return null;
        t.includes("#") && !t.startsWith("#") && (t = "#" + t.split("#")[1]), i = t && "#" !== t ? t.trim() : null
      }
      return i
    },
    o = t => {
      t = e(t);
      return t && document.querySelector(t) ? t : null
    },
    n = t => {
      t = e(t);
      return t ? document.querySelector(t) : null
    },
    s = t => {
      if (!t) return 0;
      let {
        transitionDuration: e,
        transitionDelay: i
      } = window.getComputedStyle(t);
      var s = Number.parseFloat(e),
        t = Number.parseFloat(i);
      return s || t ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
    },
    a = t => {
      t.dispatchEvent(new Event("transitionend"))
    },
    r = t => !(!t || "object" != typeof t) && void 0 !== (t = void 0 !== t.jquery ? t[0] : t).nodeType,
    c = t => r(t) ? t.jquery ? t[0] : t : "string" == typeof t && 0 < t.length ? p.findOne(t) : null,
    d = (e, t) => {
      let i = !1;
      t += 5;
      e.addEventListener("transitionend", function t() {
        i = !0, e.removeEventListener("transitionend", t)
      }), setTimeout(() => {
        i || a(e)
      }, t)
    },
    i = (s, n, a) => {
      Object.keys(a).forEach(t => {
        var e = a[t],
          i = n[t],
          i = i && r(i) ? "element" : null == i ? "" + i : {}.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
        if (!new RegExp(e).test(i)) throw new TypeError(`${s.toUpperCase()}: Option "${t}" provided type "${i}" but expected type "${e}".`)
      })
    },
    h = t => {
      if (!t) return !1;
      if (t.style && t.parentNode && t.parentNode.style) {
        var e = getComputedStyle(t),
          t = getComputedStyle(t.parentNode);
        return "none" !== e.display && "none" !== t.display && "hidden" !== e.visibility
      }
      return !1
    },
    u = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
    f = t => {
      if (!document.documentElement.attachShadow) return null;
      if ("function" != typeof t.getRootNode) return t instanceof ShadowRoot ? t : t.parentNode ? f(t.parentNode) : null;
      t = t.getRootNode();
      return t instanceof ShadowRoot ? t : null
    },
    m = () => {},
    g = t => t.offsetHeight,
    v = () => {
      var {
        jQuery: t
      } = window;
      return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null
    },
    b = () => "rtl" === document.documentElement.dir,
    t = s => {
      var t = () => {
        const t = v();
        if (t) {
          const e = s.NAME,
            i = t.fn[e];
          t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface)
        }
      };
      "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", t) : t()
    },
    _ = t => {
      "function" == typeof t && t()
    },
    y = new Map;
  var w = function (t, e, i) {
      y.has(t) || y.set(t, new Map);
      const s = y.get(t);
      s.has(e) || 0 === s.size ? s.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`)
    },
    x = (t, e) => y.has(t) && y.get(t).get(e) || null,
    C = function (t, e) {
      if (y.has(t)) {
        const i = y.get(t);
        i.delete(e), 0 === i.size && y.delete(t)
      }
    };
  const k = /[^.]*(?=\..*)\.|.*/,
    T = /\..*/,
    D = /::\d+$/,
    S = {};
  let M = 1;
  const E = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    },
    A = /^(mouseenter|mouseleave)/i,
    P = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

  function I(t, e) {
    return e && `${e}::${M++}` || t.uidEvent || M++
  }

  function O(t) {
    var e = I(t);
    return t.uidEvent = e, S[e] = S[e] || {}, S[e]
  }

  function $(i, s, n = null) {
    var a = Object.keys(i);
    for (let t = 0, e = a.length; t < e; t++) {
      var o = i[a[t]];
      if (o.originalHandler === s && o.delegationSelector === n) return o
    }
    return null
  }

  function L(t, e, i) {
    var s = "string" == typeof e,
      e = s ? i : e;
    let n = F(t);
    return P.has(n) || (n = t), [s, e, n]
  }

  function N(t, e, i, s, n) {
    if ("string" == typeof e && t) {
      if (i || (i = s, s = null), A.test(e)) {
        const t = e => function (t) {
          if (!t.relatedTarget || t.relatedTarget !== t.delegateTarget && !t.delegateTarget.contains(t.relatedTarget)) return e.call(this, t)
        };
        s ? s = t(s) : i = t(i)
      }
      const [d, h, u] = L(e, i, s), p = O(t), f = p[u] || (p[u] = {}), m = $(f, h, d ? i : null);
      if (m) return m.oneOff = m.oneOff && n, 0;
      const g = I(h, e.replace(k, "")),
        v = d ? (r = t, l = i, c = s, function i(s) {
          var n = r.querySelectorAll(l);
          for (let {
              target: e
            } = s; e && e !== this; e = e.parentNode)
            for (let t = n.length; t--;)
              if (n[t] === e) return s.delegateTarget = e, i.oneOff && z.off(r, s.type, l, c), c.apply(e, [s]);
          return null
        }) : (a = t, o = i, function t(e) {
          return e.delegateTarget = a, t.oneOff && z.off(a, e.type, o), o.apply(a, [e])
        });
      var a, o, r, l, c;
      v.delegationSelector = d ? i : null, v.originalHandler = h, v.oneOff = n, v.uidEvent = g, f[g] = v, t.addEventListener(u, v, d)
    }
  }

  function H(t, e, i, s, n) {
    s = $(e[i], s, n);
    s && (t.removeEventListener(i, s, Boolean(n)), delete e[i][s.uidEvent])
  }

  function F(t) {
    return t = t.replace(T, ""), E[t] || t
  }
  const z = {
    on(t, e, i, s) {
      N(t, e, i, s, !1)
    },
    one(t, e, i, s) {
      N(t, e, i, s, !0)
    },
    off(i, s, t, e) {
      if ("string" == typeof s && i) {
        const [n, a, o] = L(s, t, e), r = o !== s, l = O(i), c = s.startsWith(".");
        if (void 0 !== a) return l && l[o] ? void H(i, l, o, a, n ? t : null) : void 0;
        c && Object.keys(l).forEach(t => {
          ! function (e, i, s, n) {
            const a = i[s] || {};
            Object.keys(a).forEach(t => {
              if (t.includes(n)) {
                const n = a[t];
                H(e, i, s, n.originalHandler, n.delegationSelector)
              }
            })
          }(i, l, t, s.slice(1))
        });
        const d = l[o] || {};
        Object.keys(d).forEach(t => {
          var e = t.replace(D, "");
          if (!r || s.includes(e)) {
            const s = d[t];
            H(i, l, o, s.originalHandler, s.delegationSelector)
          }
        })
      }
    },
    trigger(t, e, i) {
      if ("string" != typeof e || !t) return null;
      const s = v(),
        n = F(e),
        a = e !== n,
        o = P.has(n);
      let r, l = !0,
        c = !0,
        d = !1,
        h = null;
      return a && s && (r = s.Event(e, i), s(t).trigger(r), l = !r.isPropagationStopped(), c = !r.isImmediatePropagationStopped(), d = r.isDefaultPrevented()), o ? (h = document.createEvent("HTMLEvents"), h.initEvent(n, l, !0)) : h = new CustomEvent(e, {
        bubbles: l,
        cancelable: !0
      }), void 0 !== i && Object.keys(i).forEach(t => {
        Object.defineProperty(h, t, {
          get: () => i[t]
        })
      }), d && h.preventDefault(), c && t.dispatchEvent(h), h.defaultPrevented && void 0 !== r && r.preventDefault(), h
    }
  };
  class R {
    constructor(t) {
      (t = c(t)) && (this._element = t, w(this._element, this.constructor.DATA_KEY, this))
    }
    dispose() {
      C(this._element, this.constructor.DATA_KEY), z.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(t => {
        this[t] = null
      })
    }
    _queueCallback(t, e, i = !0) {
      i ? (i = s(e), z.one(e, "transitionend", () => _(t)), d(e, i)) : _(t)
    }
    static getInstance(t) {
      return x(t, this.DATA_KEY)
    }
    static get VERSION() {
      return "5.0.1"
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!')
    }
    static get DATA_KEY() {
      return "bs." + this.NAME
    }
    static get EVENT_KEY() {
      return "." + this.DATA_KEY
    }
  }
  class B extends R {
    static get NAME() {
      return "alert"
    }
    close(t) {
      var e = t ? this._getRootElement(t) : this._element,
        t = this._triggerCloseEvent(e);
      null === t || t.defaultPrevented || this._removeElement(e)
    }
    _getRootElement(t) {
      return n(t) || t.closest(".alert")
    }
    _triggerCloseEvent(t) {
      return z.trigger(t, "close.bs.alert")
    }
    _removeElement(t) {
      t.classList.remove("show");
      var e = t.classList.contains("fade");
      this._queueCallback(() => this._destroyElement(t), t, e)
    }
    _destroyElement(t) {
      t.parentNode && t.parentNode.removeChild(t), z.trigger(t, "closed.bs.alert")
    }
    static jQueryInterface(e) {
      return this.each(function () {
        let t = x(this, "bs.alert");
        t = t || new B(this), "close" === e && t[e](this)
      })
    }
    static handleDismiss(e) {
      return function (t) {
        t && t.preventDefault(), e.close(this)
      }
    }
  }
  z.on(document, "click.bs.alert.data-api", '[data-bs-dismiss="alert"]', B.handleDismiss(new B)), t(B);
  class j extends R {
    static get NAME() {
      return "button"
    }
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
    }
    static jQueryInterface(e) {
      return this.each(function () {
        let t = x(this, "bs.button");
        t = t || new j(this), "toggle" === e && t[e]()
      })
    }
  }

  function W(t) {
    return "true" === t || "false" !== t && (t === Number(t).toString() ? Number(t) : "" === t || "null" === t ? null : t)
  }

  function V(t) {
    return t.replace(/[A-Z]/g, t => "-" + t.toLowerCase())
  }
  z.on(document, "click.bs.button.data-api", '[data-bs-toggle="button"]', t => {
    t.preventDefault();
    t = t.target.closest('[data-bs-toggle="button"]');
    let e = x(t, "bs.button");
    e = e || new j(t), e.toggle()
  }), t(j);
  const q = {
      setDataAttribute(t, e, i) {
        t.setAttribute("data-bs-" + V(e), i)
      },
      removeDataAttribute(t, e) {
        t.removeAttribute("data-bs-" + V(e))
      },
      getDataAttributes(i) {
        if (!i) return {};
        const s = {};
        return Object.keys(i.dataset).filter(t => t.startsWith("bs")).forEach(t => {
          let e = t.replace(/^bs/, "");
          e = e.charAt(0).toLowerCase() + e.slice(1, e.length), s[e] = W(i.dataset[t])
        }), s
      },
      getDataAttribute: (t, e) => W(t.getAttribute("data-bs-" + V(e))),
      offset(t) {
        t = t.getBoundingClientRect();
        return {
          top: t.top + document.body.scrollTop,
          left: t.left + document.body.scrollLeft
        }
      },
      position: t => ({
        top: t.offsetTop,
        left: t.offsetLeft
      })
    },
    Y = {
      interval: 5e3,
      keyboard: !0,
      slide: !1,
      pause: "hover",
      wrap: !0,
      touch: !0
    },
    U = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      slide: "(boolean|string)",
      pause: "(string|boolean)",
      wrap: "boolean",
      touch: "boolean"
    },
    X = "next",
    G = "prev",
    K = "left",
    Q = "right";
  class J extends R {
    constructor(t, e) {
      super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._indicatorsElement = p.findOne(".carousel-indicators", this._element), this._touchSupported = "ontouchstart" in document.documentElement || 0 < navigator.maxTouchPoints, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners()
    }
    static get Default() {
      return Y
    }
    static get NAME() {
      return "carousel"
    }
    next() {
      this._isSliding || this._slide(X)
    }
    nextWhenVisible() {
      !document.hidden && h(this._element) && this.next()
    }
    prev() {
      this._isSliding || this._slide(G)
    }
    pause(t) {
      t || (this._isPaused = !0), p.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (a(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
    }
    cycle(t) {
      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
    }
    to(t) {
      this._activeElement = p.findOne(".active.carousel-item", this._element);
      var e = this._getItemIndex(this._activeElement);
      if (!(t > this._items.length - 1 || t < 0))
        if (this._isSliding) z.one(this._element, "slid.bs.carousel", () => this.to(t));
        else {
          if (e === t) return this.pause(), void this.cycle();
          e = e < t ? X : G;
          this._slide(e, this._items[t])
        }
    }
    _getConfig(t) {
      return t = {
        ...Y,
        ...t
      }, i("carousel", t, U), t
    }
    _handleSwipe() {
      var t = Math.abs(this.touchDeltaX);
      t <= 40 || (t = t / this.touchDeltaX, this.touchDeltaX = 0, t && this._slide(0 < t ? Q : K))
    }
    _addEventListeners() {
      this._config.keyboard && z.on(this._element, "keydown.bs.carousel", t => this._keydown(t)), "hover" === this._config.pause && (z.on(this._element, "mouseenter.bs.carousel", t => this.pause(t)), z.on(this._element, "mouseleave.bs.carousel", t => this.cycle(t))), this._config.touch && this._touchSupported && this._addTouchEventListeners()
    }
    _addTouchEventListeners() {
      const e = t => {
          !this._pointerEvent || "pen" !== t.pointerType && "touch" !== t.pointerType ? this._pointerEvent || (this.touchStartX = t.touches[0].clientX) : this.touchStartX = t.clientX
        },
        i = t => {
          this.touchDeltaX = t.touches && 1 < t.touches.length ? 0 : t.touches[0].clientX - this.touchStartX
        },
        s = t => {
          !this._pointerEvent || "pen" !== t.pointerType && "touch" !== t.pointerType || (this.touchDeltaX = t.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(t => this.cycle(t), 500 + this._config.interval))
        };
      p.find(".carousel-item img", this._element).forEach(t => {
        z.on(t, "dragstart.bs.carousel", t => t.preventDefault())
      }), this._pointerEvent ? (z.on(this._element, "pointerdown.bs.carousel", t => e(t)), z.on(this._element, "pointerup.bs.carousel", t => s(t)), this._element.classList.add("pointer-event")) : (z.on(this._element, "touchstart.bs.carousel", t => e(t)), z.on(this._element, "touchmove.bs.carousel", t => i(t)), z.on(this._element, "touchend.bs.carousel", t => s(t)))
    }
    _keydown(t) {
      /input|textarea/i.test(t.target.tagName) || ("ArrowLeft" === t.key ? (t.preventDefault(), this._slide(Q)) : "ArrowRight" === t.key && (t.preventDefault(), this._slide(K)))
    }
    _getItemIndex(t) {
      return this._items = t && t.parentNode ? p.find(".carousel-item", t.parentNode) : [], this._items.indexOf(t)
    }
    _getItemByOrder(t, e) {
      var i = t === X,
        s = t === G,
        n = this._getItemIndex(e),
        t = this._items.length - 1;
      if ((s && 0 === n || i && n === t) && !this._config.wrap) return e;
      s = (n + (s ? -1 : 1)) % this._items.length;
      return -1 == s ? this._items[this._items.length - 1] : this._items[s]
    }
    _triggerSlideEvent(t, e) {
      var i = this._getItemIndex(t),
        s = this._getItemIndex(p.findOne(".active.carousel-item", this._element));
      return z.trigger(this._element, "slide.bs.carousel", {
        relatedTarget: t,
        direction: e,
        from: s,
        to: i
      })
    }
    _setActiveIndicatorElement(e) {
      if (this._indicatorsElement) {
        const t = p.findOne(".active", this._indicatorsElement);
        t.classList.remove("active"), t.removeAttribute("aria-current");
        const i = p.find("[data-bs-target]", this._indicatorsElement);
        for (let t = 0; t < i.length; t++)
          if (Number.parseInt(i[t].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(e)) {
            i[t].classList.add("active"), i[t].setAttribute("aria-current", "true");
            break
          }
      }
    }
    _updateInterval() {
      const t = this._activeElement || p.findOne(".active.carousel-item", this._element);
      var e;
      t && ((e = Number.parseInt(t.getAttribute("data-bs-interval"), 10)) ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval)
    }
    _slide(t, e) {
      const i = this._directionToOrder(t),
        s = p.findOne(".active.carousel-item", this._element),
        n = this._getItemIndex(s),
        a = e || this._getItemByOrder(i, s),
        o = this._getItemIndex(a),
        r = Boolean(this._interval),
        l = i === X,
        c = l ? "carousel-item-start" : "carousel-item-end",
        d = l ? "carousel-item-next" : "carousel-item-prev",
        h = this._orderToDirection(i);
      if (a && a.classList.contains("active")) this._isSliding = !1;
      else if (!this._triggerSlideEvent(a, h).defaultPrevented && s && a) {
        this._isSliding = !0, r && this.pause(), this._setActiveIndicatorElement(a), this._activeElement = a;
        const u = () => {
          z.trigger(this._element, "slid.bs.carousel", {
            relatedTarget: a,
            direction: h,
            from: n,
            to: o
          })
        };
        if (this._element.classList.contains("slide")) {
          a.classList.add(d), g(a), s.classList.add(c), a.classList.add(c);
          const p = () => {
            a.classList.remove(c, d), a.classList.add("active"), s.classList.remove("active", d, c), this._isSliding = !1, setTimeout(u, 0)
          };
          this._queueCallback(p, s, !0)
        } else s.classList.remove("active"), a.classList.add("active"), this._isSliding = !1, u();
        r && this.cycle()
      }
    }
    _directionToOrder(t) {
      return [Q, K].includes(t) ? b() ? t === K ? G : X : t === K ? X : G : t
    }
    _orderToDirection(t) {
      return [X, G].includes(t) ? b() ? t === G ? K : Q : t === G ? Q : K : t
    }
    static carouselInterface(t, e) {
      let i = x(t, "bs.carousel"),
        s = {
          ...Y,
          ...q.getDataAttributes(t)
        };
      "object" == typeof e && (s = {
        ...s,
        ...e
      });
      var n = "string" == typeof e ? e : s.slide;
      if (i = i || new J(t, s), "number" == typeof e) i.to(e);
      else if ("string" == typeof n) {
        if (void 0 === i[n]) throw new TypeError(`No method named "${n}"`);
        i[n]()
      } else s.interval && s.ride && (i.pause(), i.cycle())
    }
    static jQueryInterface(t) {
      return this.each(function () {
        J.carouselInterface(this, t)
      })
    }
    static dataApiClickHandler(t) {
      const e = n(this);
      if (e && e.classList.contains("carousel")) {
        const i = {
            ...q.getDataAttributes(e),
            ...q.getDataAttributes(this)
          },
          s = this.getAttribute("data-bs-slide-to");
        s && (i.interval = !1), J.carouselInterface(e, i), s && x(e, "bs.carousel").to(s), t.preventDefault()
      }
    }
  }
  z.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", J.dataApiClickHandler), z.on(window, "load.bs.carousel.data-api", () => {
    var i = p.find('[data-bs-ride="carousel"]');
    for (let t = 0, e = i.length; t < e; t++) J.carouselInterface(i[t], x(i[t], "bs.carousel"))
  }), t(J);
  const Z = {
      toggle: !0,
      parent: ""
    },
    tt = {
      toggle: "boolean",
      parent: "(string|element)"
    };
  class et extends R {
    constructor(t, i) {
      super(t), this._isTransitioning = !1, this._config = this._getConfig(i), this._triggerArray = p.find(`[data-bs-toggle="collapse"][href="#${this._element.id}"],[data-bs-toggle="collapse"][data-bs-target="#${this._element.id}"]`);
      var s = p.find('[data-bs-toggle="collapse"]');
      for (let t = 0, e = s.length; t < e; t++) {
        const i = s[t],
          n = o(i),
          a = p.find(n).filter(t => t === this._element);
        null !== n && a.length && (this._selector = n, this._triggerArray.push(i))
      }
      this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle()
    }
    static get Default() {
      return Z
    }
    static get NAME() {
      return "collapse"
    }
    toggle() {
      this._element.classList.contains("show") ? this.hide() : this.show()
    }
    show() {
      if (!this._isTransitioning && !this._element.classList.contains("show")) {
        let t, e;
        this._parent && (t = p.find(".show, .collapsing", this._parent).filter(t => "string" == typeof this._config.parent ? t.getAttribute("data-bs-parent") === this._config.parent : t.classList.contains("collapse")), 0 === t.length && (t = null));
        const s = p.findOne(this._selector);
        if (t) {
          const p = t.find(t => s !== t);
          if (e = p ? x(p, "bs.collapse") : null, e && e._isTransitioning) return
        }
        if (!z.trigger(this._element, "show.bs.collapse").defaultPrevented) {
          t && t.forEach(t => {
            s !== t && et.collapseInterface(t, "hide"), e || w(t, "bs.collapse", null)
          });
          const n = this._getDimension();
          this._element.classList.remove("collapse"), this._element.classList.add("collapsing"), this._element.style[n] = 0, this._triggerArray.length && this._triggerArray.forEach(t => {
            t.classList.remove("collapsed"), t.setAttribute("aria-expanded", !0)
          }), this.setTransitioning(!0);
          var i = "scroll" + (n[0].toUpperCase() + n.slice(1));
          this._queueCallback(() => {
            this._element.classList.remove("collapsing"), this._element.classList.add("collapse", "show"), this._element.style[n] = "", this.setTransitioning(!1), z.trigger(this._element, "shown.bs.collapse")
          }, this._element, !0), this._element.style[n] = this._element[i] + "px"
        }
      }
    }
    hide() {
      if (!this._isTransitioning && this._element.classList.contains("show") && !z.trigger(this._element, "hide.bs.collapse").defaultPrevented) {
        var t = this._getDimension();
        this._element.style[t] = this._element.getBoundingClientRect()[t] + "px", g(this._element), this._element.classList.add("collapsing"), this._element.classList.remove("collapse", "show");
        const e = this._triggerArray.length;
        if (0 < e)
          for (let t = 0; t < e; t++) {
            const e = this._triggerArray[t],
              i = n(e);
            i && !i.classList.contains("show") && (e.classList.add("collapsed"), e.setAttribute("aria-expanded", !1))
          }
        this.setTransitioning(!0), this._element.style[t] = "", this._queueCallback(() => {
          this.setTransitioning(!1), this._element.classList.remove("collapsing"), this._element.classList.add("collapse"), z.trigger(this._element, "hidden.bs.collapse")
        }, this._element, !0)
      }
    }
    setTransitioning(t) {
      this._isTransitioning = t
    }
    _getConfig(t) {
      return (t = {
        ...Z,
        ...t
      }).toggle = Boolean(t.toggle), i("collapse", t, tt), t
    }
    _getDimension() {
      return this._element.classList.contains("width") ? "width" : "height"
    }
    _getParent() {
      var {
        parent: t
      } = this._config, e = `[data-bs-toggle="collapse"][data-bs-parent="${t=c(t)}"]`;
      return p.find(e, t).forEach(t => {
        var e = n(t);
        this._addAriaAndCollapsedClass(e, [t])
      }), t
    }
    _addAriaAndCollapsedClass(t, e) {
      if (t && e.length) {
        const i = t.classList.contains("show");
        e.forEach(t => {
          i ? t.classList.remove("collapsed") : t.classList.add("collapsed"), t.setAttribute("aria-expanded", i)
        })
      }
    }
    static collapseInterface(t, e) {
      let i = x(t, "bs.collapse");
      const s = {
        ...Z,
        ...q.getDataAttributes(t),
        ..."object" == typeof e && e ? e : {}
      };
      if (!i && s.toggle && "string" == typeof e && /show|hide/.test(e) && (s.toggle = !1), i = i || new et(t, s), "string" == typeof e) {
        if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`);
        i[e]()
      }
    }
    static jQueryInterface(t) {
      return this.each(function () {
        et.collapseInterface(this, t)
      })
    }
  }
  z.on(document, "click.bs.collapse.data-api", '[data-bs-toggle="collapse"]', function (t) {
    ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
    const s = q.getDataAttributes(this),
      e = o(this);
    p.find(e).forEach(t => {
      const e = x(t, "bs.collapse");
      let i;
      i = e ? (null === e._parent && "string" == typeof s.parent && (e._config.parent = s.parent, e._parent = e._getParent()), "toggle") : s, et.collapseInterface(t, i)
    })
  }), t(et);
  var it = "top",
    st = "bottom",
    nt = "right",
    at = "left",
    ot = [it, st, nt, at],
    rt = ot.reduce(function (t, e) {
      return t.concat([e + "-start", e + "-end"])
    }, []),
    lt = [].concat(ot, ["auto"]).reduce(function (t, e) {
      return t.concat([e, e + "-start", e + "-end"])
    }, []),
    ct = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"];

  function dt(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
  }

  function ht(t) {
    if (null == t) return window;
    if ("[object Window]" === t.toString()) return t;
    t = t.ownerDocument;
    return t && t.defaultView || window
  }

  function ut(t) {
    return t instanceof ht(t).Element || t instanceof Element
  }

  function pt(t) {
    return t instanceof ht(t).HTMLElement || t instanceof HTMLElement
  }

  function ft(t) {
    return "undefined" != typeof ShadowRoot && (t instanceof ht(t).ShadowRoot || t instanceof ShadowRoot)
  }
  var mt = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (t) {
      var n = t.state;
      Object.keys(n.elements).forEach(function (t) {
        var e = n.styles[t] || {},
          i = n.attributes[t] || {},
          s = n.elements[t];
        pt(s) && dt(s) && (Object.assign(s.style, e), Object.keys(i).forEach(function (t) {
          var e = i[t];
          !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e)
        }))
      })
    },
    effect: function (t) {
      var s = t.state,
        n = {
          popper: {
            position: s.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
      return Object.assign(s.elements.popper.style, n.popper), s.styles = n, s.elements.arrow && Object.assign(s.elements.arrow.style, n.arrow),
        function () {
          Object.keys(s.elements).forEach(function (t) {
            var e = s.elements[t],
              i = s.attributes[t] || {},
              t = Object.keys((s.styles.hasOwnProperty(t) ? s.styles : n)[t]).reduce(function (t, e) {
                return t[e] = "", t
              }, {});
            pt(e) && dt(e) && (Object.assign(e.style, t), Object.keys(i).forEach(function (t) {
              e.removeAttribute(t)
            }))
          })
        }
    },
    requires: ["computeStyles"]
  };

  function gt(t) {
    return t.split("-")[0]
  }

  function vt(t) {
    t = t.getBoundingClientRect();
    return {
      width: t.width,
      height: t.height,
      top: t.top,
      right: t.right,
      bottom: t.bottom,
      left: t.left,
      x: t.left,
      y: t.top
    }
  }

  function bt(t) {
    var e = vt(t),
      i = t.offsetWidth,
      s = t.offsetHeight;
    return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - s) <= 1 && (s = e.height), {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: i,
      height: s
    }
  }

  function _t(t, e) {
    var i = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (i && ft(i)) {
      var s = e;
      do {
        if (s && t.isSameNode(s)) return !0
      } while (s = s.parentNode || s.host)
    }
    return !1
  }

  function yt(t) {
    return ht(t).getComputedStyle(t)
  }

  function wt(t) {
    return ((ut(t) ? t.ownerDocument : t.document) || window.document).documentElement
  }

  function xt(t) {
    return "html" === dt(t) ? t : t.assignedSlot || t.parentNode || (ft(t) ? t.host : null) || wt(t)
  }

  function Ct(t) {
    return pt(t) && "fixed" !== yt(t).position ? t.offsetParent : null
  }

  function kt(t) {
    for (var e, i = ht(t), s = Ct(t); s && (e = s, 0 <= ["table", "td", "th"].indexOf(dt(e))) && "static" === yt(s).position;) s = Ct(s);
    return (!s || "html" !== dt(s) && ("body" !== dt(s) || "static" !== yt(s).position)) && (s || function (t) {
      var e = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
      if (-1 !== navigator.userAgent.indexOf("Trident") && pt(t) && "fixed" === yt(t).position) return null;
      for (var i = xt(t); pt(i) && ["html", "body"].indexOf(dt(i)) < 0;) {
        var s = yt(i);
        if ("none" !== s.transform || "none" !== s.perspective || "paint" === s.contain || -1 !== ["transform", "perspective"].indexOf(s.willChange) || e && "filter" === s.willChange || e && s.filter && "none" !== s.filter) return i;
        i = i.parentNode
      }
      return null
    }(t)) || i
  }

  function Tt(t) {
    return 0 <= ["top", "bottom"].indexOf(t) ? "x" : "y"
  }
  var Dt = Math.max,
    St = Math.min,
    Mt = Math.round;

  function Et(t, e, i) {
    return Dt(t, St(e, i))
  }

  function At(t) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, t)
  }

  function Pt(i, t) {
    return t.reduce(function (t, e) {
      return t[e] = i, t
    }, {})
  }
  var It = {
      name: "arrow",
      enabled: !0,
      phase: "main",
      fn: function (t) {
        var e, i, s = t.state,
          n = t.name,
          a = t.options,
          o = s.elements.arrow,
          r = s.modifiersData.popperOffsets,
          l = gt(s.placement),
          c = Tt(l),
          d = 0 <= [at, nt].indexOf(l) ? "height" : "width";
        o && r && (e = At("number" != typeof (i = "function" == typeof (i = a.padding) ? i(Object.assign({}, s.rects, {
          placement: s.placement
        })) : i) ? i : Pt(i, ot)), t = bt(o), l = "y" === c ? it : at, a = "y" === c ? st : nt, i = s.rects.reference[d] + s.rects.reference[c] - r[c] - s.rects.popper[d], r = r[c] - s.rects.reference[c], o = (o = kt(o)) ? "y" === c ? o.clientHeight || 0 : o.clientWidth || 0 : 0, l = e[l], a = o - t[d] - e[a], a = Et(l, r = o / 2 - t[d] / 2 + (i / 2 - r / 2), a), s.modifiersData[n] = ((n = {})[c] = a, n.centerOffset = a - r, n))
      },
      effect: function (t) {
        var e = t.state,
          t = t.options.element,
          t = void 0 === t ? "[data-popper-arrow]" : t;
        null != t && ("string" != typeof t || (t = e.elements.popper.querySelector(t))) && _t(e.elements.popper, t) && (e.elements.arrow = t)
      },
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    },
    Ot = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };

  function $t(t) {
    var e, i, s, n = t.popper,
      a = t.popperRect,
      o = t.placement,
      r = t.offsets,
      l = t.position,
      c = t.gpuAcceleration,
      d = t.adaptive,
      h = t.roundOffsets,
      u = !0 === h ? (e = r.x, i = r.y, s = window.devicePixelRatio || 1, {
        x: Mt(Mt(e * s) / s) || 0,
        y: Mt(Mt(i * s) / s) || 0
      }) : "function" == typeof h ? h(r) : r,
      p = u.x,
      f = void 0 === p ? 0 : p,
      m = u.y,
      t = void 0 === m ? 0 : m,
      e = r.hasOwnProperty("x"),
      i = r.hasOwnProperty("y"),
      s = at,
      h = it,
      p = window;
    d && (u = "clientHeight", m = "clientWidth", (r = kt(n)) === ht(n) && "static" !== yt(r = wt(n)).position && (u = "scrollHeight", m = "scrollWidth"), o === it && (h = st, t -= r[u] - a.height, t *= c ? 1 : -1), o === at && (s = nt, f -= r[m] - a.width, f *= c ? 1 : -1));
    var d = Object.assign({
      position: l
    }, d && Ot);
    return c ? Object.assign({}, d, ((c = {})[h] = i ? "0" : "", c[s] = e ? "0" : "", c.transform = (p.devicePixelRatio || 1) < 2 ? "translate(" + f + "px, " + t + "px)" : "translate3d(" + f + "px, " + t + "px, 0)", c)) : Object.assign({}, d, ((d = {})[h] = i ? t + "px" : "", d[s] = e ? f + "px" : "", d.transform = "", d))
  }
  var Lt = {
      name: "computeStyles",
      enabled: !0,
      phase: "beforeWrite",
      fn: function (t) {
        var e = t.state,
          i = t.options,
          s = i.gpuAcceleration,
          t = void 0 === s || s,
          s = i.adaptive,
          s = void 0 === s || s,
          i = i.roundOffsets,
          i = void 0 === i || i,
          t = {
            placement: gt(e.placement),
            popper: e.elements.popper,
            popperRect: e.rects.popper,
            gpuAcceleration: t
          };
        null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, $t(Object.assign({}, t, {
          offsets: e.modifiersData.popperOffsets,
          position: e.options.strategy,
          adaptive: s,
          roundOffsets: i
        })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, $t(Object.assign({}, t, {
          offsets: e.modifiersData.arrow,
          position: "absolute",
          adaptive: !1,
          roundOffsets: i
        })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
          "data-popper-placement": e.placement
        })
      },
      data: {}
    },
    Nt = {
      passive: !0
    },
    Ht = {
      name: "eventListeners",
      enabled: !0,
      phase: "write",
      fn: function () {},
      effect: function (t) {
        var e = t.state,
          i = t.instance,
          s = t.options,
          t = s.scroll,
          n = void 0 === t || t,
          s = s.resize,
          a = void 0 === s || s,
          o = ht(e.elements.popper),
          r = [].concat(e.scrollParents.reference, e.scrollParents.popper);
        return n && r.forEach(function (t) {
            t.addEventListener("scroll", i.update, Nt)
          }), a && o.addEventListener("resize", i.update, Nt),
          function () {
            n && r.forEach(function (t) {
              t.removeEventListener("scroll", i.update, Nt)
            }), a && o.removeEventListener("resize", i.update, Nt)
          }
      },
      data: {}
    },
    Ft = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };

  function zt(t) {
    return t.replace(/left|right|bottom|top/g, function (t) {
      return Ft[t]
    })
  }
  var Rt = {
    start: "end",
    end: "start"
  };

  function Bt(t) {
    return t.replace(/start|end/g, function (t) {
      return Rt[t]
    })
  }

  function jt(t) {
    t = ht(t);
    return {
      scrollLeft: t.pageXOffset,
      scrollTop: t.pageYOffset
    }
  }

  function Wt(t) {
    return vt(wt(t)).left + jt(t).scrollLeft
  }

  function Vt(t) {
    var e = yt(t),
      i = e.overflow,
      t = e.overflowX,
      e = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + e + t)
  }

  function qt(t, e) {
    void 0 === e && (e = []);
    var i = function t(e) {
        return 0 <= ["html", "body", "#document"].indexOf(dt(e)) ? e.ownerDocument.body : pt(e) && Vt(e) ? e : t(xt(e))
      }(t),
      t = i === (null == (s = t.ownerDocument) ? void 0 : s.body),
      s = ht(i),
      i = t ? [s].concat(s.visualViewport || [], Vt(i) ? i : []) : i,
      e = e.concat(i);
    return t ? e : e.concat(qt(xt(i)))
  }

  function Yt(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height
    })
  }

  function Ut(t, e) {
    return "viewport" === e ? Yt((a = ht(n = t), o = wt(n), r = a.visualViewport, l = o.clientWidth, c = o.clientHeight, o = a = 0, r && (l = r.width, c = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, o = r.offsetTop)), {
      width: l,
      height: c,
      x: a + Wt(n),
      y: o
    })) : pt(e) ? ((s = vt(i = e)).top = s.top + i.clientTop, s.left = s.left + i.clientLeft, s.bottom = s.top + i.clientHeight, s.right = s.left + i.clientWidth, s.width = i.clientWidth, s.height = i.clientHeight, s.x = s.left, s.y = s.top, s) : Yt((n = wt(t), o = wt(n), e = jt(n), s = null == (i = n.ownerDocument) ? void 0 : i.body, t = Dt(o.scrollWidth, o.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0), i = Dt(o.scrollHeight, o.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0), n = -e.scrollLeft + Wt(n), e = -e.scrollTop, "rtl" === yt(s || o).direction && (n += Dt(o.clientWidth, s ? s.clientWidth : 0) - t), {
      width: t,
      height: i,
      x: n,
      y: e
    }));
    var i, s, n, a, o, r, l, c
  }

  function Xt(t) {
    return t.split("-")[1]
  }

  function Gt(t) {
    var e, i = t.reference,
      s = t.element,
      n = t.placement,
      t = n ? gt(n) : null,
      n = n ? Xt(n) : null,
      a = i.x + i.width / 2 - s.width / 2,
      o = i.y + i.height / 2 - s.height / 2;
    switch (t) {
      case it:
        e = {
          x: a,
          y: i.y - s.height
        };
        break;
      case st:
        e = {
          x: a,
          y: i.y + i.height
        };
        break;
      case nt:
        e = {
          x: i.x + i.width,
          y: o
        };
        break;
      case at:
        e = {
          x: i.x - s.width,
          y: o
        };
        break;
      default:
        e = {
          x: i.x,
          y: i.y
        }
    }
    var r = t ? Tt(t) : null;
    if (null != r) {
      var l = "y" === r ? "height" : "width";
      switch (n) {
        case "start":
          e[r] = e[r] - (i[l] / 2 - s[l] / 2);
          break;
        case "end":
          e[r] = e[r] + (i[l] / 2 - s[l] / 2)
      }
    }
    return e
  }

  function Kt(t, e) {
    var i, s, n, a = e = void 0 === e ? {} : e,
      o = a.placement,
      r = void 0 === o ? t.placement : o,
      l = a.boundary,
      c = void 0 === l ? "clippingParents" : l,
      d = a.rootBoundary,
      h = void 0 === d ? "viewport" : d,
      u = a.elementContext,
      e = void 0 === u ? "popper" : u,
      o = a.altBoundary,
      l = void 0 !== o && o,
      d = a.padding,
      u = void 0 === d ? 0 : d,
      o = At("number" != typeof u ? u : Pt(u, ot)),
      a = t.elements.reference,
      d = t.rects.popper,
      u = t.elements[l ? "popper" === e ? "reference" : "popper" : e],
      u = (i = ut(u) ? u : u.contextElement || wt(t.elements.popper), l = h, u = "clippingParents" === (u = c) ? (c = qt(xt(h = i)), ut(s = 0 <= ["absolute", "fixed"].indexOf(yt(h).position) && pt(h) ? kt(h) : h) ? c.filter(function (t) {
        return ut(t) && _t(t, s) && "body" !== dt(t)
      }) : []) : [].concat(u), u = [].concat(u, [l]), l = u[0], (l = u.reduce(function (t, e) {
        e = Ut(i, e);
        return t.top = Dt(e.top, t.top), t.right = St(e.right, t.right), t.bottom = St(e.bottom, t.bottom), t.left = Dt(e.left, t.left), t
      }, Ut(i, l))).width = l.right - l.left, l.height = l.bottom - l.top, l.x = l.left, l.y = l.top, l),
      l = vt(a),
      a = Gt({
        reference: l,
        element: d,
        strategy: "absolute",
        placement: r
      }),
      a = Yt(Object.assign({}, d, a)),
      l = "popper" === e ? a : l,
      p = {
        top: u.top - l.top + o.top,
        bottom: l.bottom - u.bottom + o.bottom,
        left: u.left - l.left + o.left,
        right: l.right - u.right + o.right
      },
      t = t.modifiersData.offset;
    return "popper" === e && t && (n = t[r], Object.keys(p).forEach(function (t) {
      var e = 0 <= [nt, st].indexOf(t) ? 1 : -1,
        i = 0 <= [it, st].indexOf(t) ? "y" : "x";
      p[t] += n[i] * e
    })), p
  }
  var Qt = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var h = t.state,
        e = t.options,
        i = t.name;
      if (!h.modifiersData[i]._skip) {
        for (var s = e.mainAxis, n = void 0 === s || s, t = e.altAxis, a = void 0 === t || t, s = e.fallbackPlacements, u = e.padding, p = e.boundary, f = e.rootBoundary, o = e.altBoundary, t = e.flipVariations, m = void 0 === t || t, g = e.allowedAutoPlacements, t = h.options.placement, e = gt(t), e = s || (e !== t && m ? function (t) {
            if ("auto" === gt(t)) return [];
            var e = zt(t);
            return [Bt(t), e, Bt(e)]
          }(t) : [zt(t)]), r = [t].concat(e).reduce(function (t, e) {
            return t.concat("auto" === gt(e) ? (i = h, n = s = void 0 === (s = {
              placement: e,
              boundary: p,
              rootBoundary: f,
              padding: u,
              flipVariations: m,
              allowedAutoPlacements: g
            }) ? {} : s, t = n.placement, a = n.boundary, o = n.rootBoundary, r = n.padding, s = n.flipVariations, l = void 0 === (n = n.allowedAutoPlacements) ? lt : n, c = Xt(t), t = c ? s ? rt : rt.filter(function (t) {
              return Xt(t) === c
            }) : ot, d = (s = 0 === (s = t.filter(function (t) {
              return 0 <= l.indexOf(t)
            })).length ? t : s).reduce(function (t, e) {
              return t[e] = Kt(i, {
                placement: e,
                boundary: a,
                rootBoundary: o,
                padding: r
              })[gt(e)], t
            }, {}), Object.keys(d).sort(function (t, e) {
              return d[t] - d[e]
            })) : e);
            var i, s, n, a, o, r, l, c, d
          }, []), l = h.rects.reference, c = h.rects.popper, d = new Map, v = !0, b = r[0], _ = 0; _ < r.length; _++) {
          var y = r[_],
            w = gt(y),
            x = "start" === Xt(y),
            C = 0 <= [it, st].indexOf(w),
            k = C ? "width" : "height",
            T = Kt(h, {
              placement: y,
              boundary: p,
              rootBoundary: f,
              altBoundary: o,
              padding: u
            }),
            C = C ? x ? nt : at : x ? st : it;
          l[k] > c[k] && (C = zt(C));
          x = zt(C), k = [];
          if (n && k.push(T[w] <= 0), a && k.push(T[C] <= 0, T[x] <= 0), k.every(function (t) {
              return t
            })) {
            b = y, v = !1;
            break
          }
          d.set(y, k)
        }
        if (v)
          for (var D = m ? 3 : 1; 0 < D && "break" !== function (e) {
              var t = r.find(function (t) {
                t = d.get(t);
                if (t) return t.slice(0, e).every(function (t) {
                  return t
                })
              });
              if (t) return b = t, "break"
            }(D); D--);
        h.placement !== b && (h.modifiersData[i]._skip = !0, h.placement = b, h.reset = !0)
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };

  function Jt(t, e, i) {
    return {
      top: t.top - e.height - (i = void 0 === i ? {
        x: 0,
        y: 0
      } : i).y,
      right: t.right - e.width + i.x,
      bottom: t.bottom - e.height + i.y,
      left: t.left - e.width - i.x
    }
  }

  function Zt(e) {
    return [it, nt, st, at].some(function (t) {
      return 0 <= e[t]
    })
  }
  var te = {
      name: "hide",
      enabled: !0,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: function (t) {
        var e = t.state,
          i = t.name,
          s = e.rects.reference,
          n = e.rects.popper,
          a = e.modifiersData.preventOverflow,
          o = Kt(e, {
            elementContext: "reference"
          }),
          t = Kt(e, {
            altBoundary: !0
          }),
          s = Jt(o, s),
          t = Jt(t, n, a),
          n = Zt(s),
          a = Zt(t);
        e.modifiersData[i] = {
          referenceClippingOffsets: s,
          popperEscapeOffsets: t,
          isReferenceHidden: n,
          hasPopperEscaped: a
        }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
          "data-popper-reference-hidden": n,
          "data-popper-escaped": a
        })
      }
    },
    ee = {
      name: "offset",
      enabled: !0,
      phase: "main",
      requires: ["popperOffsets"],
      fn: function (t) {
        var o = t.state,
          e = t.options,
          i = t.name,
          s = e.offset,
          r = void 0 === s ? [0, 0] : s,
          t = lt.reduce(function (t, e) {
            return t[e] = (i = e, s = o.rects, n = r, a = gt(i), e = 0 <= [at, it].indexOf(a) ? -1 : 1, n = (n = (i = "function" == typeof n ? n(Object.assign({}, s, {
              placement: i
            })) : n)[0]) || 0, i = ((i = i[1]) || 0) * e, 0 <= [at, nt].indexOf(a) ? {
              x: i,
              y: n
            } : {
              x: n,
              y: i
            }), t;
            var i, s, n, a
          }, {}),
          e = t[o.placement],
          s = e.x,
          e = e.y;
        null != o.modifiersData.popperOffsets && (o.modifiersData.popperOffsets.x += s, o.modifiersData.popperOffsets.y += e), o.modifiersData[i] = t
      }
    },
    ie = {
      name: "popperOffsets",
      enabled: !0,
      phase: "read",
      fn: function (t) {
        var e = t.state,
          t = t.name;
        e.modifiersData[t] = Gt({
          reference: e.rects.reference,
          element: e.rects.popper,
          strategy: "absolute",
          placement: e.placement
        })
      },
      data: {}
    },
    se = {
      name: "preventOverflow",
      enabled: !0,
      phase: "main",
      fn: function (t) {
        var e = t.state,
          i = t.options,
          s = t.name,
          n = i.mainAxis,
          a = void 0 === n || n,
          o = i.altAxis,
          r = void 0 !== o && o,
          l = i.boundary,
          c = i.rootBoundary,
          d = i.altBoundary,
          h = i.padding,
          u = i.tether,
          p = void 0 === u || u,
          f = i.tetherOffset,
          m = void 0 === f ? 0 : f,
          g = Kt(e, {
            boundary: l,
            rootBoundary: c,
            padding: h,
            altBoundary: d
          }),
          v = gt(e.placement),
          b = Xt(e.placement),
          _ = !b,
          y = Tt(v),
          w = "x" === y ? "y" : "x",
          x = e.modifiersData.popperOffsets,
          C = e.rects.reference,
          t = e.rects.popper,
          n = "function" == typeof m ? m(Object.assign({}, e.rects, {
            placement: e.placement
          })) : m,
          o = {
            x: 0,
            y: 0
          };
        x && ((a || r) && (u = "y" === y ? "height" : "width", i = x[y], l = x[y] + g[f = "y" === y ? it : at], h = x[y] - g[c = "y" === y ? st : nt], d = p ? -t[u] / 2 : 0, v = ("start" === b ? C : t)[u], m = "start" === b ? -t[u] : -C[u], b = e.elements.arrow, t = p && b ? bt(b) : {
          width: 0,
          height: 0
        }, f = (b = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        })[f], c = b[c], t = Et(0, C[u], t[u]), f = _ ? C[u] / 2 - d - t - f - n : v - t - f - n, t = _ ? -C[u] / 2 + d + t + c + n : m + t + c + n, n = (c = e.elements.arrow && kt(e.elements.arrow)) ? "y" === y ? c.clientTop || 0 : c.clientLeft || 0 : 0, c = e.modifiersData.offset ? e.modifiersData.offset[e.placement][y] : 0, n = x[y] + f - c - n, c = x[y] + t - c, a && (h = Et(p ? St(l, n) : l, i, p ? Dt(h, c) : h), x[y] = h, o[y] = h - i), r && (r = (i = x[w]) + g["x" === y ? it : at], y = i - g["x" === y ? st : nt], y = Et(p ? St(r, n) : r, i, p ? Dt(y, c) : y), x[w] = y, o[w] = y - i)), e.modifiersData[s] = o)
      },
      requiresIfExists: ["offset"]
    };
  var ne = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };

  function ae() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
    return !e.some(function (t) {
      return !(t && "function" == typeof t.getBoundingClientRect)
    })
  }

  function oe(t) {
    var e = t = void 0 === t ? {} : t,
      t = e.defaultModifiers,
      p = void 0 === t ? [] : t,
      e = e.defaultOptions,
      f = void 0 === e ? ne : e;
    return function (o, r, e) {
      void 0 === e && (e = f);
      var i, s, l = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, ne, f),
          modifiersData: {},
          elements: {
            reference: o,
            popper: r
          },
          attributes: {},
          styles: {}
        },
        c = [],
        d = !1,
        h = {
          state: l,
          setOptions: function (t) {
            u(), l.options = Object.assign({}, f, l.options, t), l.scrollParents = {
              reference: ut(o) ? qt(o) : o.contextElement ? qt(o.contextElement) : [],
              popper: qt(r)
            };
            var e, i, s, n, a, t = (t = [].concat(p, l.options.modifiers), e = t.reduce(function (t, e) {
              var i = t[e.name];
              return t[e.name] = i ? Object.assign({}, i, e, {
                options: Object.assign({}, i.options, e.options),
                data: Object.assign({}, i.data, e.data)
              }) : e, t
            }, {}), t = t = Object.keys(e).map(function (t) {
              return e[t]
            }), i = new Map, s = new Set, n = [], t.forEach(function (t) {
              i.set(t.name, t)
            }), t.forEach(function (t) {
              s.has(t.name) || function e(t) {
                s.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function (t) {
                  s.has(t) || (t = i.get(t)) && e(t)
                }), n.push(t)
              }(t)
            }), a = n, ct.reduce(function (t, e) {
              return t.concat(a.filter(function (t) {
                return t.phase === e
              }))
            }, []));
            return l.orderedModifiers = t.filter(function (t) {
              return t.enabled
            }), l.orderedModifiers.forEach(function (t) {
              var e = t.name,
                i = t.options,
                t = t.effect;
              "function" == typeof t && (i = t({
                state: l,
                name: e,
                instance: h,
                options: void 0 === i ? {} : i
              }), c.push(i || function () {}))
            }), h.update()
          },
          forceUpdate: function () {
            if (!d) {
              var t = l.elements,
                e = t.reference,
                t = t.popper;
              if (ae(e, t)) {
                l.rects = {
                  reference: function (t, e, i) {
                    void 0 === i && (i = !1);
                    var s = wt(e),
                      n = vt(t),
                      a = pt(e),
                      o = {
                        scrollLeft: 0,
                        scrollTop: 0
                      },
                      t = {
                        x: 0,
                        y: 0
                      };
                    return !a && (a || i) || ("body" === dt(e) && !Vt(s) || (o = (i = e) !== ht(i) && pt(i) ? {
                      scrollLeft: i.scrollLeft,
                      scrollTop: i.scrollTop
                    } : jt(i)), pt(e) ? ((t = vt(e)).x += e.clientLeft, t.y += e.clientTop) : s && (t.x = Wt(s))), {
                      x: n.left + o.scrollLeft - t.x,
                      y: n.top + o.scrollTop - t.y,
                      width: n.width,
                      height: n.height
                    }
                  }(e, kt(t), "fixed" === l.options.strategy),
                  popper: bt(t)
                }, l.reset = !1, l.placement = l.options.placement, l.orderedModifiers.forEach(function (t) {
                  return l.modifiersData[t.name] = Object.assign({}, t.data)
                });
                for (var i, s, n, a = 0; a < l.orderedModifiers.length; a++) !0 !== l.reset ? (i = (n = l.orderedModifiers[a]).fn, s = n.options, n = n.name, "function" == typeof i && (l = i({
                  state: l,
                  options: void 0 === s ? {} : s,
                  name: n,
                  instance: h
                }) || l)) : (l.reset = !1, a = -1)
              }
            }
          },
          update: (i = function () {
            return new Promise(function (t) {
              h.forceUpdate(), t(l)
            })
          }, function () {
            return s = s || new Promise(function (t) {
              Promise.resolve().then(function () {
                s = void 0, t(i())
              })
            })
          }),
          destroy: function () {
            u(), d = !0
          }
        };
      return ae(o, r) && h.setOptions(e).then(function (t) {
        !d && e.onFirstUpdate && e.onFirstUpdate(t)
      }), h;

      function u() {
        c.forEach(function (t) {
          return t()
        }), c = []
      }
    }
  }
  var re = oe(),
    le = oe({
      defaultModifiers: [Ht, ie, Lt, mt]
    }),
    ce = oe({
      defaultModifiers: [Ht, ie, Lt, mt, ee, Qt, se, It, te]
    }),
    de = Object.freeze({
      __proto__: null,
      popperGenerator: oe,
      detectOverflow: Kt,
      createPopperBase: re,
      createPopper: ce,
      createPopperLite: le,
      top: it,
      bottom: st,
      right: nt,
      left: at,
      auto: "auto",
      basePlacements: ot,
      start: "start",
      end: "end",
      clippingParents: "clippingParents",
      viewport: "viewport",
      popper: "popper",
      reference: "reference",
      variationPlacements: rt,
      placements: lt,
      beforeRead: "beforeRead",
      read: "read",
      afterRead: "afterRead",
      beforeMain: "beforeMain",
      main: "main",
      afterMain: "afterMain",
      beforeWrite: "beforeWrite",
      write: "write",
      afterWrite: "afterWrite",
      modifierPhases: ct,
      applyStyles: mt,
      arrow: It,
      computeStyles: Lt,
      eventListeners: Ht,
      flip: Qt,
      hide: te,
      offset: ee,
      popperOffsets: ie,
      preventOverflow: se
    });
  const he = new RegExp("ArrowUp|ArrowDown|Escape"),
    ue = b() ? "top-end" : "top-start",
    pe = b() ? "top-start" : "top-end",
    fe = b() ? "bottom-end" : "bottom-start",
    me = b() ? "bottom-start" : "bottom-end",
    ge = b() ? "left-start" : "right-start",
    ve = b() ? "right-start" : "left-start",
    be = {
      offset: [0, 2],
      boundary: "clippingParents",
      reference: "toggle",
      display: "dynamic",
      popperConfig: null,
      autoClose: !0
    },
    _e = {
      offset: "(array|string|function)",
      boundary: "(string|element)",
      reference: "(string|element|object)",
      display: "string",
      popperConfig: "(null|object|function)",
      autoClose: "(boolean|string)"
    };
  class ye extends R {
    constructor(t, e) {
      super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners()
    }
    static get Default() {
      return be
    }
    static get DefaultType() {
      return _e
    }
    static get NAME() {
      return "dropdown"
    }
    toggle() {
      u(this._element) || (this._element.classList.contains("show") ? this.hide() : this.show())
    }
    show() {
      if (!u(this._element) && !this._menu.classList.contains("show")) {
        const e = ye.getParentFromElement(this._element),
          t = {
            relatedTarget: this._element
          };
        if (!z.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
          if (this._inNavbar) q.setDataAttribute(this._menu, "popper", "none");
          else {
            if (void 0 === de) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            let t = this._element;
            "parent" === this._config.reference ? t = e : r(this._config.reference) ? t = c(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
            const i = this._getPopperConfig(),
              s = i.modifiers.find(t => "applyStyles" === t.name && !1 === t.enabled);
            this._popper = ce(t, this._menu, i), s && q.setDataAttribute(this._menu, "popper", "static")
          }
          "ontouchstart" in document.documentElement && !e.closest(".navbar-nav") && [].concat(...document.body.children).forEach(t => z.on(t, "mouseover", m)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.toggle("show"), this._element.classList.toggle("show"), z.trigger(this._element, "shown.bs.dropdown", t)
        }
      }
    }
    hide() {
      var t;
      !u(this._element) && this._menu.classList.contains("show") && (t = {
        relatedTarget: this._element
      }, this._completeHide(t))
    }
    dispose() {
      this._popper && this._popper.destroy(), super.dispose()
    }
    update() {
      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
    }
    _addEventListeners() {
      z.on(this._element, "click.bs.dropdown", t => {
        t.preventDefault(), this.toggle()
      })
    }
    _completeHide(t) {
      z.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => z.off(t, "mouseover", m)), this._popper && this._popper.destroy(), this._menu.classList.remove("show"), this._element.classList.remove("show"), this._element.setAttribute("aria-expanded", "false"), q.removeDataAttribute(this._menu, "popper"), z.trigger(this._element, "hidden.bs.dropdown", t))
    }
    _getConfig(t) {
      if (t = {
          ...this.constructor.Default,
          ...q.getDataAttributes(this._element),
          ...t
        }, i("dropdown", t, this.constructor.DefaultType), "object" == typeof t.reference && !r(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError("dropdown".toUpperCase() + ': Option "reference" provided type "object" without a required "getBoundingClientRect" method.');
      return t
    }
    _getMenuElement() {
      return p.next(this._element, ".dropdown-menu")[0]
    }
    _getPlacement() {
      const t = this._element.parentNode;
      if (t.classList.contains("dropend")) return ge;
      if (t.classList.contains("dropstart")) return ve;
      var e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
      return t.classList.contains("dropup") ? e ? pe : ue : e ? me : fe
    }
    _detectNavbar() {
      return null !== this._element.closest(".navbar")
    }
    _getOffset() {
      const {
        offset: e
      } = this._config;
      return "string" == typeof e ? e.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof e ? t => e(t, this._element) : e
    }
    _getPopperConfig() {
      const t = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      return "static" === this._config.display && (t.modifiers = [{
        name: "applyStyles",
        enabled: !1
      }]), {
        ...t,
        ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig
      }
    }
    _selectMenuItem(e) {
      const i = p.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(h);
      if (i.length) {
        let t = i.indexOf(e.target);
        "ArrowUp" === e.key && 0 < t && t--, "ArrowDown" === e.key && t < i.length - 1 && t++, t = -1 === t ? 0 : t, i[t].focus()
      }
    }
    static dropdownInterface(t, e) {
      let i = x(t, "bs.dropdown");
      if (i = i || new ye(t, "object" == typeof e ? e : null), "string" == typeof e) {
        if (void 0 === i[e]) throw new TypeError(`No method named "${e}"`);
        i[e]()
      }
    }
    static jQueryInterface(t) {
      return this.each(function () {
        ye.dropdownInterface(this, t)
      })
    }
    static clearMenus(i) {
      if (!i || 2 !== i.button && ("keyup" !== i.type || "Tab" === i.key)) {
        const s = p.find('[data-bs-toggle="dropdown"]');
        for (let t = 0, e = s.length; t < e; t++) {
          const n = x(s[t], "bs.dropdown");
          if (n && !1 !== n._config.autoClose && n._element.classList.contains("show")) {
            const a = {
              relatedTarget: n._element
            };
            if (i) {
              const p = i.composedPath(),
                s = p.includes(n._menu);
              if (p.includes(n._element) || "inside" === n._config.autoClose && !s || "outside" === n._config.autoClose && s) continue;
              if (n._menu.contains(i.target) && ("keyup" === i.type && "Tab" === i.key || /input|select|option|textarea|form/i.test(i.target.tagName))) continue;
              "click" === i.type && (a.clickEvent = i)
            }
            n._completeHide(a)
          }
        }
      }
    }
    static getParentFromElement(t) {
      return n(t) || t.parentNode
    }
    static dataApiKeydownHandler(t) {
      if (/input|textarea/i.test(t.target.tagName) ? !("Space" === t.key || "Escape" !== t.key && ("ArrowDown" !== t.key && "ArrowUp" !== t.key || t.target.closest(".dropdown-menu"))) : he.test(t.key)) {
        var e = this.classList.contains("show");
        if ((e || "Escape" !== t.key) && (t.preventDefault(), t.stopPropagation(), !u(this))) {
          var i = () => this.matches('[data-bs-toggle="dropdown"]') ? this : p.prev(this, '[data-bs-toggle="dropdown"]')[0];
          if ("Escape" === t.key) return i().focus(), void ye.clearMenus();
          e || "ArrowUp" !== t.key && "ArrowDown" !== t.key ? e && "Space" !== t.key ? ye.getInstance(i())._selectMenuItem(t) : ye.clearMenus() : i().click()
        }
      }
    }
  }
  z.on(document, "keydown.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', ye.dataApiKeydownHandler), z.on(document, "keydown.bs.dropdown.data-api", ".dropdown-menu", ye.dataApiKeydownHandler), z.on(document, "click.bs.dropdown.data-api", ye.clearMenus), z.on(document, "keyup.bs.dropdown.data-api", ye.clearMenus), z.on(document, "click.bs.dropdown.data-api", '[data-bs-toggle="dropdown"]', function (t) {
    t.preventDefault(), ye.dropdownInterface(this)
  }), t(ye);
  const we = () => {
      var t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t)
    },
    xe = (e = we()) => {
      Ce(), ke("body", "paddingRight", t => t + e), ke(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight", t => t + e), ke(".sticky-top", "marginRight", t => t - e)
    },
    Ce = () => {
      var t = document.body.style.overflow;
      t && q.setDataAttribute(document.body, "overflow", t), document.body.style.overflow = "hidden"
    },
    ke = (t, s, n) => {
      const a = we();
      p.find(t).forEach(t => {
        var e, i;
        t !== document.body && window.innerWidth > t.clientWidth + a || (e = t.style[s], i = window.getComputedStyle(t)[s], q.setDataAttribute(t, s, e), t.style[s] = n(Number.parseFloat(i)) + "px")
      })
    },
    Te = () => {
      De("body", "overflow"), De("body", "paddingRight"), De(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", "paddingRight"), De(".sticky-top", "marginRight")
    },
    De = (t, i) => {
      p.find(t).forEach(t => {
        var e = q.getDataAttribute(t, i);
        void 0 === e ? t.style.removeProperty(i) : (q.removeDataAttribute(t, i), t.style[i] = e)
      })
    },
    Se = {
      isVisible: !0,
      isAnimated: !1,
      rootElement: document.body,
      clickCallback: null
    },
    Me = {
      isVisible: "boolean",
      isAnimated: "boolean",
      rootElement: "element",
      clickCallback: "(function|null)"
    };
  class Ee {
    constructor(t) {
      this._config = this._getConfig(t), this._isAppended = !1, this._element = null
    }
    show(t) {
      this._config.isVisible ? (this._append(), this._config.isAnimated && g(this._getElement()), this._getElement().classList.add("show"), this._emulateAnimation(() => {
        _(t)
      })) : _(t)
    }
    hide(t) {
      this._config.isVisible ? (this._getElement().classList.remove("show"), this._emulateAnimation(() => {
        this.dispose(), _(t)
      })) : _(t)
    }
    _getElement() {
      if (!this._element) {
        const t = document.createElement("div");
        t.className = "modal-backdrop", this._config.isAnimated && t.classList.add("fade"), this._element = t
      }
      return this._element
    }
    _getConfig(t) {
      return (t = {
        ...Se,
        ..."object" == typeof t ? t : {}
      }).rootElement = t.rootElement || document.body, i("backdrop", t, Me), t
    }
    _append() {
      this._isAppended || (this._config.rootElement.appendChild(this._getElement()), z.on(this._getElement(), "mousedown.bs.backdrop", () => {
        _(this._config.clickCallback)
      }), this._isAppended = !0)
    }
    dispose() {
      this._isAppended && (z.off(this._element, "mousedown.bs.backdrop"), this._getElement().parentNode.removeChild(this._element), this._isAppended = !1)
    }
    _emulateAnimation(t) {
      var e;
      this._config.isAnimated ? (e = s(this._getElement()), z.one(this._getElement(), "transitionend", () => _(t)), d(this._getElement(), e)) : _(t)
    }
  }
  const Ae = {
      backdrop: !0,
      keyboard: !0,
      focus: !0
    },
    Pe = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      focus: "boolean"
    };
  class Ie extends R {
    constructor(t, e) {
      super(t), this._config = this._getConfig(e), this._dialog = p.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1
    }
    static get Default() {
      return Ae
    }
    static get NAME() {
      return "modal"
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
      var e;
      this._isShown || this._isTransitioning || (this._isAnimated() && (this._isTransitioning = !0), e = z.trigger(this._element, "show.bs.modal", {
        relatedTarget: t
      }), this._isShown || e.defaultPrevented || (this._isShown = !0, xe(), document.body.classList.add("modal-open"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), z.on(this._element, "click.dismiss.bs.modal", '[data-bs-dismiss="modal"]', t => this.hide(t)), z.on(this._dialog, "mousedown.dismiss.bs.modal", () => {
        z.one(this._element, "mouseup.dismiss.bs.modal", t => {
          t.target === this._element && (this._ignoreBackdropClick = !0)
        })
      }), this._showBackdrop(() => this._showElement(t))))
    }
    hide(t) {
      t && t.preventDefault(), this._isShown && !this._isTransitioning && (z.trigger(this._element, "hide.bs.modal").defaultPrevented || (this._isShown = !1, (t = this._isAnimated()) && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), z.off(document, "focusin.bs.modal"), this._element.classList.remove("show"), z.off(this._element, "click.dismiss.bs.modal"), z.off(this._dialog, "mousedown.dismiss.bs.modal"), this._queueCallback(() => this._hideModal(), this._element, t)))
    }
    dispose() {
      [window, this._dialog].forEach(t => z.off(t, ".bs.modal")), this._backdrop.dispose(), super.dispose(), z.off(document, "focusin.bs.modal")
    }
    handleUpdate() {
      this._adjustDialog()
    }
    _initializeBackDrop() {
      return new Ee({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated()
      })
    }
    _getConfig(t) {
      return t = {
        ...Ae,
        ...q.getDataAttributes(this._element),
        ...t
      }, i("modal", t, Pe), t
    }
    _showElement(t) {
      const e = this._isAnimated(),
        i = p.findOne(".modal-body", this._dialog);
      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, i && (i.scrollTop = 0), e && g(this._element), this._element.classList.add("show"), this._config.focus && this._enforceFocus(), this._queueCallback(() => {
        this._config.focus && this._element.focus(), this._isTransitioning = !1, z.trigger(this._element, "shown.bs.modal", {
          relatedTarget: t
        })
      }, this._dialog, e)
    }
    _enforceFocus() {
      z.off(document, "focusin.bs.modal"), z.on(document, "focusin.bs.modal", t => {
        document === t.target || this._element === t.target || this._element.contains(t.target) || this._element.focus()
      })
    }
    _setEscapeEvent() {
      this._isShown ? z.on(this._element, "keydown.dismiss.bs.modal", t => {
        this._config.keyboard && "Escape" === t.key ? (t.preventDefault(), this.hide()) : this._config.keyboard || "Escape" !== t.key || this._triggerBackdropTransition()
      }) : z.off(this._element, "keydown.dismiss.bs.modal")
    }
    _setResizeEvent() {
      this._isShown ? z.on(window, "resize.bs.modal", () => this._adjustDialog()) : z.off(window, "resize.bs.modal")
    }
    _hideModal() {
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
        document.body.classList.remove("modal-open"), this._resetAdjustments(), Te(), z.trigger(this._element, "hidden.bs.modal")
      })
    }
    _showBackdrop(t) {
      z.on(this._element, "click.dismiss.bs.modal", t => {
        this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : t.target === t.currentTarget && (!0 === this._config.backdrop ? this.hide() : "static" === this._config.backdrop && this._triggerBackdropTransition())
      }), this._backdrop.show(t)
    }
    _isAnimated() {
      return this._element.classList.contains("fade")
    }
    _triggerBackdropTransition() {
      if (!z.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) {
        const t = this._element.scrollHeight > document.documentElement.clientHeight;
        t || (this._element.style.overflowY = "hidden"), this._element.classList.add("modal-static");
        const e = s(this._dialog);
        z.off(this._element, "transitionend"), z.one(this._element, "transitionend", () => {
          this._element.classList.remove("modal-static"), t || (z.one(this._element, "transitionend", () => {
            this._element.style.overflowY = ""
          }), d(this._element, e))
        }), d(this._element, e), this._element.focus()
      }
    }
    _adjustDialog() {
      var t = this._element.scrollHeight > document.documentElement.clientHeight,
        e = we(),
        i = 0 < e;
      (!i && t && !b() || i && !t && b()) && (this._element.style.paddingLeft = e + "px"), (i && !t && !b() || !i && t && b()) && (this._element.style.paddingRight = e + "px")
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
    }
    static jQueryInterface(e, i) {
      return this.each(function () {
        const t = Ie.getInstance(this) || new Ie(this, "object" == typeof e ? e : {});
        if ("string" == typeof e) {
          if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
          t[e](i)
        }
      })
    }
  }
  z.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', function (t) {
    const e = n(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), z.one(e, "show.bs.modal", t => {
      t.defaultPrevented || z.one(e, "hidden.bs.modal", () => {
        h(this) && this.focus()
      })
    }), (Ie.getInstance(e) || new Ie(e)).toggle(this)
  }), t(Ie);
  const Oe = {
      backdrop: !0,
      keyboard: !0,
      scroll: !1
    },
    $e = {
      backdrop: "boolean",
      keyboard: "boolean",
      scroll: "boolean"
    };
  class Le extends R {
    constructor(t, e) {
      super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._addEventListeners()
    }
    static get NAME() {
      return "offcanvas"
    }
    static get Default() {
      return Oe
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
      this._isShown || z.trigger(this._element, "show.bs.offcanvas", {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || (xe(), this._enforceFocusOnElement(this._element)), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add("show"), this._queueCallback(() => {
        z.trigger(this._element, "shown.bs.offcanvas", {
          relatedTarget: t
        })
      }, this._element, !0))
    }
    hide() {
      this._isShown && (z.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (z.off(document, "focusin.bs.offcanvas"), this._element.blur(), this._isShown = !1, this._element.classList.remove("show"), this._backdrop.hide(), this._queueCallback(() => {
        this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || Te(), z.trigger(this._element, "hidden.bs.offcanvas")
      }, this._element, !0)))
    }
    dispose() {
      this._backdrop.dispose(), super.dispose(), z.off(document, "focusin.bs.offcanvas")
    }
    _getConfig(t) {
      return t = {
        ...Oe,
        ...q.getDataAttributes(this._element),
        ..."object" == typeof t ? t : {}
      }, i("offcanvas", t, $e), t
    }
    _initializeBackDrop() {
      return new Ee({
        isVisible: this._config.backdrop,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: () => this.hide()
      })
    }
    _enforceFocusOnElement(e) {
      z.off(document, "focusin.bs.offcanvas"), z.on(document, "focusin.bs.offcanvas", t => {
        document === t.target || e === t.target || e.contains(t.target) || e.focus()
      }), e.focus()
    }
    _addEventListeners() {
      z.on(this._element, "click.dismiss.bs.offcanvas", '[data-bs-dismiss="offcanvas"]', () => this.hide()), z.on(this._element, "keydown.dismiss.bs.offcanvas", t => {
        this._config.keyboard && "Escape" === t.key && this.hide()
      })
    }
    static jQueryInterface(e) {
      return this.each(function () {
        const t = x(this, "bs.offcanvas") || new Le(this, "object" == typeof e ? e : {});
        if ("string" == typeof e) {
          if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw new TypeError(`No method named "${e}"`);
          t[e](this)
        }
      })
    }
  }
  z.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', function (t) {
    var e = n(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), u(this) || (z.one(e, "hidden.bs.offcanvas", () => {
      h(this) && this.focus()
    }), (t = p.findOne(".offcanvas.show")) && t !== e && Le.getInstance(t).hide(), (x(e, "bs.offcanvas") || new Le(e)).toggle(this))
  }), z.on(window, "load.bs.offcanvas.data-api", () => {
    p.find(".offcanvas.show").forEach(t => (x(t, "bs.offcanvas") || new Le(t)).show())
  }), t(Le);
  const Ne = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    He = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i,
    Fe = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

  function ze(t, i, s) {
    if (!t.length) return t;
    if (s && "function" == typeof s) return s(t);
    const n = (new window.DOMParser).parseFromString(t, "text/html"),
      a = Object.keys(i),
      o = [].concat(...n.body.querySelectorAll("*"));
    for (let t = 0, e = o.length; t < e; t++) {
      const s = o[t],
        n = s.nodeName.toLowerCase();
      if (a.includes(n)) {
        const r = [].concat(...s.attributes),
          l = [].concat(i["*"] || [], i[n] || []);
        r.forEach(t => {
          ((t, e) => {
            var i = t.nodeName.toLowerCase();
            if (e.includes(i)) return !Ne.has(i) || Boolean(He.test(t.nodeValue) || Fe.test(t.nodeValue));
            const s = e.filter(t => t instanceof RegExp);
            for (let t = 0, e = s.length; t < e; t++)
              if (s[t].test(i)) return !0;
            return !1
          })(t, l) || s.removeAttribute(t.nodeName)
        })
      } else s.parentNode.removeChild(s)
    }
    return n.body.innerHTML
  }
  const Re = new RegExp("(^|\\s)bs-tooltip\\S+", "g"),
    Be = new Set(["sanitize", "allowList", "sanitizeFn"]),
    je = {
      animation: "boolean",
      template: "string",
      title: "(string|element|function)",
      trigger: "string",
      delay: "(number|object)",
      html: "boolean",
      selector: "(string|boolean)",
      placement: "(string|function)",
      offset: "(array|string|function)",
      container: "(string|element|boolean)",
      fallbackPlacements: "array",
      boundary: "(string|element)",
      customClass: "(string|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      allowList: "object",
      popperConfig: "(null|object|function)"
    },
    We = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: b() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: b() ? "right" : "left"
    },
    Ve = {
      animation: !0,
      template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      trigger: "hover focus",
      title: "",
      delay: 0,
      html: !1,
      selector: !1,
      placement: "top",
      offset: [0, 0],
      container: !1,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      boundary: "clippingParents",
      customClass: "",
      sanitize: !0,
      sanitizeFn: null,
      allowList: {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
      },
      popperConfig: null
    },
    qe = {
      HIDE: "hide.bs.tooltip",
      HIDDEN: "hidden.bs.tooltip",
      SHOW: "show.bs.tooltip",
      SHOWN: "shown.bs.tooltip",
      INSERTED: "inserted.bs.tooltip",
      CLICK: "click.bs.tooltip",
      FOCUSIN: "focusin.bs.tooltip",
      FOCUSOUT: "focusout.bs.tooltip",
      MOUSEENTER: "mouseenter.bs.tooltip",
      MOUSELEAVE: "mouseleave.bs.tooltip"
    };
  class Ye extends R {
    constructor(t, e) {
      if (void 0 === de) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
      super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners()
    }
    static get Default() {
      return Ve
    }
    static get NAME() {
      return "tooltip"
    }
    static get Event() {
      return qe
    }
    static get DefaultType() {
      return je
    }
    enable() {
      this._isEnabled = !0
    }
    disable() {
      this._isEnabled = !1
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled
    }
    toggle(t) {
      if (this._isEnabled)
        if (t) {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e)
        } else this.getTipElement().classList.contains("show") ? this._leave(null, this) : this._enter(null, this)
    }
    dispose() {
      clearTimeout(this._timeout), z.off(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this.tip && this.tip.parentNode && this.tip.parentNode.removeChild(this.tip), this._popper && this._popper.destroy(), super.dispose()
    }
    show() {
      if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
      if (this.isWithContent() && this._isEnabled) {
        const e = z.trigger(this._element, this.constructor.Event.SHOW),
          i = f(this._element),
          s = (null === i ? this._element.ownerDocument.documentElement : i).contains(this._element);
        if (!e.defaultPrevented && s) {
          const n = this.getTipElement(),
            a = l(this.constructor.NAME);
          n.setAttribute("id", a), this._element.setAttribute("aria-describedby", a), this.setContent(), this._config.animation && n.classList.add("fade");
          var t = "function" == typeof this._config.placement ? this._config.placement.call(this, n, this._element) : this._config.placement,
            t = this._getAttachment(t);
          this._addAttachmentClass(t);
          const {
            container: o
          } = this._config;
          w(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (o.appendChild(n), z.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = ce(this._element, n, this._getPopperConfig(t)), n.classList.add("show");
          const r = "function" == typeof this._config.customClass ? this._config.customClass() : this._config.customClass;
          r && n.classList.add(...r.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => {
            z.on(t, "mouseover", m)
          });
          t = this.tip.classList.contains("fade");
          this._queueCallback(() => {
            var t = this._hoverState;
            this._hoverState = null, z.trigger(this._element, this.constructor.Event.SHOWN), "out" === t && this._leave(null, this)
          }, this.tip, t)
        }
      }
    }
    hide() {
      if (this._popper) {
        const e = this.getTipElement();
        var t;
        z.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented || (e.classList.remove("show"), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => z.off(t, "mouseover", m)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, t = this.tip.classList.contains("fade"), this._queueCallback(() => {
          this._isWithActiveTrigger() || ("show" !== this._hoverState && e.parentNode && e.parentNode.removeChild(e), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), z.trigger(this._element, this.constructor.Event.HIDDEN), this._popper && (this._popper.destroy(), this._popper = null))
        }, this.tip, t), this._hoverState = "")
      }
    }
    update() {
      null !== this._popper && this._popper.update()
    }
    isWithContent() {
      return Boolean(this.getTitle())
    }
    getTipElement() {
      if (this.tip) return this.tip;
      const t = document.createElement("div");
      return t.innerHTML = this._config.template, this.tip = t.children[0], this.tip
    }
    setContent() {
      const t = this.getTipElement();
      this.setElementContent(p.findOne(".tooltip-inner", t), this.getTitle()), t.classList.remove("fade", "show")
    }
    setElementContent(t, e) {
      if (null !== t) return r(e) ? (e = c(e), void(this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.appendChild(e)) : t.textContent = e.textContent)) : void(this._config.html ? (this._config.sanitize && (e = ze(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e)
    }
    getTitle() {
      let t = this._element.getAttribute("data-bs-original-title");
      return t = t || ("function" == typeof this._config.title ? this._config.title.call(this._element) : this._config.title), t
    }
    updateAttachment(t) {
      return "right" === t ? "end" : "left" === t ? "start" : t
    }
    _initializeOnDelegatedTarget(t, e) {
      var i = this.constructor.DATA_KEY;
      return (e = e || x(t.delegateTarget, i)) || (e = new this.constructor(t.delegateTarget, this._getDelegateConfig()), w(t.delegateTarget, i, e)), e
    }
    _getOffset() {
      const {
        offset: e
      } = this._config;
      return "string" == typeof e ? e.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof e ? t => e(t, this._element) : e
    }
    _getPopperConfig(t) {
      t = {
        placement: t,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "onChange",
          enabled: !0,
          phase: "afterWrite",
          fn: t => this._handlePopperPlacementChange(t)
        }],
        onFirstUpdate: t => {
          t.options.placement !== t.placement && this._handlePopperPlacementChange(t)
        }
      };
      return {
        ...t,
        ..."function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig
      }
    }
    _addAttachmentClass(t) {
      this.getTipElement().classList.add("bs-tooltip-" + this.updateAttachment(t))
    }
    _getAttachment(t) {
      return We[t.toUpperCase()]
    }
    _setListeners() {
      this._config.trigger.split(" ").forEach(t => {
        var e;
        "click" === t ? z.on(this._element, this.constructor.Event.CLICK, this._config.selector, t => this.toggle(t)) : "manual" !== t && (e = "hover" === t ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, t = "hover" === t ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT, z.on(this._element, e, this._config.selector, t => this._enter(t)), z.on(this._element, t, this._config.selector, t => this._leave(t)))
      }), this._hideModalHandler = () => {
        this._element && this.hide()
      }, z.on(this._element.closest(".modal"), "hide.bs.modal", this._hideModalHandler), this._config.selector ? this._config = {
        ...this._config,
        trigger: "manual",
        selector: ""
      } : this._fixTitle()
    }
    _fixTitle() {
      var t = this._element.getAttribute("title"),
        e = typeof this._element.getAttribute("data-bs-original-title");
      !t && "string" == e || (this._element.setAttribute("data-bs-original-title", t || ""), !t || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""))
    }
    _enter(t, e) {
      e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusin" === t.type ? "focus" : "hover"] = !0), e.getTipElement().classList.contains("show") || "show" === e._hoverState ? e._hoverState = "show" : (clearTimeout(e._timeout), e._hoverState = "show", e._config.delay && e._config.delay.show ? e._timeout = setTimeout(() => {
        "show" === e._hoverState && e.show()
      }, e._config.delay.show) : e.show())
    }
    _leave(t, e) {
      e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusout" === t.type ? "focus" : "hover"] = e._element.contains(t.relatedTarget)), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = "out", e._config.delay && e._config.delay.hide ? e._timeout = setTimeout(() => {
        "out" === e._hoverState && e.hide()
      }, e._config.delay.hide) : e.hide())
    }
    _isWithActiveTrigger() {
      for (const t in this._activeTrigger)
        if (this._activeTrigger[t]) return !0;
      return !1
    }
    _getConfig(t) {
      const e = q.getDataAttributes(this._element);
      return Object.keys(e).forEach(t => {
        Be.has(t) && delete e[t]
      }), (t = {
        ...this.constructor.Default,
        ...e,
        ..."object" == typeof t && t ? t : {}
      }).container = !1 === t.container ? document.body : c(t.container), "number" == typeof t.delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), i("tooltip", t, this.constructor.DefaultType), t.sanitize && (t.template = ze(t.template, t.allowList, t.sanitizeFn)), t
    }
    _getDelegateConfig() {
      const t = {};
      if (this._config)
        for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);
      return t
    }
    _cleanTipClass() {
      const e = this.getTipElement(),
        t = e.getAttribute("class").match(Re);
      null !== t && 0 < t.length && t.map(t => t.trim()).forEach(t => e.classList.remove(t))
    }
    _handlePopperPlacementChange(t) {
      var {
        state: t
      } = t;
      t && (this.tip = t.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(t.placement)))
    }
    static jQueryInterface(i) {
      return this.each(function () {
        let t = x(this, "bs.tooltip");
        var e = "object" == typeof i && i;
        if ((t || !/dispose|hide/.test(i)) && (t = t || new Ye(this, e), "string" == typeof i)) {
          if (void 0 === t[i]) throw new TypeError(`No method named "${i}"`);
          t[i]()
        }
      })
    }
  }
  t(Ye);
  const Ue = new RegExp("(^|\\s)bs-popover\\S+", "g"),
    Xe = {
      ...Ye.Default,
      placement: "right",
      offset: [0, 8],
      trigger: "click",
      content: "",
      template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
    },
    Ge = {
      ...Ye.DefaultType,
      content: "(string|element|function)"
    },
    Ke = {
      HIDE: "hide.bs.popover",
      HIDDEN: "hidden.bs.popover",
      SHOW: "show.bs.popover",
      SHOWN: "shown.bs.popover",
      INSERTED: "inserted.bs.popover",
      CLICK: "click.bs.popover",
      FOCUSIN: "focusin.bs.popover",
      FOCUSOUT: "focusout.bs.popover",
      MOUSEENTER: "mouseenter.bs.popover",
      MOUSELEAVE: "mouseleave.bs.popover"
    };
  class Qe extends Ye {
    static get Default() {
      return Xe
    }
    static get NAME() {
      return "popover"
    }
    static get Event() {
      return Ke
    }
    static get DefaultType() {
      return Ge
    }
    isWithContent() {
      return this.getTitle() || this._getContent()
    }
    setContent() {
      const t = this.getTipElement();
      this.setElementContent(p.findOne(".popover-header", t), this.getTitle());
      let e = this._getContent();
      "function" == typeof e && (e = e.call(this._element)), this.setElementContent(p.findOne(".popover-body", t), e), t.classList.remove("fade", "show")
    }
    _addAttachmentClass(t) {
      this.getTipElement().classList.add("bs-popover-" + this.updateAttachment(t))
    }
    _getContent() {
      return this._element.getAttribute("data-bs-content") || this._config.content
    }
    _cleanTipClass() {
      const e = this.getTipElement(),
        t = e.getAttribute("class").match(Ue);
      null !== t && 0 < t.length && t.map(t => t.trim()).forEach(t => e.classList.remove(t))
    }
    static jQueryInterface(i) {
      return this.each(function () {
        let t = x(this, "bs.popover");
        var e = "object" == typeof i ? i : null;
        if ((t || !/dispose|hide/.test(i)) && (t || (t = new Qe(this, e), w(this, "bs.popover", t)), "string" == typeof i)) {
          if (void 0 === t[i]) throw new TypeError(`No method named "${i}"`);
          t[i]()
        }
      })
    }
  }
  t(Qe);
  const Je = {
      offset: 10,
      method: "auto",
      target: ""
    },
    Ze = {
      offset: "number",
      method: "string",
      target: "(string|element)"
    };
  class ti extends R {
    constructor(t, e) {
      super(t), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(e), this._selector = `${this._config.target} .nav-link, ${this._config.target} .list-group-item, ${this._config.target} .dropdown-item`, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, z.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process()), this.refresh(), this._process()
    }
    static get Default() {
      return Je
    }
    static get NAME() {
      return "scrollspy"
    }
    refresh() {
      const t = this._scrollElement === this._scrollElement.window ? "offset" : "position",
        s = "auto" === this._config.method ? t : this._config.method,
        n = "position" === s ? this._getScrollTop() : 0;
      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), p.find(this._selector).map(t => {
        const e = o(t),
          i = e ? p.findOne(e) : null;
        if (i) {
          const p = i.getBoundingClientRect();
          if (p.width || p.height) return [q[s](i).top + n, e]
        }
        return null
      }).filter(t => t).sort((t, e) => t[0] - e[0]).forEach(t => {
        this._offsets.push(t[0]), this._targets.push(t[1])
      })
    }
    dispose() {
      z.off(this._scrollElement, ".bs.scrollspy"), super.dispose()
    }
    _getConfig(e) {
      if ("string" != typeof (e = {
          ...Je,
          ...q.getDataAttributes(this._element),
          ..."object" == typeof e && e ? e : {}
        }).target && r(e.target)) {
        let {
          id: t
        } = e.target;
        t || (t = l("scrollspy"), e.target.id = t), e.target = "#" + t
      }
      return i("scrollspy", e, Ze), e
    }
    _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
    }
    _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
    }
    _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
    }
    _process() {
      const e = this._getScrollTop() + this._config.offset,
        t = this._getScrollHeight(),
        i = this._config.offset + t - this._getOffsetHeight();
      if (this._scrollHeight !== t && this.refresh(), e >= i) {
        const e = this._targets[this._targets.length - 1];
        this._activeTarget !== e && this._activate(e)
      } else {
        if (this._activeTarget && e < this._offsets[0] && 0 < this._offsets[0]) return this._activeTarget = null, void this._clear();
        for (let t = this._offsets.length; t--;) this._activeTarget !== this._targets[t] && e >= this._offsets[t] && (void 0 === this._offsets[t + 1] || e < this._offsets[t + 1]) && this._activate(this._targets[t])
      }
    }
    _activate(e) {
      this._activeTarget = e, this._clear();
      const t = this._selector.split(",").map(t => `${t}[data-bs-target="${e}"],${t}[href="${e}"]`),
        i = p.findOne(t.join(","));
      i.classList.contains("dropdown-item") ? (p.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add("active"), i.classList.add("active")) : (i.classList.add("active"), p.parents(i, ".nav, .list-group").forEach(t => {
        p.prev(t, ".nav-link, .list-group-item").forEach(t => t.classList.add("active")), p.prev(t, ".nav-item").forEach(t => {
          p.children(t, ".nav-link").forEach(t => t.classList.add("active"))
        })
      })), z.trigger(this._scrollElement, "activate.bs.scrollspy", {
        relatedTarget: e
      })
    }
    _clear() {
      p.find(this._selector).filter(t => t.classList.contains("active")).forEach(t => t.classList.remove("active"))
    }
    static jQueryInterface(e) {
      return this.each(function () {
        const t = ti.getInstance(this) || new ti(this, "object" == typeof e ? e : {});
        if ("string" == typeof e) {
          if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
          t[e]()
        }
      })
    }
  }
  z.on(window, "load.bs.scrollspy.data-api", () => {
    p.find('[data-bs-spy="scroll"]').forEach(t => new ti(t))
  }), t(ti);
  class ei extends R {
    static get NAME() {
      return "tab"
    }
    show() {
      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE || !this._element.classList.contains("active")) {
        let t;
        const i = n(this._element),
          s = this._element.closest(".nav, .list-group");
        if (s) {
          const i = "UL" === s.nodeName || "OL" === s.nodeName ? ":scope > li > .active" : ".active";
          t = p.find(i, s), t = t[t.length - 1]
        }
        var e = t ? z.trigger(t, "hide.bs.tab", {
          relatedTarget: this._element
        }) : null;
        z.trigger(this._element, "show.bs.tab", {
          relatedTarget: t
        }).defaultPrevented || null !== e && e.defaultPrevented || (this._activate(this._element, s), e = () => {
          z.trigger(t, "hidden.bs.tab", {
            relatedTarget: this._element
          }), z.trigger(this._element, "shown.bs.tab", {
            relatedTarget: t
          })
        }, i ? this._activate(i, i.parentNode, e) : e())
      }
    }
    _activate(t, e, i) {
      const s = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? p.children(e, ".active") : p.find(":scope > li > .active", e))[0],
        n = i && s && s.classList.contains("fade"),
        a = () => this._transitionComplete(t, s, i);
      s && n ? (s.classList.remove("show"), this._queueCallback(a, t, !0)) : a()
    }
    _transitionComplete(t, e, i) {
      if (e) {
        e.classList.remove("active");
        const t = p.findOne(":scope > .dropdown-menu .active", e.parentNode);
        t && t.classList.remove("active"), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1)
      }
      t.classList.add("active"), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), g(t), t.classList.contains("fade") && t.classList.add("show");
      let s = t.parentNode;
      if (s && "LI" === s.nodeName && (s = s.parentNode), s && s.classList.contains("dropdown-menu")) {
        const e = t.closest(".dropdown");
        e && p.find(".dropdown-toggle", e).forEach(t => t.classList.add("active")), t.setAttribute("aria-expanded", !0)
      }
      i && i()
    }
    static jQueryInterface(e) {
      return this.each(function () {
        const t = x(this, "bs.tab") || new ei(this);
        if ("string" == typeof e) {
          if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
          t[e]()
        }
      })
    }
  }
  z.on(document, "click.bs.tab.data-api", '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', function (t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), u(this) || (x(this, "bs.tab") || new ei(this)).show()
  }), t(ei);
  const ii = {
      animation: "boolean",
      autohide: "boolean",
      delay: "number"
    },
    si = {
      animation: !0,
      autohide: !0,
      delay: 5e3
    };
  class ni extends R {
    constructor(t, e) {
      super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
    }
    static get DefaultType() {
      return ii
    }
    static get Default() {
      return si
    }
    static get NAME() {
      return "toast"
    }
    show() {
      z.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove("hide"), g(this._element), this._element.classList.add("showing"), this._queueCallback(() => {
        this._element.classList.remove("showing"), this._element.classList.add("show"), z.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide()
      }, this._element, this._config.animation))
    }
    hide() {
      this._element.classList.contains("show") && (z.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.remove("show"), this._queueCallback(() => {
        this._element.classList.add("hide"), z.trigger(this._element, "hidden.bs.toast")
      }, this._element, this._config.animation)))
    }
    dispose() {
      this._clearTimeout(), this._element.classList.contains("show") && this._element.classList.remove("show"), super.dispose()
    }
    _getConfig(t) {
      return t = {
        ...si,
        ...q.getDataAttributes(this._element),
        ..."object" == typeof t && t ? t : {}
      }, i("toast", t, this.constructor.DefaultType), t
    }
    _maybeScheduleHide() {
      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
        this.hide()
      }, this._config.delay)))
    }
    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e
      }
      e ? this._clearTimeout() : (t = t.relatedTarget, this._element === t || this._element.contains(t) || this._maybeScheduleHide())
    }
    _setListeners() {
      z.on(this._element, "click.dismiss.bs.toast", '[data-bs-dismiss="toast"]', () => this.hide()), z.on(this._element, "mouseover.bs.toast", t => this._onInteraction(t, !0)), z.on(this._element, "mouseout.bs.toast", t => this._onInteraction(t, !1)), z.on(this._element, "focusin.bs.toast", t => this._onInteraction(t, !0)), z.on(this._element, "focusout.bs.toast", t => this._onInteraction(t, !1))
    }
    _clearTimeout() {
      clearTimeout(this._timeout), this._timeout = null
    }
    static jQueryInterface(e) {
      return this.each(function () {
        let t = x(this, "bs.toast");
        if (t = t || new ni(this, "object" == typeof e && e), "string" == typeof e) {
          if (void 0 === t[e]) throw new TypeError(`No method named "${e}"`);
          t[e](this)
        }
      })
    }
  }
  return t(ni), {
    Alert: B,
    Button: j,
    Carousel: J,
    Collapse: et,
    Dropdown: ye,
    Modal: Ie,
    Offcanvas: Le,
    Popover: Qe,
    ScrollSpy: ti,
    Tab: ei,
    Toast: ni,
    Tooltip: Ye
  }
}),
function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Chart = e()
}(this, function () {
  "use strict";
  const o = "undefined" == typeof window ? function (t) {
    return t()
  } : window.requestAnimationFrame;

  function l(e, i, t) {
    const s = t || (t => Array.prototype.slice.call(t));
    let n = !1,
      a;
    return function (...t) {
      a = s(t), n || (n = !0, o.call(window, () => {
        n = !1, e.apply(i, a)
      }))
    }
  }

  function r(t, e) {
    let i;
    return function () {
      return e ? (clearTimeout(i), i = setTimeout(t, e)) : t(), e
    }
  }
  const f = t => "start" === t ? "left" : "end" === t ? "right" : "center",
    P = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2,
    I = (t, e, i) => "right" === t ? i : "center" === t ? (e + i) / 2 : e;
  var c = new class {
    constructor() {
      this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0
    }
    _notify(e, i, s, t) {
      const n = i.listeners[t],
        a = i.duration;
      n.forEach(t => t({
        chart: e,
        initial: i.initial,
        numSteps: a,
        currentStep: Math.min(s - i.start, a)
      }))
    }
    _refresh() {
      const t = this;
      t._request || (t._running = !0, t._request = o.call(window, () => {
        t._update(), t._request = null, t._running && t._refresh()
      }))
    }
    _update(o = Date.now()) {
      const r = this;
      let l = 0;
      r._charts.forEach((s, n) => {
        if (s.running && s.items.length) {
          const a = s.items;
          let t, e = a.length - 1,
            i = !1;
          for (; 0 <= e; --e) t = a[e], t._active ? (t._total > s.duration && (s.duration = t._total), t.tick(o), i = !0) : (a[e] = a[a.length - 1], a.pop());
          i && (n.draw(), r._notify(n, s, o, "progress")), a.length || (s.running = !1, r._notify(n, s, o, "complete"), s.initial = !1), l += a.length
        }
      }), r._lastDate = o, 0 === l && (r._running = !1)
    }
    _getAnims(t) {
      const e = this._charts;
      let i = e.get(t);
      return i || (i = {
        running: !1,
        initial: !0,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      }, e.set(t, i)), i
    }
    listen(t, e, i) {
      this._getAnims(t).listeners[e].push(i)
    }
    add(t, e) {
      e && e.length && this._getAnims(t).items.push(...e)
    }
    has(t) {
      return 0 < this._getAnims(t).items.length
    }
    start(t) {
      const e = this._charts.get(t);
      e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e) => Math.max(t, e._duration), 0), this._refresh())
    }
    running(t) {
      if (!this._running) return !1;
      t = this._charts.get(t);
      return !!(t && t.running && t.items.length)
    }
    stop(e) {
      const i = this._charts.get(e);
      if (i && i.items.length) {
        const s = i.items;
        let t = s.length - 1;
        for (; 0 <= t; --t) s[t].cancel();
        i.items = [], this._notify(e, i, Date.now(), "complete")
      }
    }
    remove(t) {
      return this._charts.delete(t)
    }
  };
  const a = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    },
    e = "0123456789ABCDEF",
    i = t => e[15 & t],
    s = t => e[(240 & t) >> 4] + e[15 & t],
    n = t => (240 & t) >> 4 == (15 & t);
  const d = (t, e, i) => Math.max(Math.min(t, i), e);

  function h(t) {
    return d(2.55 * t + .5 | 0, 0, 255)
  }

  function u(t) {
    return d(255 * t + .5 | 0, 0, 255)
  }

  function p(t) {
    return d((t / 2.55 + .5 | 0) / 100, 0, 1)
  }

  function m(t) {
    return d(100 * t + .5 | 0, 0, 100)
  }
  const g = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/,
    v = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;

  function b(i, t, s) {
    const n = t * Math.min(s, 1 - s),
      e = (t, e = (t + i / 30) % 12) => s - n * Math.max(Math.min(e - 3, 9 - e, 1), -1);
    return [e(0), e(8), e(4)]
  }

  function _(i, s, n) {
    i = (t, e = (t + i / 60) % 6) => n - n * s * Math.max(Math.min(e, 4 - e, 1), 0);
    return [i(5), i(3), i(1)]
  }

  function y(t, e, i) {
    const s = b(t, 1, .5);
    let n;
    for (1 < e + i && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++) s[n] *= 1 - e - i, s[n] += e;
    return s
  }

  function w(t) {
    var e = t.r / 255,
      i = t.g / 255,
      s = t.b / 255,
      n = Math.max(e, i, s),
      a = Math.min(e, i, s),
      t = (n + a) / 2;
    let o, r, l;
    return n !== a && (l = n - a, r = .5 < t ? l / (2 - n - a) : l / (n + a), o = n === e ? (i - s) / l + (i < s ? 6 : 0) : n === i ? (s - e) / l + 2 : (e - i) / l + 4, o = 60 * o + .5), [0 | o, r || 0, t]
  }

  function x(t, e, i, s) {
    return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(u)
  }

  function C(t, e, i) {
    return x(b, t, e, i)
  }

  function k(t) {
    return (t % 360 + 360) % 360
  }
  const T = {
      x: "dark",
      Z: "light",
      Y: "re",
      X: "blu",
      W: "gr",
      V: "medium",
      U: "slate",
      A: "ee",
      T: "ol",
      S: "or",
      B: "ra",
      C: "lateg",
      D: "ights",
      R: "in",
      Q: "turquois",
      E: "hi",
      P: "ro",
      O: "al",
      N: "le",
      M: "de",
      L: "yello",
      F: "en",
      K: "ch",
      G: "arks",
      H: "ea",
      I: "ightg",
      J: "wh"
    },
    D = {
      OiceXe: "f0f8ff",
      antiquewEte: "faebd7",
      aqua: "ffff",
      aquamarRe: "7fffd4",
      azuY: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "0",
      blanKedOmond: "ffebcd",
      Xe: "ff",
      XeviTet: "8a2be2",
      bPwn: "a52a2a",
      burlywood: "deb887",
      caMtXe: "5f9ea0",
      KartYuse: "7fff00",
      KocTate: "d2691e",
      cSO: "ff7f50",
      cSnflowerXe: "6495ed",
      cSnsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "ffff",
      xXe: "8b",
      xcyan: "8b8b",
      xgTMnPd: "b8860b",
      xWay: "a9a9a9",
      xgYF: "6400",
      xgYy: "a9a9a9",
      xkhaki: "bdb76b",
      xmagFta: "8b008b",
      xTivegYF: "556b2f",
      xSange: "ff8c00",
      xScEd: "9932cc",
      xYd: "8b0000",
      xsOmon: "e9967a",
      xsHgYF: "8fbc8f",
      xUXe: "483d8b",
      xUWay: "2f4f4f",
      xUgYy: "2f4f4f",
      xQe: "ced1",
      xviTet: "9400d3",
      dAppRk: "ff1493",
      dApskyXe: "bfff",
      dimWay: "696969",
      dimgYy: "696969",
      dodgerXe: "1e90ff",
      fiYbrick: "b22222",
      flSOwEte: "fffaf0",
      foYstWAn: "228b22",
      fuKsia: "ff00ff",
      gaRsbSo: "dcdcdc",
      ghostwEte: "f8f8ff",
      gTd: "ffd700",
      gTMnPd: "daa520",
      Way: "808080",
      gYF: "8000",
      gYFLw: "adff2f",
      gYy: "808080",
      honeyMw: "f0fff0",
      hotpRk: "ff69b4",
      RdianYd: "cd5c5c",
      Rdigo: "4b0082",
      ivSy: "fffff0",
      khaki: "f0e68c",
      lavFMr: "e6e6fa",
      lavFMrXsh: "fff0f5",
      lawngYF: "7cfc00",
      NmoncEffon: "fffacd",
      ZXe: "add8e6",
      ZcSO: "f08080",
      Zcyan: "e0ffff",
      ZgTMnPdLw: "fafad2",
      ZWay: "d3d3d3",
      ZgYF: "90ee90",
      ZgYy: "d3d3d3",
      ZpRk: "ffb6c1",
      ZsOmon: "ffa07a",
      ZsHgYF: "20b2aa",
      ZskyXe: "87cefa",
      ZUWay: "778899",
      ZUgYy: "778899",
      ZstAlXe: "b0c4de",
      ZLw: "ffffe0",
      lime: "ff00",
      limegYF: "32cd32",
      lRF: "faf0e6",
      magFta: "ff00ff",
      maPon: "800000",
      VaquamarRe: "66cdaa",
      VXe: "cd",
      VScEd: "ba55d3",
      VpurpN: "9370db",
      VsHgYF: "3cb371",
      VUXe: "7b68ee",
      VsprRggYF: "fa9a",
      VQe: "48d1cc",
      VviTetYd: "c71585",
      midnightXe: "191970",
      mRtcYam: "f5fffa",
      mistyPse: "ffe4e1",
      moccasR: "ffe4b5",
      navajowEte: "ffdead",
      navy: "80",
      Tdlace: "fdf5e6",
      Tive: "808000",
      TivedBb: "6b8e23",
      Sange: "ffa500",
      SangeYd: "ff4500",
      ScEd: "da70d6",
      pOegTMnPd: "eee8aa",
      pOegYF: "98fb98",
      pOeQe: "afeeee",
      pOeviTetYd: "db7093",
      papayawEp: "ffefd5",
      pHKpuff: "ffdab9",
      peru: "cd853f",
      pRk: "ffc0cb",
      plum: "dda0dd",
      powMrXe: "b0e0e6",
      purpN: "800080",
      YbeccapurpN: "663399",
      Yd: "ff0000",
      Psybrown: "bc8f8f",
      PyOXe: "4169e1",
      saddNbPwn: "8b4513",
      sOmon: "fa8072",
      sandybPwn: "f4a460",
      sHgYF: "2e8b57",
      sHshell: "fff5ee",
      siFna: "a0522d",
      silver: "c0c0c0",
      skyXe: "87ceeb",
      UXe: "6a5acd",
      UWay: "708090",
      UgYy: "708090",
      snow: "fffafa",
      sprRggYF: "ff7f",
      stAlXe: "4682b4",
      tan: "d2b48c",
      teO: "8080",
      tEstN: "d8bfd8",
      tomato: "ff6347",
      Qe: "40e0d0",
      viTet: "ee82ee",
      JHt: "f5deb3",
      wEte: "ffffff",
      wEtesmoke: "f5f5f5",
      Lw: "ffff00",
      LwgYF: "9acd32"
    };
  let S;

  function M(e, i, s) {
    if (e) {
      let t = w(e);
      t[i] = Math.max(0, Math.min(t[i] + t[i] * s, 0 === i ? 360 : 1)), t = C(t), e.r = t[0], e.g = t[1], e.b = t[2]
    }
  }

  function E(t, e) {
    return t && Object.assign(e || {}, t)
  }

  function A(t) {
    var e = {
      r: 0,
      g: 0,
      b: 0,
      a: 255
    };
    return Array.isArray(t) ? 3 <= t.length && (e = {
      r: t[0],
      g: t[1],
      b: t[2],
      a: 255
    }, 3 < t.length && (e.a = u(t[3]))) : (e = E(t, {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    })).a = u(e.a), e
  }

  function O(t) {
    return ("r" === t.charAt(0) ? function (t) {
      t = g.exec(t);
      let e, i, s, n = 255;
      if (t) {
        if (t[7] !== e) {
          const a = +t[7];
          n = 255 & (t[8] ? h(a) : 255 * a)
        }
        return e = +t[1], i = +t[3], s = +t[5], e = 255 & (t[2] ? h(e) : e), i = 255 & (t[4] ? h(i) : i), s = 255 & (t[6] ? h(s) : s), {
          r: e,
          g: i,
          b: s,
          a: n
        }
      }
    } : function (t) {
      var e = v.exec(t);
      let i, s = 255;
      if (e) {
        void 0 !== e[5] && (s = (e[6] ? h : u)(+e[5]));
        var n = k(+e[2]),
          a = +e[3] / 100,
          t = +e[4] / 100;
        return {
          r: (i = "hwb" === e[1] ? x(y, n, a, t) : "hsv" === e[1] ? x(_, n, a, t) : C(n, a, t))[0],
          g: i[1],
          b: i[2],
          a: s
        }
      }
    })(t)
  }
  class $ {
    constructor(t) {
      if (t instanceof $) return t;
      var e, i, s = typeof t;
      let n;
      "object" == s ? n = A(t) : "string" == s && (s = (e = t).length, "#" === e[0] && (4 === s || 5 === s ? i = {
        r: 255 & 17 * a[e[1]],
        g: 255 & 17 * a[e[2]],
        b: 255 & 17 * a[e[3]],
        a: 5 === s ? 17 * a[e[4]] : 255
      } : 7 !== s && 9 !== s || (i = {
        r: a[e[1]] << 4 | a[e[2]],
        g: a[e[3]] << 4 | a[e[4]],
        b: a[e[5]] << 4 | a[e[6]],
        a: 9 === s ? a[e[7]] << 4 | a[e[8]] : 255
      })), n = i || (i = t, S || (S = function () {
        const t = {},
          e = Object.keys(D),
          i = Object.keys(T);
        let s, n, a, o, r;
        for (s = 0; s < e.length; s++) {
          for (o = r = e[s], n = 0; n < i.length; n++) a = i[n], r = r.replace(a, T[a]);
          a = parseInt(D[o], 16), t[r] = [a >> 16 & 255, a >> 8 & 255, 255 & a]
        }
        return t
      }(), S.transparent = [0, 0, 0, 0]), (i = S[i.toLowerCase()]) && {
        r: i[0],
        g: i[1],
        b: i[2],
        a: 4 === i.length ? i[3] : 255
      }) || O(t)), this._rgb = n, this._valid = !!n
    }
    get valid() {
      return this._valid
    }
    get rgb() {
      var t = E(this._rgb);
      return t && (t.a = p(t.a)), t
    }
    set rgb(t) {
      this._rgb = A(t)
    }
    rgbString() {
      return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${p(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : this._rgb;
      var t
    }
    hexString() {
      return this._valid ? (t = this._rgb, e = t, e = n(e.r) && n(e.g) && n(e.b) && n(e.a) ? i : s, t && "#" + e(t.r) + e(t.g) + e(t.b) + (t.a < 255 ? e(t.a) : "")) : this._rgb;
      var t, e
    }
    hslString() {
      return this._valid ? function (t) {
        if (t) {
          var e = w(t),
            i = e[0],
            s = m(e[1]),
            e = m(e[2]);
          return t.a < 255 ? `hsla(${i}, ${s}%, ${e}%, ${p(t.a)})` : `hsl(${i}, ${s}%, ${e}%)`
        }
      }(this._rgb) : this._rgb
    }
    mix(t, e) {
      if (t) {
        const s = this.rgb,
          n = t.rgb;
        var i = void 0 === e ? .5 : e,
          t = 2 * i - 1,
          e = s.a - n.a,
          t = (1 + (t * e == -1 ? t : (t + e) / (1 + t * e))) / 2,
          e = 1 - t;
        s.r = 255 & t * s.r + e * n.r + .5, s.g = 255 & t * s.g + e * n.g + .5, s.b = 255 & t * s.b + e * n.b + .5, s.a = i * s.a + (1 - i) * n.a, this.rgb = s
      }
      return this
    }
    clone() {
      return new $(this.rgb)
    }
    alpha(t) {
      return this._rgb.a = u(t), this
    }
    clearer(t) {
      return this._rgb.a *= 1 - t, this
    }
    greyscale() {
      const t = this._rgb,
        e = .3 * t.r + .59 * t.g + .11 * t.b + .5 | 0;
      return t.r = t.g = t.b = e, this
    }
    opaquer(t) {
      return this._rgb.a *= 1 + t, this
    }
    negate() {
      const t = this._rgb;
      return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this
    }
    lighten(t) {
      return M(this._rgb, 2, t), this
    }
    darken(t) {
      return M(this._rgb, 2, -t), this
    }
    saturate(t) {
      return M(this._rgb, 1, t), this
    }
    desaturate(t) {
      return M(this._rgb, 1, -t), this
    }
    rotate(t) {
      return e = this._rgb, i = t, (t = w(e))[0] = k(t[0] + i), t = C(t), e.r = t[0], e.g = t[1], e.b = t[2], this;
      var e, i
    }
  }

  function L(t) {
    return new $(t)
  }
  const N = t => t instanceof CanvasGradient || t instanceof CanvasPattern;

  function H(t) {
    return N(t) ? t : L(t)
  }

  function F(t) {
    return N(t) ? t : L(t).saturate(.5).darken(.1).hexString()
  }

  function t() {}
  const z = function () {
    let t = 0;
    return function () {
      return t++
    }
  }();

  function R(t) {
    return null == t
  }

  function B(t) {
    if (Array.isArray && Array.isArray(t)) return !0;
    const e = Object.prototype.toString.call(t);
    return "[object" === e.substr(0, 7) && "Array]" === e.substr(-6)
  }

  function j(t) {
    return null !== t && "[object Object]" === Object.prototype.toString.call(t)
  }
  const W = t => ("number" == typeof t || t instanceof Number) && isFinite(+t);

  function V(t, e) {
    return W(t) ? t : e
  }

  function q(t, e) {
    return void 0 === t ? e : t
  }
  const Y = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : t / e,
    U = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t;

  function X(t, e, i) {
    if (t && "function" == typeof t.call) return t.apply(i, e)
  }

  function G(t, e, i, s) {
    let n, a, o;
    if (B(t))
      if (a = t.length, s)
        for (n = a - 1; 0 <= n; n--) e.call(i, t[n], n);
      else
        for (n = 0; n < a; n++) e.call(i, t[n], n);
    else if (j(t))
      for (o = Object.keys(t), a = o.length, n = 0; n < a; n++) e.call(i, t[o[n]], o[n])
  }

  function K(t, e) {
    let i, s, n, a;
    if (!t || !e || t.length !== e.length) return !1;
    for (i = 0, s = t.length; i < s; ++i)
      if (n = t[i], a = e[i], n.datasetIndex !== a.datasetIndex || n.index !== a.index) return !1;
    return !0
  }

  function Q(e) {
    if (B(e)) return e.map(Q);
    if (j(e)) {
      const i = Object.create(null),
        s = Object.keys(e),
        n = s.length;
      let t = 0;
      for (; t < n; ++t) i[s[t]] = Q(e[s[t]]);
      return i
    }
    return e
  }

  function J(t) {
    return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
  }

  function Z(t, e, i, s) {
    var n;
    J(t) && (n = e[t], i = i[t], j(n) && j(i) ? tt(n, i, s) : e[t] = Q(i))
  }

  function tt(i, s, n) {
    const e = B(s) ? s : [s],
      a = e.length;
    if (!j(i)) return i;
    const o = (n = n || {}).merger || Z;
    for (let t = 0; t < a; ++t)
      if (j(s = e[t])) {
        const a = Object.keys(s);
        for (let t = 0, e = a.length; t < e; ++t) o(a[t], i, s, n)
      } return i
  }

  function et(t, e) {
    return tt(t, e, {
      merger: it
    })
  }

  function it(t, e, i) {
    var s;
    J(t) && (s = e[t], i = i[t], j(s) && j(i) ? et(s, i) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = Q(i)))
  }

  function st(t, e) {
    e = t.indexOf(".", e);
    return -1 === e ? t.length : e
  }

  function nt(t, e) {
    if ("" === e) return t;
    let i = 0,
      s = st(e, i);
    for (; t && s > i;) t = t[e.substr(i, s - i)], i = s + 1, s = st(e, i);
    return t
  }

  function at(t) {
    return t.charAt(0).toUpperCase() + t.slice(1)
  }
  const ot = t => void 0 !== t,
    rt = t => "function" == typeof t,
    lt = (t, e) => {
      if (t.size !== e.size) return !1;
      for (const i of t)
        if (!e.has(i)) return !1;
      return !0
    },
    ct = Object.create(null),
    dt = Object.create(null);

  function ht(i, t) {
    if (!t) return i;
    var s = t.split(".");
    for (let t = 0, e = s.length; t < e; ++t) {
      var n = s[t];
      i = i[n] || (i[n] = Object.create(null))
    }
    return i
  }

  function ut(t, e, i) {
    return "string" == typeof e ? tt(ht(t, e), i) : tt(ht(t, ""), e)
  }
  var pt = new class {
    constructor(t) {
      this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      }, this.hover = {}, this.hoverBackgroundColor = (t, e) => F(e.backgroundColor), this.hoverBorderColor = (t, e) => F(e.borderColor), this.hoverColor = (t, e) => F(e.color), this.indexAxis = "x", this.interaction = {
        mode: "nearest",
        intersect: !0
      }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.describe(t)
    }
    set(t, e) {
      return ut(this, t, e)
    }
    get(t) {
      return ht(this, t)
    }
    describe(t, e) {
      return ut(dt, t, e)
    }
    override(t, e) {
      return ut(ct, t, e)
    }
    route(t, e, i, s) {
      const n = ht(this, t),
        a = ht(this, i),
        o = "_" + e;
      Object.defineProperties(n, {
        [o]: {
          value: n[e],
          writable: !0
        },
        [e]: {
          enumerable: !0,
          get() {
            var t = this[o],
              e = a[s];
            return j(t) ? Object.assign({}, e, t) : q(t, e)
          },
          set(t) {
            this[o] = t
          }
        }
      })
    }
  }({
    _scriptable: t => !t.startsWith("on"),
    _indexable: t => "events" !== t,
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: !1,
      _indexable: !1
    }
  });
  const ft = Math.PI,
    mt = 2 * ft,
    gt = mt + ft,
    vt = Number.POSITIVE_INFINITY,
    bt = ft / 180,
    _t = ft / 2,
    yt = ft / 4,
    wt = 2 * ft / 3,
    xt = Math.log10,
    Ct = Math.sign;

  function kt(t) {
    var e = Math.pow(10, Math.floor(xt(t))),
      t = t / e;
    return (t <= 1 ? 1 : t <= 2 ? 2 : t <= 5 ? 5 : 10) * e
  }

  function Tt(t) {
    const e = [],
      i = Math.sqrt(t);
    let s;
    for (s = 1; s < i; s++) t % s == 0 && (e.push(s), e.push(t / s));
    return i === (0 | i) && e.push(i), e.sort((t, e) => t - e).pop(), e
  }

  function Dt(t) {
    return !isNaN(parseFloat(t)) && isFinite(t)
  }

  function St(t, e, i) {
    return Math.abs(t - e) < i
  }

  function Mt(t, e) {
    var i = Math.round(t);
    return i - e <= t && t <= i + e
  }

  function Et(t, e, i) {
    let s, n, a;
    for (s = 0, n = t.length; s < n; s++) a = t[s][i], isNaN(a) || (e.min = Math.min(e.min, a), e.max = Math.max(e.max, a))
  }

  function At(t) {
    return t * (ft / 180)
  }

  function Pt(t) {
    return t * (180 / ft)
  }

  function It(i) {
    if (W(i)) {
      let t = 1,
        e = 0;
      for (; Math.round(i * t) / t !== i;) t *= 10, e++;
      return e
    }
  }

  function Ot(t, e) {
    var i = e.x - t.x,
      e = e.y - t.y,
      t = Math.sqrt(i * i + e * e);
    let s = Math.atan2(e, i);
    return s < -.5 * ft && (s += mt), {
      angle: s,
      distance: t
    }
  }

  function $t(t, e) {
    return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
  }

  function Lt(t, e) {
    return (t - e + gt) % mt - ft
  }

  function Nt(t) {
    return (t % mt + mt) % mt
  }

  function Ht(t, e, i) {
    var s = Nt(t),
      n = Nt(e),
      a = Nt(i),
      o = Nt(n - s),
      t = Nt(a - s),
      e = Nt(s - n),
      i = Nt(s - a);
    return s === n || s === a || t < o && e < i
  }

  function Ft(t, e, i) {
    return Math.max(e, Math.min(i, t))
  }

  function zt(t) {
    return Ft(t, -32768, 32767)
  }

  function Rt(t) {
    return !t || R(t.size) || R(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family
  }

  function Bt(t, e, i, s, n) {
    let a = e[n];
    return a || (a = e[n] = t.measureText(n).width, i.push(n)), s = a > s ? a : s
  }

  function jt(t, e, i, s) {
    let n = (s = s || {}).data = s.data || {},
      a = s.garbageCollect = s.garbageCollect || [];
    s.font !== e && (n = s.data = {}, a = s.garbageCollect = [], s.font = e), t.save(), t.font = e;
    let o = 0;
    var r = i.length;
    let l, c, d, h, u;
    for (l = 0; l < r; l++)
      if (null != (h = i[l]) && !0 !== B(h)) o = Bt(t, n, a, o, h);
      else if (B(h))
      for (c = 0, d = h.length; c < d; c++) null == (u = h[c]) || B(u) || (o = Bt(t, n, a, o, u));
    t.restore();
    var p = a.length / 2;
    if (p > i.length) {
      for (l = 0; l < p; l++) delete n[a[l]];
      a.splice(0, p)
    }
    return o
  }

  function Wt(t, e, i) {
    t = t.currentDevicePixelRatio, i = 0 !== i ? Math.max(i / 2, .5) : 0;
    return Math.round((e - i) * t) / t + i
  }

  function Vt(t, e) {
    (e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore()
  }

  function qt(t, e, i, s) {
    let n, a, o, r, l;
    const c = e.pointStyle,
      d = e.rotation,
      h = e.radius;
    let u = (d || 0) * bt;
    if (c && "object" == typeof c && ("[object HTMLImageElement]" === (n = c.toString()) || "[object HTMLCanvasElement]" === n)) return t.save(), t.translate(i, s), t.rotate(u), t.drawImage(c, -c.width / 2, -c.height / 2, c.width, c.height), void t.restore();
    if (!(isNaN(h) || h <= 0)) {
      switch (t.beginPath(), c) {
        default:
          t.arc(i, s, h, 0, mt), t.closePath();
          break;
        case "triangle":
          t.moveTo(i + Math.sin(u) * h, s - Math.cos(u) * h), u += wt, t.lineTo(i + Math.sin(u) * h, s - Math.cos(u) * h), u += wt, t.lineTo(i + Math.sin(u) * h, s - Math.cos(u) * h), t.closePath();
          break;
        case "rectRounded":
          l = .516 * h, r = h - l, a = Math.cos(u + yt) * r, o = Math.sin(u + yt) * r, t.arc(i - a, s - o, l, u - ft, u - _t), t.arc(i + o, s - a, l, u - _t, u), t.arc(i + a, s + o, l, u, u + _t), t.arc(i - o, s + a, l, u + _t, u + ft), t.closePath();
          break;
        case "rect":
          if (!d) {
            r = Math.SQRT1_2 * h, t.rect(i - r, s - r, 2 * r, 2 * r);
            break
          }
          u += yt;
        case "rectRot":
          a = Math.cos(u) * h, o = Math.sin(u) * h, t.moveTo(i - a, s - o), t.lineTo(i + o, s - a), t.lineTo(i + a, s + o), t.lineTo(i - o, s + a), t.closePath();
          break;
        case "crossRot":
          u += yt;
        case "cross":
          a = Math.cos(u) * h, o = Math.sin(u) * h, t.moveTo(i - a, s - o), t.lineTo(i + a, s + o), t.moveTo(i + o, s - a), t.lineTo(i - o, s + a);
          break;
        case "star":
          a = Math.cos(u) * h, o = Math.sin(u) * h, t.moveTo(i - a, s - o), t.lineTo(i + a, s + o), t.moveTo(i + o, s - a), t.lineTo(i - o, s + a), u += yt, a = Math.cos(u) * h, o = Math.sin(u) * h, t.moveTo(i - a, s - o), t.lineTo(i + a, s + o), t.moveTo(i + o, s - a), t.lineTo(i - o, s + a);
          break;
        case "line":
          a = Math.cos(u) * h, o = Math.sin(u) * h, t.moveTo(i - a, s - o), t.lineTo(i + a, s + o);
          break;
        case "dash":
          t.moveTo(i, s), t.lineTo(i + Math.cos(u) * h, s + Math.sin(u) * h)
      }
      t.fill(), 0 < e.borderWidth && t.stroke()
    }
  }

  function Yt(t, e, i) {
    return i = i || .5, t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i
  }

  function Ut(t, e) {
    t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()
  }

  function Xt(t) {
    t.restore()
  }

  function Gt(t, e, i, s, n) {
    if (!e) return t.lineTo(i.x, i.y);
    if ("middle" === n) {
      const s = (e.x + i.x) / 2;
      t.lineTo(s, e.y), t.lineTo(s, i.y)
    } else "after" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);
    t.lineTo(i.x, i.y)
  }

  function Kt(t, e, i, s) {
    if (!e) return t.lineTo(i.x, i.y);
    t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y)
  }

  function Qt(t, e, i, s, n, a = {}) {
    const o = B(e) ? e : [e],
      r = 0 < a.strokeWidth && "" !== a.strokeColor;
    let l, c;
    for (t.save(), a.translation && t.translate(a.translation[0], a.translation[1]), R(a.rotation) || t.rotate(a.rotation), t.font = n.string, a.color && (t.fillStyle = a.color), a.textAlign && (t.textAlign = a.textAlign), a.textBaseline && (t.textBaseline = a.textBaseline), l = 0; l < o.length; ++l) {
      if (c = o[l], r && (a.strokeColor && (t.strokeStyle = a.strokeColor), R(a.strokeWidth) || (t.lineWidth = a.strokeWidth), t.strokeText(c, i, s, a.maxWidth)), t.fillText(c, i, s, a.maxWidth), a.strikethrough || a.underline) {
        const e = t.measureText(c),
          n = i - e.actualBoundingBoxLeft,
          o = i + e.actualBoundingBoxRight,
          r = s - e.actualBoundingBoxAscent,
          l = s + e.actualBoundingBoxDescent,
          d = a.strikethrough ? (r + l) / 2 : l;
        t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = a.decorationWidth || 2, t.moveTo(n, d), t.lineTo(o, d), t.stroke()
      }
      s += n.lineHeight
    }
    t.restore()
  }

  function Jt(t, e) {
    var {
      x: i,
      y: s,
      w: n,
      h: a,
      radius: e
    } = e;
    t.arc(i + e.topLeft, s + e.topLeft, e.topLeft, -_t, ft, !0), t.lineTo(i, s + a - e.bottomLeft), t.arc(i + e.bottomLeft, s + a - e.bottomLeft, e.bottomLeft, ft, _t, !0), t.lineTo(i + n - e.bottomRight, s + a), t.arc(i + n - e.bottomRight, s + a - e.bottomRight, e.bottomRight, _t, 0, !0), t.lineTo(i + n, s + e.topRight), t.arc(i + n - e.topRight, s + e.topRight, e.topRight, 0, -_t, !0), t.lineTo(i + e.topLeft, s)
  }

  function Zt(e, i, t) {
    t = t || (t => e[t] < i);
    let s, n = e.length - 1,
      a = 0;
    for (; 1 < n - a;) t(s = a + n >> 1) ? a = s : n = s;
    return {
      lo: a,
      hi: n
    }
  }
  const te = (e, i, s) => Zt(e, s, t => e[t][i] < s),
    ee = (e, i, s) => Zt(e, s, t => e[t][i] >= s);

  function ie(t, e, i) {
    let s = 0,
      n = t.length;
    for (; s < n && t[s] < e;) s++;
    for (; n > s && t[n - 1] > i;) n--;
    return 0 < s || n < t.length ? t.slice(s, n) : t
  }
  const se = ["push", "pop", "shift", "splice", "unshift"];

  function ne(n, t) {
    n._chartjs ? n._chartjs.listeners.push(t) : (Object.defineProperty(n, "_chartjs", {
      configurable: !0,
      enumerable: !1,
      value: {
        listeners: [t]
      }
    }), se.forEach(t => {
      const i = "_onData" + at(t),
        s = n[t];
      Object.defineProperty(n, t, {
        configurable: !0,
        enumerable: !1,
        value(...e) {
          var t = s.apply(this, e);
          return n._chartjs.listeners.forEach(t => {
            "function" == typeof t[i] && t[i](...e)
          }), t
        }
      })
    }))
  }

  function ae(e, t) {
    var i = e._chartjs;
    if (i) {
      const s = i.listeners,
        n = s.indexOf(t); - 1 !== n && s.splice(n, 1), 0 < s.length || (se.forEach(t => {
        delete e[t]
      }), delete e._chartjs)
    }
  }

  function oe(t) {
    const e = new Set;
    let i, s;
    for (i = 0, s = t.length; i < s; ++i) e.add(t[i]);
    if (e.size === s) return t;
    const n = [];
    return e.forEach(t => {
      n.push(t)
    }), n
  }

  function re(t) {
    let e = t.parentNode;
    return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e
  }

  function le(t, e, i) {
    let s;
    return "string" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf("%") && (s = s / 100 * e.parentNode[i])) : s = t, s
  }
  const ce = t => window.getComputedStyle(t, null);

  function de(t, e) {
    return ce(t).getPropertyValue(e)
  }
  const he = ["top", "right", "bottom", "left"];

  function ue(e, i, s) {
    const n = {};
    s = s ? "-" + s : "";
    for (let t = 0; t < 4; t++) {
      var a = he[t];
      n[a] = parseFloat(e[i + "-" + a + s]) || 0
    }
    return n.width = n.left + n.right, n.height = n.top + n.bottom, n
  }

  function pe(t, e) {
    var {
      canvas: i,
      currentDevicePixelRatio: s
    } = e, n = ce(i), a = "border-box" === n.boxSizing, o = ue(n, "padding"), r = ue(n, "border", "width"), {
      x: l,
      y: c,
      box: n
    } = function (t, e) {
      var i = t.native || t,
        s = i.touches,
        n = s && s.length ? s[0] : i,
        {
          offsetX: t,
          offsetY: s
        } = n;
      let a, o, r = !1;
      if (i = i.target, !(0 < t || 0 < s) || i && i.shadowRoot) {
        const l = e.getBoundingClientRect();
        a = n.clientX - l.left, o = n.clientY - l.top, r = !0
      } else a = t, o = s;
      return {
        x: a,
        y: o,
        box: r
      }
    }(t, i), t = o.left + (n && r.left), n = o.top + (n && r.top);
    let {
      width: d,
      height: h
    } = e;
    return a && (d -= o.width + r.width, h -= o.height + r.height), {
      x: Math.round((l - t) / d * i.width / s),
      y: Math.round((c - n) / h * i.height / s)
    }
  }
  const fe = t => Math.round(10 * t) / 10;

  function me(t, e, i, s) {
    var n = ce(t),
      a = ue(n, "margin"),
      o = le(n.maxWidth, t, "clientWidth") || vt,
      r = le(n.maxHeight, t, "clientHeight") || vt,
      i = function (t, e, i) {
        let s, n;
        if (void 0 === e || void 0 === i) {
          const a = re(t);
          if (a) {
            const t = a.getBoundingClientRect(),
              o = ce(a),
              r = ue(o, "border", "width"),
              l = ue(o, "padding");
            e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = le(o.maxWidth, a, "clientWidth"), n = le(o.maxHeight, a, "clientHeight")
          } else e = t.clientWidth, i = t.clientHeight
        }
        return {
          width: e,
          height: i,
          maxWidth: s || vt,
          maxHeight: n || vt
        }
      }(t, e, i);
    let {
      width: l,
      height: c
    } = i;
    if ("content-box" === n.boxSizing) {
      const t = ue(n, "border", "width"),
        e = ue(n, "padding");
      l -= e.width + t.width, c -= e.height + t.height
    }
    return l = Math.max(0, l - a.width), c = Math.max(0, s ? Math.floor(l / s) : c - a.height), l = fe(Math.min(l, o, i.maxWidth)), c = fe(Math.min(c, r, i.maxHeight)), l && !c && (c = fe(l / 2)), {
      width: l,
      height: c
    }
  }

  function ge(t, e, i) {
    const s = t.currentDevicePixelRatio = e || 1,
      {
        canvas: n,
        width: a,
        height: o
      } = t;
    n.height = o * s, n.width = a * s, t.ctx.setTransform(s, 0, 0, s, 0, 0), n.style && (i || !n.style.height && !n.style.width) && (n.style.height = o + "px", n.style.width = a + "px")
  }
  var ve = function () {
    let t = !1;
    try {
      var e = {
        get passive() {
          return !(t = !0)
        }
      };
      window.addEventListener("test", null, e), window.removeEventListener("test", null, e)
    } catch (t) {}
    return t
  }();

  function be(t, e) {
    const i = de(t, e),
      s = i && i.match(/^(\d+)(\.\d+)?px$/);
    return s ? +s[1] : void 0
  }

  function _e(t, e) {
    return "native" in t ? {
      x: t.x,
      y: t.y
    } : pe(t, e)
  }

  function ye(t, i, s, n, a) {
    var o = t.getSortedVisibleDatasetMetas(),
      r = s[i];
    for (let t = 0, e = o.length; t < e; ++t) {
      const {
        index: s,
        data: l
      } = o[t], {
        lo: c,
        hi: d
      } = function (t, e, i, s) {
        const {
          controller: n,
          data: a,
          _sorted: o
        } = t, r = n._cachedMeta.iScale;
        if (r && e === r.axis && o && a.length) {
          const t = r._reversePixels ? ee : te;
          if (!s) return t(a, e, i);
          if (n._sharedOptions) {
            const s = a[0],
              n = "function" == typeof s.getRange && s.getRange(e);
            if (n) {
              const s = t(a, e, i - n),
                o = t(a, e, i + n);
              return {
                lo: s.lo,
                hi: o.hi
              }
            }
          }
        }
        return {
          lo: 0,
          hi: a.length - 1
        }
      }(o[t], i, r, a);
      for (let t = c; t <= d; ++t) {
        const i = l[t];
        i.skip || n(i, s, t)
      }
    }
  }

  function we(t, s, e, n) {
    const a = [];
    return Yt(s, t.chartArea, t._minPadding) && ye(t, e, s, function (t, e, i) {
      t.inRange(s.x, s.y, n) && a.push({
        element: t,
        datasetIndex: e,
        index: i
      })
    }, !0), a
  }

  function xe(t, n, e, a, o) {
    const r = function (t) {
      const s = -1 !== t.indexOf("x"),
        n = -1 !== t.indexOf("y");
      return function (t, e) {
        var i = s ? Math.abs(t.x - e.x) : 0,
          e = n ? Math.abs(t.y - e.y) : 0;
        return Math.sqrt(Math.pow(i, 2) + Math.pow(e, 2))
      }
    }(e);
    let l = Number.POSITIVE_INFINITY,
      c = [];
    return Yt(n, t.chartArea, t._minPadding) && ye(t, e, n, function (t, e, i) {
      var s;
      a && !t.inRange(n.x, n.y, o) || (s = t.getCenterPoint(o), (s = r(n, s)) < l ? (c = [{
        element: t,
        datasetIndex: e,
        index: i
      }], l = s) : s === l && c.push({
        element: t,
        datasetIndex: e,
        index: i
      }))
    }), c
  }

  function Ce(t, e, i, l) {
    const c = _e(e, t),
      d = [],
      h = i.axis,
      u = "x" === h ? "inXRange" : "inYRange";
    let p = !1;
    return function () {
      var i, s, n, a, o, r = t.getSortedVisibleDatasetMetas();
      for (let t = 0, e = r.length; t < e; ++t) {
        ({
          index: i,
          data: s
        } = r[t]);
        for (let t = 0, e = s.length; t < e; ++t)(o = s[t]).skip || (n = o, a = i, o = t, n[u](c[h], l) && d.push({
          element: n,
          datasetIndex: a,
          index: o
        }), n.inRange(c.x, c.y, l) && (p = !0))
      }
    }(), i.intersect && !p ? [] : d
  }
  var ke = {
    modes: {
      index(t, e, i, s) {
        const n = _e(e, t),
          a = i.axis || "x",
          o = i.intersect ? we(t, n, a, s) : xe(t, n, a, !1, s),
          r = [];
        return o.length ? (t.getSortedVisibleDatasetMetas().forEach(t => {
          var e = o[0].index,
            i = t.data[e];
          i && !i.skip && r.push({
            element: i,
            datasetIndex: t.index,
            index: e
          })
        }), r) : []
      },
      dataset(t, e, i, s) {
        var n = _e(e, t),
          e = i.axis || "xy";
        let a = i.intersect ? we(t, n, e, s) : xe(t, n, e, !1, s);
        if (0 < a.length) {
          const o = a[0].datasetIndex,
            i = t.getDatasetMeta(o).data;
          a = [];
          for (let t = 0; t < i.length; ++t) a.push({
            element: i[t],
            datasetIndex: o,
            index: t
          })
        }
        return a
      },
      point: (t, e, i, s) => we(t, _e(e, t), i.axis || "xy", s),
      nearest: (t, e, i, s) => xe(t, _e(e, t), i.axis || "xy", i.intersect, s),
      x: (t, e, i, s) => (i.axis = "x", Ce(t, e, i, s)),
      y: (t, e, i, s) => (i.axis = "y", Ce(t, e, i, s))
    }
  };
  const Te = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),
    De = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);

  function Se(t, e) {
    var i = ("" + t).match(Te);
    if (!i || "normal" === i[1]) return 1.2 * e;
    switch (t = +i[2], i[3]) {
      case "px":
        return t;
      case "%":
        t /= 100
    }
    return e * t
  }

  function Me(e, i) {
    const t = {},
      s = j(i),
      n = s ? Object.keys(i) : i,
      a = j(e) ? s ? t => q(e[t], e[i[t]]) : t => e[t] : () => e;
    for (const e of n) t[e] = +a(e) || 0;
    return t
  }

  function Ee(t) {
    return Me(t, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    })
  }

  function Ae(t) {
    return Me(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
  }

  function Pe(t) {
    const e = Ee(t);
    return e.width = e.left + e.right, e.height = e.top + e.bottom, e
  }

  function Ie(t, e) {
    e = e || pt.font;
    let i = q((t = t || {}).size, e.size);
    "string" == typeof i && (i = parseInt(i, 10));
    let s = q(t.style, e.style);
    s && !("" + s).match(De) && (console.warn('Invalid font style specified: "' + s + '"'), s = "");
    const n = {
      family: q(t.family, e.family),
      lineHeight: Se(q(t.lineHeight, e.lineHeight), i),
      size: i,
      style: s,
      weight: q(t.weight, e.weight),
      string: ""
    };
    return n.string = Rt(n), n
  }

  function Oe(t, e, i, s) {
    let n, a, o, r = !0;
    for (n = 0, a = t.length; n < a; ++n)
      if (o = t[n], void 0 !== o && (void 0 !== e && "function" == typeof o && (o = o(e), r = !1), void 0 !== i && B(o) && (o = o[i % o.length], r = !1), void 0 !== o)) return s && !r && (s.cacheable = !1), o
  }

  function $e(t, e) {
    var {
      min: i,
      max: t
    } = t;
    return {
      min: i - Math.abs(U(e, i)),
      max: t + U(e, t)
    }
  }
  const Le = ["left", "top", "right", "bottom"];

  function Ne(t, e) {
    return t.filter(t => t.pos === e)
  }

  function He(t, e) {
    return t.filter(t => -1 === Le.indexOf(t.pos) && t.box.axis === e)
  }

  function Fe(t, s) {
    return t.sort((t, e) => {
      var i = s ? e : t,
        e = s ? t : e;
      return i.weight === e.weight ? i.index - e.index : i.weight - e.weight
    })
  }

  function ze(t, e, i, s) {
    return Math.max(t[i], e[i]) + Math.max(t[s], e[s])
  }

  function Re(t, e) {
    t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right)
  }

  function Be(t, i) {
    const s = i.maxPadding;
    return function (t) {
      const e = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      return t.forEach(t => {
        e[t] = Math.max(i[t], s[t])
      }), e
    }(t ? ["left", "right"] : ["top", "bottom"])
  }

  function je(t, e, i) {
    const s = [];
    let n, a, o, r, l, c;
    for (n = 0, a = t.length, l = 0; n < a; ++n) {
      o = t[n], r = o.box, r.update(o.width || e.w, o.height || e.h, Be(o.horizontal, e));
      const {
        same: a,
        other: d
      } = function (t, e, i) {
        const s = i.box,
          n = t.maxPadding;
        j(i.pos) || (i.size && (t[i.pos] -= i.size), i.size = i.horizontal ? s.height : s.width, t[i.pos] += i.size), s.getPadding && Re(n, s.getPadding());
        var a = Math.max(0, e.outerWidth - ze(n, t, "left", "right")),
          o = Math.max(0, e.outerHeight - ze(n, t, "top", "bottom")),
          r = a !== t.w,
          e = o !== t.h;
        return t.w = a, t.h = o, i.horizontal ? {
          same: r,
          other: e
        } : {
          same: e,
          other: r
        }
      }(e, i, o);
      l |= a && s.length, c = c || d, r.fullSize || s.push(o)
    }
    return l && je(s, e, i) || c
  }

  function We(t, e, i) {
    var s = i.padding;
    let n, a, o, r, l = e.x,
      c = e.y;
    for (n = 0, a = t.length; n < a; ++n) o = t[n], r = o.box, o.horizontal ? (r.left = (r.fullSize ? s : e).left, r.right = r.fullSize ? i.outerWidth - s.right : e.left + e.w, r.top = c, r.bottom = c + r.height, r.width = r.right - r.left, c = r.bottom) : (r.left = l, r.right = l + r.width, r.top = (r.fullSize ? s : e).top, r.bottom = r.fullSize ? i.outerHeight - s.right : e.top + e.h, r.height = r.bottom - r.top, l = r.right);
    e.x = l, e.y = c
  }
  pt.set("layout", {
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
  var Ve = {
    addBox(t, e) {
      t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () {
        return [{
          z: 0,
          draw(t) {
            e.draw(t)
          }
        }]
      }, t.boxes.push(e)
    },
    removeBox(t, e) {
      e = t.boxes ? t.boxes.indexOf(e) : -1; - 1 !== e && t.boxes.splice(e, 1)
    },
    configure(t, e, i) {
      e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight
    },
    update(l, t, e, i) {
      if (l) {
        const n = Pe(l.options.layout.padding),
          a = t - n.width,
          o = e - n.height,
          r = function () {
            const t = function (t) {
                const e = [];
                let i, s, n;
                for (i = 0, s = (t || []).length; i < s; ++i) n = t[i], e.push({
                  index: i,
                  box: n,
                  pos: n.position,
                  horizontal: n.isHorizontal(),
                  weight: n.weight
                });
                return e
              }(l.boxes),
              e = Fe(t.filter(t => t.box.fullSize), !0),
              i = Fe(Ne(t, "left"), !0),
              s = Fe(Ne(t, "right")),
              n = Fe(Ne(t, "top"), !0),
              a = Fe(Ne(t, "bottom")),
              o = He(t, "x"),
              r = He(t, "y");
            return {
              fullSize: e,
              leftAndTop: i.concat(n),
              rightAndBottom: s.concat(r).concat(a).concat(o),
              chartArea: Ne(t, "chartArea"),
              vertical: i.concat(s).concat(r),
              horizontal: n.concat(a).concat(o)
            }
          }(),
          c = r.vertical,
          d = r.horizontal;
        G(l.boxes, t => {
          "function" == typeof t.beforeLayout && t.beforeLayout()
        });
        var s = c.reduce((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1,
          e = Object.freeze({
            outerWidth: t,
            outerHeight: e,
            padding: n,
            availableWidth: a,
            availableHeight: o,
            vBoxMaxWidth: a / 2 / s,
            hBoxMaxHeight: o / 2
          }),
          s = Object.assign({}, n);
        Re(s, Pe(i));
        const h = Object.assign({
          maxPadding: s,
          w: a,
          h: o,
          x: n.left,
          y: n.top
        }, n);
        ! function (t, e) {
          let i, s, n;
          for (i = 0, s = t.length; i < s; ++i) n = t[i], n.horizontal ? (n.width = n.box.fullSize && e.availableWidth, n.height = e.hBoxMaxHeight) : (n.width = e.vBoxMaxWidth, n.height = n.box.fullSize && e.availableHeight)
        }(c.concat(d), e), je(r.fullSize, h, e), je(c, h, e), je(d, h, e) && je(c, h, e),
          function (i) {
            const s = i.maxPadding;

            function t(t) {
              var e = Math.max(s[t] - i[t], 0);
              return i[t] += e, e
            }
            i.y += t("top"), i.x += t("left"), t("right"), t("bottom")
          }(h), We(r.leftAndTop, h, e), h.x += h.w, h.y += h.h, We(r.rightAndBottom, h, e), l.chartArea = {
            left: h.left,
            top: h.top,
            right: h.left + h.w,
            bottom: h.top + h.h,
            height: h.h,
            width: h.w
          }, G(r.chartArea, t => {
            const e = t.box;
            Object.assign(e, l.chartArea), e.update(h.w, h.h)
          })
      }
    }
  };
  class qe {
    acquireContext(t, e) {}
    releaseContext(t) {
      return !1
    }
    addEventListener(t, e, i) {}
    removeEventListener(t, e, i) {}
    getDevicePixelRatio() {
      return 1
    }
    getMaximumSize(t, e, i, s) {
      return e = Math.max(0, e || t.width), i = i || t.height, {
        width: e,
        height: Math.max(0, s ? Math.floor(e / s) : i)
      }
    }
    isAttached(t) {
      return !0
    }
  }
  class Ye extends qe {
    acquireContext(t) {
      return t && t.getContext && t.getContext("2d") || null
    }
  }
  const Ue = {
      touchstart: "mousedown",
      touchmove: "mousemove",
      touchend: "mouseup",
      pointerenter: "mouseenter",
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointerleave: "mouseout",
      pointerout: "mouseout"
    },
    Xe = t => null === t || "" === t,
    Ge = !!ve && {
      passive: !0
    };

  function Ke(t, e, n) {
    const i = t.canvas,
      a = i && re(i) || i,
      s = new MutationObserver(t => {
        const s = re(a);
        t.forEach(e => {
          for (let t = 0; t < e.addedNodes.length; t++) {
            var i = e.addedNodes[t];
            i !== a && i !== s || n(e.target)
          }
        })
      });
    return s.observe(document, {
      childList: !0,
      subtree: !0
    }), s
  }

  function Qe(t, e, i) {
    const s = t.canvas,
      n = s && re(s);
    if (n) {
      const a = new MutationObserver(t => {
        t.forEach(e => {
          for (let t = 0; t < e.removedNodes.length; t++)
            if (e.removedNodes[t] === s) {
              i();
              break
            }
        })
      });
      return a.observe(n, {
        childList: !0
      }), a
    }
  }
  const Je = new Map;
  let Ze = 0;

  function ti() {
    const i = window.devicePixelRatio;
    i !== Ze && (Ze = i, Je.forEach((t, e) => {
      e.currentDevicePixelRatio !== i && t()
    }))
  }

  function ei(t, e, s) {
    const i = t.canvas,
      n = i && re(i);
    if (n) {
      const o = l((t, e) => {
          var i = n.clientWidth;
          s(t, e), i < n.clientWidth && s()
        }, window),
        r = new ResizeObserver(t => {
          var e = t[0],
            t = e.contentRect.width,
            e = e.contentRect.height;
          0 === t && 0 === e || o(t, e)
        });
      return r.observe(n), a = t, t = o, Je.size || window.addEventListener("resize", ti), Je.set(a, t), r;
      var a
    }
  }

  function ii(t, e, i) {
    i && i.disconnect(), "resize" === e && (t = t, Je.delete(t), Je.size || window.removeEventListener("resize", ti))
  }

  function si(e, t, i) {
    var s = e.canvas,
      n = l(t => {
        null !== e.ctx && i(function (t, e) {
          var i = Ue[t.type] || t.type,
            {
              x: s,
              y: n
            } = pe(t, e);
          return {
            type: i,
            chart: e,
            native: t,
            x: void 0 !== s ? s : null,
            y: void 0 !== n ? n : null
          }
        }(t, e))
      }, e, t => {
        t = t[0];
        return [t, t.offsetX, t.offsetY]
      });
    return s.addEventListener(t, n, Ge), n
  }
  class ni extends qe {
    acquireContext(t, e) {
      var i = t && t.getContext && t.getContext("2d");
      return i && i.canvas === t ? (function (t, e) {
        const i = t.style,
          s = t.getAttribute("height"),
          n = t.getAttribute("width");
        if (t.$chartjs = {
            initial: {
              height: s,
              width: n,
              style: {
                display: i.display,
                height: i.height,
                width: i.width
              }
            }
          }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", Xe(n)) {
          const e = be(t, "width");
          void 0 !== e && (t.width = e)
        }
        if (Xe(s))
          if ("" === t.style.height) t.height = t.width / (e || 2);
          else {
            const e = be(t, "height");
            void 0 !== e && (t.height = e)
          }
      }(t, e), i) : null
    }
    releaseContext(t) {
      const i = t.canvas;
      if (!i.$chartjs) return !1;
      const s = i.$chartjs.initial;
      ["height", "width"].forEach(t => {
        var e = s[t];
        R(e) ? i.removeAttribute(t) : i.setAttribute(t, e)
      });
      const e = s.style || {};
      return Object.keys(e).forEach(t => {
        i.style[t] = e[t]
      }), i.width = i.width, delete i.$chartjs, !0
    }
    addEventListener(t, e, i) {
      this.removeEventListener(t, e);
      const s = t.$proxies || (t.$proxies = {}),
        n = {
          attach: Ke,
          detach: Qe,
          resize: ei
        } [e] || si;
      s[e] = n(t, e, i)
    }
    removeEventListener(t, e) {
      const i = t.$proxies || (t.$proxies = {}),
        s = i[e];
      s && (({
        attach: ii,
        detach: ii,
        resize: ii
      } [e] || function (t, e, i) {
        t.canvas.removeEventListener(e, i, Ge)
      })(t, e, s), i[e] = void 0)
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio
    }
    getMaximumSize(t, e, i, s) {
      return me(t, e, i, s)
    }
    isAttached(t) {
      t = re(t);
      return !(!t || !re(t))
    }
  }
  var ai = Object.freeze({
    __proto__: null,
    BasePlatform: qe,
    BasicPlatform: Ye,
    DomPlatform: ni
  });
  const oi = t => 0 === t || 1 === t,
    ri = (t, e, i) => -Math.pow(2, 10 * --t) * Math.sin((t - e) * mt / i),
    li = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * mt / i) + 1,
    ci = {
      linear: t => t,
      easeInQuad: t => t * t,
      easeOutQuad: t => -t * (t - 2),
      easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
      easeInCubic: t => t * t * t,
      easeOutCubic: t => --t * t * t + 1,
      easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
      easeInQuart: t => t * t * t * t,
      easeOutQuart: t => -(--t * t * t * t - 1),
      easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
      easeInQuint: t => t * t * t * t * t,
      easeOutQuint: t => --t * t * t * t * t + 1,
      easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
      easeInSine: t => 1 - Math.cos(t * _t),
      easeOutSine: t => Math.sin(t * _t),
      easeInOutSine: t => -.5 * (Math.cos(ft * t) - 1),
      easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)),
      easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t),
      easeInOutExpo: t => oi(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),
      easeInCirc: t => 1 <= t ? t : -(Math.sqrt(1 - t * t) - 1),
      easeOutCirc: t => Math.sqrt(1 - --t * t),
      easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
      easeInElastic: t => oi(t) ? t : ri(t, .075, .3),
      easeOutElastic: t => oi(t) ? t : li(t, .075, .3),
      easeInOutElastic(t) {
        return oi(t) ? t : t < .5 ? .5 * ri(2 * t, .1125, .45) : .5 + .5 * li(2 * t - 1, .1125, .45)
      },
      easeInBack(t) {
        return t * t * (2.70158 * t - 1.70158)
      },
      easeOutBack(t) {
        return --t * t * (2.70158 * t + 1.70158) + 1
      },
      easeInOutBack(t) {
        let e = 1.70158;
        return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
      },
      easeInBounce: t => 1 - ci.easeOutBounce(1 - t),
      easeOutBounce(t) {
        var e = 7.5625;
        return t < 1 / 2.75 ? e * t * t : t < 2 / 2.75 ? e * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? e * (t -= 2.25 / 2.75) * t + .9375 : e * (t -= 2.625 / 2.75) * t + .984375
      },
      easeInOutBounce: t => t < .5 ? .5 * ci.easeInBounce(2 * t) : .5 * ci.easeOutBounce(2 * t - 1) + .5
    },
    di = "transparent",
    hi = {
      boolean: (t, e, i) => .5 < i ? e : t,
      color(t, e, i) {
        const s = H(t || di),
          n = s.valid && H(e || di);
        return n && n.valid ? n.mix(s, i).hexString() : e
      },
      number: (t, e, i) => t + (e - t) * i
    };
  class ui {
    constructor(t, e, i, s) {
      var n = e[i];
      s = Oe([t.to, s, n, t.from]);
      n = Oe([t.from, n, s]);
      this._active = !0, this._fn = t.fn || hi[t.type || typeof n], this._easing = ci[t.easing] || ci.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = n, this._to = s, this._promises = void 0
    }
    active() {
      return this._active
    }
    update(t, e, i) {
      var s, n, a, o = this;
      o._active && (o._notify(!1), s = o._target[o._prop], n = i - o._start, a = o._duration - n, o._start = i, o._duration = Math.floor(Math.max(a, t.duration)), o._total += n, o._loop = !!t.loop, o._to = Oe([t.to, e, s, t.from]), o._from = Oe([t.from, s, e]))
    }
    cancel() {
      this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1))
    }
    tick(t) {
      var e = this,
        i = t - e._start,
        s = e._duration,
        n = e._prop,
        a = e._from,
        o = e._loop,
        t = e._to;
      let r;
      if (e._active = a !== t && (o || i < s), !e._active) return e._target[n] = t, void e._notify(!0);
      i < 0 ? e._target[n] = a : (r = i / s % 2, r = o && 1 < r ? 2 - r : r, r = e._easing(Math.min(1, Math.max(0, r))), e._target[n] = e._fn(a, t, r))
    }
    wait() {
      const i = this._promises || (this._promises = []);
      return new Promise((t, e) => {
        i.push({
          res: t,
          rej: e
        })
      })
    }
    _notify(t) {
      const e = t ? "res" : "rej",
        i = this._promises || [];
      for (let t = 0; t < i.length; t++) i[t][e]()
    }
  }
  pt.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  const pi = Object.keys(pt.animation);
  pt.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t
  }), pt.set("animations", {
    colors: {
      type: "color",
      properties: ["color", "borderColor", "backgroundColor"]
    },
    numbers: {
      type: "number",
      properties: ["x", "y", "borderWidth", "radius", "tension"]
    }
  }), pt.describe("animations", {
    _fallback: "animation"
  }), pt.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: t => 0 | t
        }
      }
    }
  });
  class fi {
    constructor(t, e) {
      this._chart = t, this._properties = new Map, this.configure(e)
    }
    configure(s) {
      if (j(s)) {
        const n = this._properties;
        Object.getOwnPropertyNames(s).forEach(e => {
          const t = s[e];
          if (j(t)) {
            const i = {};
            for (const s of pi) i[s] = t[s];
            (B(t.properties) && t.properties || [e]).forEach(t => {
              t !== e && n.has(t) || n.set(t, i)
            })
          }
        })
      }
    }
    _animateOptions(t, e) {
      const i = e.options,
        s = function (e, i) {
          if (i) {
            let t = e.options;
            if (t) return t.$shared && (e.options = t = Object.assign({}, t, {
              $shared: !1,
              $animations: {}
            })), t;
            e.options = i
          }
        }(t, i);
      if (!s) return [];
      e = this._createAnimations(s, i);
      return i.$shared && function (e, t) {
        const i = [],
          s = Object.keys(t);
        for (let t = 0; t < s.length; t++) {
          const n = e[s[t]];
          n && n.active() && i.push(n.wait())
        }
        return Promise.all(i)
      }(t.options.$animations, i).then(() => {
        t.options = i
      }, () => {}), e
    }
    _createAnimations(e, i) {
      const s = this._properties,
        n = [],
        a = e.$animations || (e.$animations = {}),
        t = Object.keys(i),
        o = Date.now();
      let r;
      for (r = t.length - 1; 0 <= r; --r) {
        const d = t[r];
        if ("$" !== d.charAt(0))
          if ("options" !== d) {
            var l = i[d];
            let t = a[d];
            var c = s.get(d);
            if (t) {
              if (c && t.active()) {
                t.update(c, l, o);
                continue
              }
              t.cancel()
            }
            c && c.duration ? (a[d] = t = new ui(c, e, d, l), n.push(t)) : e[d] = l
          } else n.push(...this._animateOptions(e, i))
      }
      return n
    }
    update(t, e) {
      if (0 !== this._properties.size) {
        var i = this._createAnimations(t, e);
        return i.length ? (c.add(this._chart, i), !0) : void 0
      }
      Object.assign(t, e)
    }
  }

  function mi(t, e) {
    var i = t && t.options || {},
      s = i.reverse,
      t = void 0 === i.min ? e : 0,
      e = void 0 === i.max ? e : 0;
    return {
      start: s ? e : t,
      end: s ? t : e
    }
  }

  function gi(t, e) {
    const i = [],
      s = t._getSortedDatasetMetas(e);
    let n, a;
    for (n = 0, a = s.length; n < a; ++n) i.push(s[n].index);
    return i
  }

  function vi(t, e, i, s) {
    var n = t.keys,
      a = "single" === s.mode;
    let o, r, l, c;
    if (null !== e) {
      for (o = 0, r = n.length; o < r; ++o) {
        if ((l = +n[o]) === i) {
          if (s.all) continue;
          break
        }
        c = t.values[l], W(c) && (a || 0 === e || Ct(e) === Ct(c)) && (e += c)
      }
      return e
    }
  }

  function bi(t, e) {
    t = t && t.options.stacked;
    return t || void 0 === t && void 0 !== e.stack
  }

  function _i(t, e, i) {
    for (const s of e.getMatchingVisibleMetas("bar").reverse()) {
      const e = t[s.index];
      if (i && 0 < e || !i && e < 0) return s.index
    }
    return null
  }

  function yi(t, e) {
    const {
      chart: i,
      _cachedMeta: s
    } = t, n = i._stacks || (i._stacks = {}), {
      iScale: a,
      vScale: o,
      index: r
    } = s, l = a.axis, c = o.axis, d = (u = a, t = s, `${u.id}.${o.id}.${t.stack||t.type}`), h = e.length;
    var u;
    let p;
    for (let t = 0; t < h; ++t) {
      const i = e[t],
        {
          [l]: s,
          [c]: a
        } = i;
      p = (i._stacks || (i._stacks = {}))[c] = function (t, e, i) {
        const s = t[e] || (t[e] = {});
        return s[i] || (s[i] = {})
      }(n, d, s), p[r] = a, p._top = _i(p, o, !0), p._bottom = _i(p, o, !1)
    }
  }

  function wi(t, e) {
    const i = t.scales;
    return Object.keys(i).filter(t => i[t].axis === e).shift()
  }

  function xi(t, e) {
    for (const i of e = e || t._parsed) {
      const e = i._stacks;
      if (!e || void 0 === e[t.vScale.id] || void 0 === e[t.vScale.id][t.index]) return;
      delete e[t.vScale.id][t.index]
    }
  }
  const Ci = t => "reset" === t || "none" === t,
    ki = (t, e) => e ? t : Object.assign({}, t);
  class Ti {
    constructor(t, e) {
      this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.$context = void 0, this.initialize()
    }
    initialize() {
      const t = this._cachedMeta;
      this.configure(), this.linkScales(), t._stacked = bi(t.vScale, t), this.addElements()
    }
    updateIndex(t) {
      this.index = t
    }
    linkScales() {
      const t = this.chart,
        e = this._cachedMeta,
        i = this.getDataset(),
        s = (t, e, i, s) => "x" === t ? e : "r" === t ? s : i,
        n = e.xAxisID = q(i.xAxisID, wi(t, "x")),
        a = e.yAxisID = q(i.yAxisID, wi(t, "y")),
        o = e.rAxisID = q(i.rAxisID, wi(t, "r")),
        r = e.indexAxis,
        l = e.iAxisID = s(r, n, a, o),
        c = e.vAxisID = s(r, a, n, o);
      e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(a), e.rScale = this.getScaleForId(o), e.iScale = this.getScaleForId(l), e.vScale = this.getScaleForId(c)
    }
    getDataset() {
      return this.chart.data.datasets[this.index]
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index)
    }
    getScaleForId(t) {
      return this.chart.scales[t]
    }
    _getOtherScale(t) {
      var e = this._cachedMeta;
      return t === e.iScale ? e.vScale : e.iScale
    }
    reset() {
      this._update("reset")
    }
    _destroy() {
      var t = this._cachedMeta;
      this._data && ae(this._data, this), t._stacked && xi(t)
    }
    _dataCheck() {
      const t = this.getDataset(),
        e = t.data || (t.data = []);
      j(e) ? this._data = function (t) {
        const e = Object.keys(t),
          i = new Array(e.length);
        let s, n, a;
        for (s = 0, n = e.length; s < n; ++s) a = e[s], i[s] = {
          x: a,
          y: t[a]
        };
        return i
      }(e) : this._data !== e && (this._data && (ae(this._data, this), xi(this._cachedMeta)), e && Object.isExtensible(e) && ne(e, this), this._data = e)
    }
    addElements() {
      const t = this._cachedMeta;
      this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType)
    }
    buildOrUpdateElements(t) {
      const e = this._cachedMeta,
        i = this.getDataset();
      let s = !1;
      this._dataCheck(), e._stacked = bi(e.vScale, e), e.stack !== i.stack && (s = !0, xi(e), e.stack = i.stack), this._resyncElements(t), s && yi(this, e._parsed)
    }
    configure() {
      const t = this.chart.config,
        e = t.datasetScopeKeys(this._type),
        i = t.getOptionScopes(this.getDataset(), e, !0);
      this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing
    }
    parse(t, e) {
      const {
        _cachedMeta: i,
        _data: s
      } = this, {
        iScale: n,
        _stacked: a
      } = i, o = n.axis;
      let r, l, c, d = 0 === t && e === s.length || i._sorted,
        h = 0 < t && i._parsed[t - 1];
      if (!1 === this._parsing) i._parsed = s, i._sorted = !0, c = s;
      else {
        c = B(s[t]) ? this.parseArrayData(i, s, t, e) : j(s[t]) ? this.parseObjectData(i, s, t, e) : this.parsePrimitiveData(i, s, t, e);
        const n = () => null === l[o] || h && l[o] < h[o];
        for (r = 0; r < e; ++r) i._parsed[r + t] = l = c[r], d && (n() && (d = !1), h = l);
        i._sorted = d
      }
      a && yi(this, c)
    }
    parsePrimitiveData(t, e, i, s) {
      const {
        iScale: n,
        vScale: a
      } = t, o = n.axis, r = a.axis, l = n.getLabels(), c = n === a, d = new Array(s);
      let h, u, p;
      for (h = 0, u = s; h < u; ++h) p = h + i, d[h] = {
        [o]: c || n.parse(l[p], p),
        [r]: a.parse(e[p], p)
      };
      return d
    }
    parseArrayData(t, e, i, s) {
      const {
        xScale: n,
        yScale: a
      } = t, o = new Array(s);
      let r, l, c, d;
      for (r = 0, l = s; r < l; ++r) d = e[c = r + i], o[r] = {
        x: n.parse(d[0], c),
        y: a.parse(d[1], c)
      };
      return o
    }
    parseObjectData(t, e, i, s) {
      const {
        xScale: n,
        yScale: a
      } = t, {
        xAxisKey: o = "x",
        yAxisKey: r = "y"
      } = this._parsing, l = new Array(s);
      let c, d, h, u;
      for (c = 0, d = s; c < d; ++c) u = e[h = c + i], l[c] = {
        x: n.parse(nt(u, o), h),
        y: a.parse(nt(u, r), h)
      };
      return l
    }
    getParsed(t) {
      return this._cachedMeta._parsed[t]
    }
    getDataElement(t) {
      return this._cachedMeta.data[t]
    }
    applyStack(t, e, i) {
      var s = this.chart,
        n = this._cachedMeta,
        a = e[t.axis];
      return vi({
        keys: gi(s, !0),
        values: e._stacks[t.axis]
      }, a, n.index, {
        mode: i
      })
    }
    updateRangeFromParsed(t, e, i, s) {
      var n = i[e.axis];
      let a = null === n ? NaN : n;
      e = s && i._stacks[e.axis];
      s && e && (s.values = e, t.min = Math.min(t.min, a), t.max = Math.max(t.max, a), a = vi(s, n, this._cachedMeta.index, {
        all: !0
      })), t.min = Math.min(t.min, a), t.max = Math.max(t.max, a)
    }
    getMinMax(t, e) {
      const i = this._cachedMeta,
        s = i._parsed,
        n = i._sorted && t === i.iScale,
        a = s.length,
        o = this._getOtherScale(t),
        r = e && i._stacked && {
          keys: gi(this.chart, !0),
          values: null
        },
        l = {
          min: Number.POSITIVE_INFINITY,
          max: Number.NEGATIVE_INFINITY
        },
        {
          min: c,
          max: d
        } = function () {
          var {
            min: t,
            max: e,
            minDefined: i,
            maxDefined: s
          } = o.getUserBounds();
          return {
            min: i ? t : Number.NEGATIVE_INFINITY,
            max: s ? e : Number.POSITIVE_INFINITY
          }
        }();
      let h, u, p, f;

      function m() {
        return p = s[h], u = p[t.axis], f = p[o.axis], !W(u) || c > f || d < f
      }
      for (h = 0; h < a && (m() || (this.updateRangeFromParsed(l, t, p, r), !n)); ++h);
      if (n)
        for (h = a - 1; 0 <= h; --h)
          if (!m()) {
            this.updateRangeFromParsed(l, t, p, r);
            break
          } return l
    }
    getAllParsedValues(t) {
      const e = this._cachedMeta._parsed,
        i = [];
      let s, n, a;
      for (s = 0, n = e.length; s < n; ++s) a = e[s][t.axis], W(a) && i.push(a);
      return i
    }
    getMaxOverflow() {
      return !1
    }
    getLabelAndValue(t) {
      const e = this._cachedMeta,
        i = e.iScale,
        s = e.vScale,
        n = this.getParsed(t);
      return {
        label: i ? "" + i.getLabelForValue(n[i.axis]) : "",
        value: s ? "" + s.getLabelForValue(n[s.axis]) : ""
      }
    }
    _update(t) {
      const e = this._cachedMeta;
      this.configure(), this._cachedDataOpts = {}, this.update(t || "default"), e._clip = function (t) {
        let e, i, s, n;
        return j(t) ? (e = t.top, i = t.right, s = t.bottom, n = t.left) : e = i = s = n = t, {
          top: e,
          right: i,
          bottom: s,
          left: n
        }
      }(q(this.options.clip, function (t, e, i) {
        if (!1 === i) return !1;
        t = mi(t, i), i = mi(e, i);
        return {
          top: i.end,
          right: t.end,
          bottom: i.start,
          left: t.start
        }
      }(e.xScale, e.yScale, this.getMaxOverflow())))
    }
    update(t) {}
    draw() {
      const t = this,
        e = t._ctx,
        i = t.chart,
        s = t._cachedMeta,
        n = s.data || [],
        a = i.chartArea,
        o = [],
        r = t._drawStart || 0,
        l = t._drawCount || n.length - r;
      let c;
      for (s.dataset && s.dataset.draw(e, a, r, l), c = r; c < r + l; ++c) {
        const t = n[c];
        t.active ? o.push(t) : t.draw(e, a)
      }
      for (c = 0; c < o.length; ++c) o[c].draw(e, a)
    }
    getStyle(t, e) {
      e = e ? "active" : "default";
      return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(e) : this.resolveDataElementOptions(t || 0, e)
    }
    getContext(t, e, i) {
      var s, n, a, o = this.getDataset();
      let r;
      if (0 <= t && t < this._cachedMeta.data.length) {
        const e = this._cachedMeta.data[t];
        r = e.$context || (e.$context = (s = this.getContext(), n = t, a = e, Object.assign(Object.create(s), {
          active: !1,
          dataIndex: n,
          parsed: void 0,
          raw: void 0,
          element: a,
          index: n,
          mode: "default",
          type: "data"
        }))), r.parsed = this.getParsed(t), r.raw = o.data[t]
      } else r = this.$context || (this.$context = (n = this.chart.getContext(), t = this.index, Object.assign(Object.create(n), {
        active: !1,
        dataset: void 0,
        datasetIndex: t,
        index: t,
        mode: "default",
        type: "dataset"
      }))), r.dataset = o;
      return r.active = !!e, r.mode = i, r
    }
    resolveDatasetElementOptions(t) {
      return this._resolveElementOptions(this.datasetElementType.id, t)
    }
    resolveDataElementOptions(t, e) {
      return this._resolveElementOptions(this.dataElementType.id, e, t)
    }
    _resolveElementOptions(t, e = "default", i) {
      const s = this,
        n = "active" === e,
        a = s._cachedDataOpts,
        o = t + "-" + e,
        r = a[o],
        l = s.enableOptionSharing && ot(i);
      if (r) return ki(r, l);
      const c = s.chart.config,
        d = c.datasetElementScopeKeys(s._type, t),
        h = n ? [t + "Hover", "hover", t, ""] : [t, ""],
        u = c.getOptionScopes(s.getDataset(), d),
        p = Object.keys(pt.elements[t]),
        f = c.resolveNamedOptions(u, p, () => s.getContext(i, n), h);
      return f.$shared && (f.$shared = l, a[o] = Object.freeze(ki(f, l))), f
    }
    _resolveAnimations(t, e, i) {
      const s = this.chart,
        n = this._cachedDataOpts,
        a = "animation-" + e,
        o = n[a];
      if (o) return o;
      let r;
      if (!1 !== s.options.animation) {
        const s = this.chart.config,
          n = s.datasetAnimationScopeKeys(this._type, e),
          a = s.getOptionScopes(this.getDataset(), n);
        r = s.createResolver(a, this.getContext(t, i, e))
      }
      e = new fi(s, r && r.animations);
      return r && r._cacheable && (n[a] = Object.freeze(e)), e
    }
    getSharedOptions(t) {
      if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
    }
    includeOptions(t, e) {
      return !e || Ci(t) || this.chart._animationsDisabled
    }
    updateElement(t, e, i, s) {
      Ci(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i)
    }
    updateSharedOptions(t, e, i) {
      t && !Ci(e) && this._resolveAnimations(void 0, e).update(t, i)
    }
    _setStyle(t, e, i, s) {
      t.active = s;
      var n = this.getStyle(e, s);
      this._resolveAnimations(e, i, s).update(t, {
        options: !s && this.getSharedOptions(n) || n
      })
    }
    removeHoverStyle(t, e, i) {
      this._setStyle(t, i, "active", !1)
    }
    setHoverStyle(t, e, i) {
      this._setStyle(t, i, "active", !0)
    }
    _removeDatasetHoverStyle() {
      var t = this._cachedMeta.dataset;
      t && this._setStyle(t, void 0, "active", !1)
    }
    _setDatasetHoverStyle() {
      var t = this._cachedMeta.dataset;
      t && this._setStyle(t, void 0, "active", !0)
    }
    _resyncElements(t) {
      var e = this._cachedMeta.data.length,
        i = this._data.length;
      e < i ? this._insertElements(e, i - e, t) : i < e && this._removeElements(i, e - i);
      e = Math.min(i, e);
      e && this.parse(0, e)
    }
    _insertElements(t, e, i = !0) {
      const s = this._cachedMeta,
        n = s.data,
        a = t + e;
      let o;
      var r = t => {
        for (t.length += e, o = t.length - 1; o >= a; o--) t[o] = t[o - e]
      };
      for (r(n), o = t; o < a; ++o) n[o] = new this.dataElementType;
      this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, "reset")
    }
    updateElements(t, e, i, s) {}
    _removeElements(t, e) {
      const i = this._cachedMeta;
      var s;
      this._parsing && (s = i._parsed.splice(t, e), i._stacked && xi(i, s)), i.data.splice(t, e)
    }
    _onDataPush() {
      var t = arguments.length;
      this._insertElements(this.getDataset().data.length - t, t)
    }
    _onDataPop() {
      this._removeElements(this._cachedMeta.data.length - 1, 1)
    }
    _onDataShift() {
      this._removeElements(0, 1)
    }
    _onDataSplice(t, e) {
      this._removeElements(t, e), this._insertElements(t, arguments.length - 2)
    }
    _onDataUnshift() {
      this._insertElements(0, arguments.length)
    }
  }
  Ti.defaults = {}, Ti.prototype.datasetElementType = null, Ti.prototype.dataElementType = null;
  class Di {
    constructor() {
      this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0
    }
    tooltipPosition(t) {
      var {
        x: e,
        y: t
      } = this.getProps(["x", "y"], t);
      return {
        x: e,
        y: t
      }
    }
    hasValue() {
      return Dt(this.x) && Dt(this.y)
    }
    getProps(t, e) {
      const i = this,
        s = this.$animations;
      if (!e || !s) return i;
      const n = {};
      return t.forEach(t => {
        n[t] = s[t] && s[t].active() ? s[t]._to : i[t]
      }), n
    }
  }
  Di.defaults = {}, Di.defaultRoutes = void 0;
  const Si = new Map;

  function Mi(t, e, n) {
    return function (t, e) {
      e = n || {};
      var i = t + JSON.stringify(e);
      let s = Si.get(i);
      return s || (s = new Intl.NumberFormat(t, e), Si.set(i, s)), s
    }(e).format(t)
  }
  const Ei = {
    values: t => B(t) ? t : "" + t,
    numeric(t, e, i) {
      if (0 === t) return "0";
      var s = this.chart.options.locale;
      let n, a = t;
      if (1 < i.length) {
        const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
        (e < 1e-4 || 1e15 < e) && (n = "scientific"), a = function (t) {
          let e = 3 < i.length ? i[2].value - i[1].value : i[1].value - i[0].value;
          return 1 < Math.abs(e) && t !== Math.floor(t) && (e = t - Math.floor(t)), e
        }(t)
      }
      var o = xt(Math.abs(a)),
        o = Math.max(Math.min(-1 * Math.floor(o), 20), 0),
        o = {
          notation: n,
          minimumFractionDigits: o,
          maximumFractionDigits: o
        };
      return Object.assign(o, this.options.ticks.format), Mi(t, s, o)
    },
    logarithmic(t, e, i) {
      if (0 === t) return "0";
      var s = t / Math.pow(10, Math.floor(xt(t)));
      return 1 == s || 2 == s || 5 == s ? Ei.numeric.call(this, t, e, i) : ""
    }
  };
  var Ai = {
    formatters: Ei
  };

  function Pi(t, i) {
    const e = t.options.ticks,
      s = e.maxTicksLimit || (d = (c = t).options.offset, t = c._tickSize(), d = c._length / t + (d ? 0 : 1), t = c._maxLength / t, Math.floor(Math.min(d, t))),
      n = e.major.enabled ? function (t) {
        const e = [];
        let i, s;
        for (i = 0, s = t.length; i < s; i++) t[i].major && e.push(i);
        return e
      }(i) : [],
      a = n.length,
      o = n[0],
      r = n[a - 1],
      l = [];
    var c, d;
    if (a > s) return function (t, e, i, s) {
      let n, a = 0,
        o = i[0];
      for (s = Math.ceil(s), n = 0; n < t.length; n++) n === o && (e.push(t[n]), a++, o = i[a * s])
    }(i, l, n, a / s), l;
    var h = function (t, i, e) {
      var t = function (t) {
          var e = t.length;
          let i, s;
          if (e < 2) return !1;
          for (s = t[0], i = 1; i < e; ++i)
            if (t[i] - t[i - 1] !== s) return !1;
          return s
        }(t),
        s = i.length / e;
      if (!t) return Math.max(s, 1);
      var n = Tt(t);
      for (let t = 0, e = n.length - 1; t < e; t++) {
        const i = n[t];
        if (i > s) return i
      }
      return Math.max(s, 1)
    }(n, i, s);
    if (0 < a) {
      let t, e;
      const s = 1 < a ? Math.round((r - o) / (a - 1)) : null;
      for (Ii(i, l, h, R(s) ? 0 : o - s, o), t = 0, e = a - 1; t < e; t++) Ii(i, l, h, n[t], n[t + 1]);
      return Ii(i, l, h, r, R(s) ? i.length : r + s), l
    }
    return Ii(i, l, h), l
  }

  function Ii(t, e, i, s, n) {
    var a = q(s, 0),
      o = Math.min(q(n, t.length), t.length);
    let r, l, c, d = 0;
    for (i = Math.ceil(i), n && (i = (r = n - s) / Math.floor(r / i)), c = a; c < 0;) d++, c = Math.round(a + d * i);
    for (l = Math.max(a, 0); l < o; l++) l === c && (e.push(t[l]), d++, c = Math.round(a + d * i))
  }
  pt.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawBorder: !0,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, e) => e.lineWidth,
      tickColor: (t, e) => e.color,
      offset: !1,
      borderDash: [],
      borderDashOffset: 0,
      borderWidth: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ai.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), pt.route("scale.ticks", "color", "", "color"), pt.route("scale.grid", "color", "", "borderColor"), pt.route("scale.grid", "borderColor", "", "borderColor"), pt.route("scale.title", "color", "", "color"), pt.describe("scale", {
    _fallback: !1,
    _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t,
    _indexable: t => "borderDash" !== t && "tickBorderDash" !== t
  }), pt.describe("scales", {
    _fallback: "scale"
  });
  const Oi = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i;

  function $i(t, e) {
    const i = [],
      s = t.length / e,
      n = t.length;
    let a = 0;
    for (; a < n; a += s) i.push(t[Math.floor(a)]);
    return i
  }

  function Li(t) {
    return t.drawTicks ? t.tickLength : 0
  }

  function Ni(t, e) {
    if (!t.display) return 0;
    var i = Ie(t.font, e),
      e = Pe(t.padding);
    return (B(t.text) ? t.text.length : 1) * i.lineHeight + e.height
  }
  class Hi extends Di {
    constructor(t) {
      super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0
    }
    init(t) {
      var e = this;
      e.options = t.setContext(e.getContext()), e.axis = t.axis, e._userMin = e.parse(t.min), e._userMax = e.parse(t.max), e._suggestedMin = e.parse(t.suggestedMin), e._suggestedMax = e.parse(t.suggestedMax)
    }
    parse(t, e) {
      return t
    }
    getUserBounds() {
      var {
        _userMin: t,
        _userMax: e,
        _suggestedMin: i,
        _suggestedMax: s
      } = this, t = V(t, Number.POSITIVE_INFINITY), e = V(e, Number.NEGATIVE_INFINITY), i = V(i, Number.POSITIVE_INFINITY), s = V(s, Number.NEGATIVE_INFINITY);
      return {
        min: V(t, i),
        max: V(e, s),
        minDefined: W(t),
        maxDefined: W(e)
      }
    }
    getMinMax(i) {
      let s, {
        min: n,
        max: a,
        minDefined: o,
        maxDefined: r
      } = this.getUserBounds();
      if (o && r) return {
        min: n,
        max: a
      };
      const l = this.getMatchingVisibleMetas();
      for (let t = 0, e = l.length; t < e; ++t) s = l[t].controller.getMinMax(this, i), o || (n = Math.min(n, s.min)), r || (a = Math.max(a, s.max));
      return {
        min: V(n, V(a, n)),
        max: V(a, V(n, a))
      }
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      }
    }
    getTicks() {
      return this.ticks
    }
    getLabels() {
      var t = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
    }
    beforeLayout() {
      this._cache = {}, this._dataLimitsCached = !1
    }
    beforeUpdate() {
      X(this.options.beforeUpdate, [this])
    }
    update(t, e, i) {
      var s = this,
        n = s.options.ticks,
        a = n.sampleSize;
      s.beforeUpdate(), s.maxWidth = t, s.maxHeight = e, s._margins = i = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, i), s.ticks = null, s._labelSizes = null, s._gridLineItems = null, s._labelItems = null, s.beforeSetDimensions(), s.setDimensions(), s.afterSetDimensions(), s._maxLength = s.isHorizontal() ? s.width + i.left + i.right : s.height + i.top + i.bottom, s._dataLimitsCached || (s.beforeDataLimits(), s.determineDataLimits(), s.afterDataLimits(), s._range = $e(s, s.options.grace), s._dataLimitsCached = !0), s.beforeBuildTicks(), s.ticks = s.buildTicks() || [], s.afterBuildTicks();
      i = a < s.ticks.length;
      s._convertTicksToLabels(i ? $i(s.ticks, a) : s.ticks), s.configure(), s.beforeCalculateLabelRotation(), s.calculateLabelRotation(), s.afterCalculateLabelRotation(), n.display && (n.autoSkip || "auto" === n.source) && (s.ticks = Pi(s, s.ticks), s._labelSizes = null), i && s._convertTicksToLabels(s.ticks), s.beforeFit(), s.fit(), s.afterFit(), s.afterUpdate()
    }
    configure() {
      var t = this;
      let e, i, s = t.options.reverse;
      t.isHorizontal() ? (e = t.left, i = t.right) : (e = t.top, i = t.bottom, s = !s), t._startPixel = e, t._endPixel = i, t._reversePixels = s, t._length = i - e, t._alignToPixels = t.options.alignToPixels
    }
    afterUpdate() {
      X(this.options.afterUpdate, [this])
    }
    beforeSetDimensions() {
      X(this.options.beforeSetDimensions, [this])
    }
    setDimensions() {
      var t = this;
      t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0
    }
    afterSetDimensions() {
      X(this.options.afterSetDimensions, [this])
    }
    _callHooks(t) {
      this.chart.notifyPlugins(t, this.getContext()), X(this.options[t], [this])
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits")
    }
    determineDataLimits() {}
    afterDataLimits() {
      this._callHooks("afterDataLimits")
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks")
    }
    buildTicks() {
      return []
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks")
    }
    beforeTickToLabelConversion() {
      X(this.options.beforeTickToLabelConversion, [this])
    }
    generateTickLabels(t) {
      var e = this.options.ticks;
      let i, s, n;
      for (i = 0, s = t.length; i < s; i++) n = t[i], n.label = X(e.callback, [n.value, i, t], this);
      for (i = 0; i < s; i++) R(t[i].label) && (t.splice(i, 1), s--, i--)
    }
    afterTickToLabelConversion() {
      X(this.options.afterTickToLabelConversion, [this])
    }
    beforeCalculateLabelRotation() {
      X(this.options.beforeCalculateLabelRotation, [this])
    }
    calculateLabelRotation() {
      var t, e, i, s, n = this,
        a = n.options,
        o = a.ticks,
        r = n.ticks.length,
        l = o.minRotation || 0,
        c = o.maxRotation;
      let d, h, u, p = l;
      !n._isVisible() || !o.display || c <= l || r <= 1 || !n.isHorizontal() ? n.labelRotation = l : (e = (t = n._getLabelSizes()).widest.width, i = t.highest.height, s = Ft(n.chart.width - e, 0, n.maxWidth), (a.offset ? n.maxWidth / r : s / (r - 1)) < e + 6 && (d = s / (r - (a.offset ? .5 : 1)), h = n.maxHeight - Li(a.grid) - o.padding - Ni(a.title, n.chart.options.font), u = Math.sqrt(e * e + i * i), p = Pt(Math.min(Math.asin(Math.min((t.highest.height + 6) / d, 1)), Math.asin(Math.min(h / u, 1)) - Math.asin(i / u))), p = Math.max(l, Math.min(c, p))), n.labelRotation = p)
    }
    afterCalculateLabelRotation() {
      X(this.options.afterCalculateLabelRotation, [this])
    }
    beforeFit() {
      X(this.options.beforeFit, [this])
    }
    fit() {
      const t = this,
        e = {
          width: 0,
          height: 0
        },
        {
          chart: i,
          options: {
            ticks: s,
            title: n,
            grid: a
          }
        } = t,
        o = t._isVisible(),
        r = t.isHorizontal();
      if (o) {
        const o = Ni(n, i.options.font);
        if (r ? (e.width = t.maxWidth, e.height = Li(a) + o) : (e.height = t.maxHeight, e.width = Li(a) + o), s.display && t.ticks.length) {
          const {
            first: i,
            last: n,
            widest: a,
            highest: o
          } = t._getLabelSizes(), l = 2 * s.padding, c = At(t.labelRotation), d = Math.cos(c), h = Math.sin(c);
          if (r) {
            const i = s.mirror ? 0 : h * a.width + d * o.height;
            e.height = Math.min(t.maxHeight, e.height + i + l)
          } else {
            const i = s.mirror ? 0 : d * a.width + h * o.height;
            e.width = Math.min(t.maxWidth, e.width + i + l)
          }
          t._calculatePadding(i, n, h, d)
        }
      }
      t._handleMargins(), r ? (t.width = t._length = i.width - t._margins.left - t._margins.right, t.height = e.height) : (t.width = e.width, t.height = t._length = i.height - t._margins.top - t._margins.bottom)
    }
    _calculatePadding(i, s, n, a) {
      const o = this,
        {
          ticks: {
            align: r,
            padding: l
          },
          position: c
        } = o.options,
        d = 0 !== o.labelRotation,
        h = "top" !== c && "x" === o.axis;
      if (o.isHorizontal()) {
        const c = o.getPixelForTick(0) - o.left,
          u = o.right - o.getPixelForTick(o.ticks.length - 1);
        let t = 0,
          e = 0;
        d ? e = h ? (t = a * i.width, n * s.height) : (t = n * i.height, a * s.width) : "start" === r ? e = s.width : "end" === r ? t = i.width : (t = i.width / 2, e = s.width / 2), o.paddingLeft = Math.max((t - c + l) * o.width / (o.width - c), 0), o.paddingRight = Math.max((e - u + l) * o.width / (o.width - u), 0)
      } else {
        let t = s.height / 2,
          e = i.height / 2;
        "start" === r ? (t = 0, e = i.height) : "end" === r && (t = s.height, e = 0), o.paddingTop = t + l, o.paddingBottom = e + l
      }
    }
    _handleMargins() {
      var t = this;
      t._margins && (t._margins.left = Math.max(t.paddingLeft, t._margins.left), t._margins.top = Math.max(t.paddingTop, t._margins.top), t._margins.right = Math.max(t.paddingRight, t._margins.right), t._margins.bottom = Math.max(t.paddingBottom, t._margins.bottom))
    }
    afterFit() {
      X(this.options.afterFit, [this])
    }
    isHorizontal() {
      var {
        axis: t,
        position: e
      } = this.options;
      return "top" === e || "bottom" === e || "x" === t
    }
    isFullSize() {
      return this.options.fullSize
    }
    _convertTicksToLabels(t) {
      this.beforeTickToLabelConversion(), this.generateTickLabels(t), this.afterTickToLabelConversion()
    }
    _getLabelSizes() {
      let e = this._labelSizes;
      if (!e) {
        var i = this.options.ticks.sampleSize;
        let t = this.ticks;
        i < t.length && (t = $i(t, i)), this._labelSizes = e = this._computeLabelSizes(t, t.length)
      }
      return e
    }
    _computeLabelSizes(t, e) {
      const {
        ctx: i,
        _longestTextCache: s
      } = this, n = [], a = [];
      let o, r, l, c, d, h, u, p, f, m, g, v = 0,
        b = 0;
      for (o = 0; o < e; ++o) {
        if (c = t[o].label, d = this._resolveTickFontOptions(o), i.font = h = d.string, u = s[h] = s[h] || {
            data: {},
            gc: []
          }, p = d.lineHeight, f = m = 0, R(c) || B(c)) {
          if (B(c))
            for (r = 0, l = c.length; r < l; ++r) R(g = c[r]) || B(g) || (f = Bt(i, u.data, u.gc, f, g), m += p)
        } else f = Bt(i, u.data, u.gc, f, c), m = p;
        n.push(f), a.push(m), v = Math.max(f, v), b = Math.max(m, b)
      }
      var _;
      x = s, _ = e, G(x, t => {
        const e = t.gc,
          i = e.length / 2;
        let s;
        if (_ < i) {
          for (s = 0; s < i; ++s) delete t.data[e[s]];
          e.splice(0, i)
        }
      });
      var y = n.indexOf(v),
        w = a.indexOf(b),
        x = t => ({
          width: n[t] || 0,
          height: a[t] || 0
        });
      return {
        first: x(0),
        last: x(e - 1),
        widest: x(y),
        highest: x(w),
        widths: n,
        heights: a
      }
    }
    getLabelForValue(t) {
      return t
    }
    getPixelForValue(t, e) {
      return NaN
    }
    getValueForPixel(t) {}
    getPixelForTick(t) {
      var e = this.ticks;
      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
    }
    getPixelForDecimal(t) {
      this._reversePixels && (t = 1 - t);
      t = this._startPixel + t * this._length;
      return zt(this._alignToPixels ? Wt(this.chart, t, 0) : t)
    }
    getDecimalForPixel(t) {
      t = (t - this._startPixel) / this._length;
      return this._reversePixels ? 1 - t : t
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue())
    }
    getBaseValue() {
      var {
        min: t,
        max: e
      } = this;
      return t < 0 && e < 0 ? e : 0 < t && 0 < e ? t : 0
    }
    getContext(t) {
      var e, i, s = this.ticks || [];
      if (0 <= t && t < s.length) {
        const i = s[t];
        return i.$context || (i.$context = (e = this.getContext(), s = t, t = i, Object.assign(Object.create(e), {
          tick: t,
          index: s,
          type: "tick"
        })))
      }
      return this.$context || (this.$context = (i = this.chart.getContext(), Object.assign(Object.create(i), {
        scale: this,
        type: "scale"
      })))
    }
    _tickSize() {
      var t = this.options.ticks,
        e = At(this.labelRotation),
        i = Math.abs(Math.cos(e)),
        s = Math.abs(Math.sin(e)),
        n = this._getLabelSizes(),
        e = t.autoSkipPadding || 0,
        t = n ? n.widest.width + e : 0,
        e = n ? n.highest.height + e : 0;
      return this.isHorizontal() ? t * s < e * i ? t / i : e / s : e * s < t * i ? e / i : t / s
    }
    _isVisible() {
      var t = this.options.display;
      return "auto" !== t ? !!t : 0 < this.getMatchingVisibleMetas().length
    }
    _computeGridLineItems(t) {
      const e = this,
        i = e.axis,
        s = e.chart,
        n = e.options,
        {
          grid: a,
          position: o
        } = n,
        r = a.offset,
        l = e.isHorizontal(),
        c = e.ticks.length + (r ? 1 : 0),
        d = Li(a),
        h = [],
        u = a.setContext(e.getContext()),
        p = u.drawBorder ? u.borderWidth : 0,
        f = p / 2,
        m = function (t) {
          return Wt(s, t, p)
        };
      let g, v, b, _, y, w, x, C, k, T, D, S;
      if ("top" === o) g = m(e.bottom), w = e.bottom - d, C = g - f, T = m(t.top) + f, S = t.bottom;
      else if ("bottom" === o) g = m(e.top), T = t.top, S = m(t.bottom) - f, w = g + f, C = e.top + d;
      else if ("left" === o) g = m(e.right), y = e.right - d, x = g - f, k = m(t.left) + f, D = t.right;
      else if ("right" === o) g = m(e.left), k = t.left, D = m(t.right) - f, y = g + f, x = e.left + d;
      else if ("x" === i) {
        if ("center" === o) g = m((t.top + t.bottom) / 2 + .5);
        else if (j(o)) {
          const t = Object.keys(o)[0],
            i = o[t];
          g = m(e.chart.scales[t].getPixelForValue(i))
        }
        T = t.top, S = t.bottom, w = g + f, C = w + d
      } else if ("y" === i) {
        if ("center" === o) g = m((t.left + t.right) / 2);
        else if (j(o)) {
          const t = Object.keys(o)[0],
            i = o[t];
          g = m(e.chart.scales[t].getPixelForValue(i))
        }
        y = g - f, x = y - d, k = t.left, D = t.right
      }
      for (v = 0; v < c; ++v) {
        const t = a.setContext(e.getContext(v)),
          i = t.lineWidth,
          n = t.color,
          o = a.borderDash || [],
          c = t.borderDashOffset,
          d = t.tickWidth,
          u = t.tickColor,
          p = t.tickBorderDash || [],
          f = t.tickBorderDashOffset;
        void 0 !== (b = function (t, e, i) {
          var s = t.ticks.length,
            n = Math.min(e, s - 1),
            a = t._startPixel,
            o = t._endPixel;
          let r, l = t.getPixelForTick(n);
          if (!(i && (r = 1 === s ? Math.max(l - a, o - l) : 0 === e ? (t.getPixelForTick(1) - l) / 2 : (l - t.getPixelForTick(n - 1)) / 2, l += n < e ? r : -r, l < a - 1e-6 || l > o + 1e-6))) return l
        }(e, v, r)) && (_ = Wt(s, b, i), l ? y = x = k = D = _ : w = C = T = S = _, h.push({
          tx1: y,
          ty1: w,
          tx2: x,
          ty2: C,
          x1: k,
          y1: T,
          x2: D,
          y2: S,
          width: i,
          color: n,
          borderDash: o,
          borderDashOffset: c,
          tickWidth: d,
          tickColor: u,
          tickBorderDash: p,
          tickBorderDashOffset: f
        }))
      }
      return e._ticksLength = c, e._borderValue = g, h
    }
    _computeLabelItems(s) {
      const n = this,
        a = n.axis,
        o = n.options,
        {
          position: t,
          ticks: e
        } = o,
        r = n.isHorizontal(),
        l = n.ticks,
        {
          align: c,
          crossAlign: d,
          padding: h,
          mirror: u
        } = e,
        i = Li(o.grid),
        p = i + h,
        f = u ? -h : p,
        m = -At(n.labelRotation),
        g = [];
      let v, b, _, y, w, x, C, k, T, D, S, M = "middle";
      if ("top" === t) w = n.bottom - f, x = n._getXAxisLabelAlignment();
      else if ("bottom" === t) w = n.top + f, x = n._getXAxisLabelAlignment();
      else if ("left" === t) {
        const s = n._getYAxisLabelAlignment(i);
        x = s.textAlign, y = s.x
      } else if ("right" === t) {
        const s = n._getYAxisLabelAlignment(i);
        x = s.textAlign, y = s.x
      } else if ("x" === a) {
        if ("center" === t) w = (s.top + s.bottom) / 2 + p;
        else if (j(t)) {
          const s = Object.keys(t)[0],
            a = t[s];
          w = n.chart.scales[s].getPixelForValue(a) + p
        }
        x = n._getXAxisLabelAlignment()
      } else if ("y" === a) {
        if ("center" === t) y = (s.left + s.right) / 2 - p;
        else if (j(t)) {
          const s = Object.keys(t)[0],
            a = t[s];
          y = n.chart.scales[s].getPixelForValue(a)
        }
        x = n._getYAxisLabelAlignment(i).textAlign
      }
      "y" === a && ("start" === c ? M = "top" : "end" === c && (M = "bottom"));
      var E = n._getLabelSizes();
      for (v = 0, b = l.length; v < b; ++v) {
        _ = l[v].label;
        const s = e.setContext(n.getContext(v));
        C = n.getPixelForTick(v) + e.labelOffset, T = (k = n._resolveTickFontOptions(v)).lineHeight;
        const a = (D = B(_) ? _.length : 1) / 2,
          o = s.color,
          c = s.textStrokeColor,
          h = s.textStrokeWidth;
        let i;
        if (r ? (y = C, S = "top" === t ? "near" === d || 0 != m ? -D * T + T / 2 : "center" === d ? -E.highest.height / 2 - a * T + T : -E.highest.height + T / 2 : "near" === d || 0 != m ? T / 2 : "center" === d ? E.highest.height / 2 - a * T : E.highest.height - D * T, u && (S *= -1)) : (w = C, S = (1 - D) * T / 2), s.showLabelBackdrop) {
          const n = Pe(s.backdropPadding),
            a = E.heights[v],
            o = E.widths[v];
          let t = w + S - n.top,
            e = y - n.left;
          switch (M) {
            case "middle":
              t -= a / 2;
              break;
            case "bottom":
              t -= a
          }
          switch (x) {
            case "center":
              e -= o / 2;
              break;
            case "right":
              e -= o
          }
          i = {
            left: e,
            top: t,
            width: o + n.width,
            height: a + n.height,
            color: s.backdropColor
          }
        }
        g.push({
          rotation: m,
          label: _,
          font: k,
          color: o,
          strokeColor: c,
          strokeWidth: h,
          textOffset: S,
          textAlign: x,
          textBaseline: M,
          translation: [y, w],
          backdrop: i
        })
      }
      return g
    }
    _getXAxisLabelAlignment() {
      var {
        position: t,
        ticks: e
      } = this.options;
      if (-At(this.labelRotation)) return "top" === t ? "left" : "right";
      let i = "center";
      return "start" === e.align ? i = "left" : "end" === e.align && (i = "right"), i
    }
    _getYAxisLabelAlignment(t) {
      var {
        position: e,
        ticks: {
          crossAlign: i,
          mirror: s,
          padding: n
        }
      } = this.options, a = t + n, t = this._getLabelSizes().widest.width;
      let o, r;
      return "left" === e ? s ? (o = "left", r = this.right + n) : (r = this.right - a, "near" === i ? o = "right" : "center" === i ? (o = "center", r -= t / 2) : (o = "left", r = this.left)) : "right" === e ? s ? (o = "right", r = this.left + n) : (r = this.left + a, "near" === i ? o = "left" : "center" === i ? (o = "center", r += t / 2) : (o = "right", r = this.right)) : o = "right", {
        textAlign: o,
        x: r
      }
    }
    _computeLabelArea() {
      if (!this.options.ticks.mirror) {
        var t = this.chart,
          e = this.options.position;
        return "left" === e || "right" === e ? {
          top: 0,
          left: this.left,
          bottom: t.height,
          right: this.right
        } : "top" === e || "bottom" === e ? {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: t.width
        } : void 0
      }
    }
    drawBackground() {
      const {
        ctx: t,
        options: {
          backgroundColor: e
        },
        left: i,
        top: s,
        width: n,
        height: a
      } = this;
      e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, a), t.restore())
    }
    getLineWidthForValue(e) {
      const t = this.options.grid;
      if (!this._isVisible() || !t.display) return 0;
      var i = this.ticks.findIndex(t => t.value === e);
      return 0 <= i ? t.setContext(this.getContext(i)).lineWidth : 0
    }
    drawGrid(t) {
      const e = this.options.grid,
        s = this.ctx,
        i = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
      let n, a;
      var o = (t, e, i) => {
        i.width && i.color && (s.save(), s.lineWidth = i.width, s.strokeStyle = i.color, s.setLineDash(i.borderDash || []), s.lineDashOffset = i.borderDashOffset, s.beginPath(), s.moveTo(t.x, t.y), s.lineTo(e.x, e.y), s.stroke(), s.restore())
      };
      if (e.display)
        for (n = 0, a = i.length; n < a; ++n) {
          const t = i[n];
          e.drawOnChartArea && o({
            x: t.x1,
            y: t.y1
          }, {
            x: t.x2,
            y: t.y2
          }, t), e.drawTicks && o({
            x: t.tx1,
            y: t.ty1
          }, {
            x: t.tx2,
            y: t.ty2
          }, {
            color: t.tickColor,
            width: t.tickWidth,
            borderDash: t.tickBorderDash,
            borderDashOffset: t.tickBorderDashOffset
          })
        }
    }
    drawBorder() {
      const {
        chart: n,
        ctx: a,
        options: {
          grid: o
        }
      } = this, r = o.setContext(this.getContext()), l = o.drawBorder ? r.borderWidth : 0;
      if (l) {
        var c = o.setContext(this.getContext(0)).lineWidth,
          d = this._borderValue;
        let t, e, i, s;
        this.isHorizontal() ? (t = Wt(n, this.left, l) - l / 2, e = Wt(n, this.right, c) + c / 2, i = s = d) : (i = Wt(n, this.top, l) - l / 2, s = Wt(n, this.bottom, c) + c / 2, t = e = d), a.save(), a.lineWidth = r.borderWidth, a.strokeStyle = r.borderColor, a.beginPath(), a.moveTo(t, i), a.lineTo(e, s), a.stroke(), a.restore()
      }
    }
    drawLabels(i) {
      const s = this;
      if (s.options.ticks.display) {
        const a = s.ctx,
          o = s._computeLabelArea();
        o && Ut(a, o);
        var n = s._labelItems || (s._labelItems = s._computeLabelItems(i));
        let t, e;
        for (t = 0, e = n.length; t < e; ++t) {
          const i = n[t],
            s = i.font,
            o = i.label;
          i.backdrop && (a.fillStyle = i.backdrop.color, a.fillRect(i.backdrop.left, i.backdrop.top, i.backdrop.width, i.backdrop.height)), Qt(a, o, 0, i.textOffset, s, i)
        }
        o && Xt(a)
      }
    }
    drawTitle() {
      var {
        ctx: e,
        options: {
          position: i,
          title: s,
          reverse: n
        }
      } = this;
      if (s.display) {
        var a = Ie(s.font),
          o = Pe(s.padding),
          r = s.align;
        let t = a.lineHeight / 2;
        "bottom" === i ? (t += o.bottom, B(s.text) && (t += a.lineHeight * (s.text.length - 1))) : t += o.top;
        var {
          titleX: l,
          titleY: c,
          maxWidth: d,
          rotation: o
        } = function (t, e, i, s) {
          var {
            top: n,
            left: a,
            bottom: o,
            right: r
          } = t;
          let l, c, d, h = 0;
          return t.isHorizontal() ? (c = P(s, a, r), d = Oi(t, i, e), l = r - a) : (c = Oi(t, i, e), d = P(s, o, n), h = "left" === i ? -_t : _t), {
            titleX: c,
            titleY: d,
            maxWidth: l,
            rotation: h
          }
        }(this, t, i, r);
        Qt(e, s.text, 0, 0, a, {
          color: s.color,
          maxWidth: d,
          rotation: o,
          textAlign: function (t, e, i) {
            let s = f(t);
            return (i && "right" !== e || !i && "right" === e) && (s = "left" === (e = s) ? "right" : "right" === e ? "left" : e), s
          }(r, i, n),
          textBaseline: "middle",
          translation: [l, c]
        })
      }
    }
    draw(t) {
      this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t))
    }
    _layers() {
      const e = this,
        t = e.options,
        i = t.ticks && t.ticks.z || 0,
        s = t.grid && t.grid.z || 0;
      return e._isVisible() && e.draw === Hi.prototype.draw ? [{
        z: s,
        draw(t) {
          e.drawBackground(), e.drawGrid(t), e.drawTitle()
        }
      }, {
        z: s + 1,
        draw() {
          e.drawBorder()
        }
      }, {
        z: i,
        draw(t) {
          e.drawLabels(t)
        }
      }] : [{
        z: i,
        draw(t) {
          e.draw(t)
        }
      }]
    }
    getMatchingVisibleMetas(t) {
      const e = this.chart.getSortedVisibleDatasetMetas(),
        i = this.axis + "AxisID",
        s = [];
      let n, a;
      for (n = 0, a = e.length; n < a; ++n) {
        const a = e[n];
        a[i] !== this.id || t && a.type !== t || s.push(a)
      }
      return s
    }
    _resolveTickFontOptions(t) {
      return Ie(this.options.ticks.setContext(this.getContext(t)).font)
    }
  }

  function Fi(i, a = [""], e = i, s, n = () => i[0]) {
    ot(s) || (s = Xi("_fallback", i));
    var t = {
      [Symbol.toStringTag]: "Object",
      _cacheable: !0,
      _scopes: i,
      _rootScopes: e,
      _fallback: s,
      _getTarget: n,
      override: t => Fi([t, ...i], a, e, s)
    };
    return new Proxy(t, {
      deleteProperty: (t, e) => (delete t[e], delete t._keys, delete i[0][e], !0),
      get: (t, e) => Wi(t, e, () => function (t, e, i) {
        var s;
        for (const n of a)
          if (s = Xi(Bi(n, t), e), ot(s)) return ji(t, s) ? Yi(e, i, t, s) : s
      }(e, i, t)),
      getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e),
      getPrototypeOf: () => Reflect.getPrototypeOf(i[0]),
      has: (t, e) => Gi(t).includes(e),
      ownKeys: t => Gi(t),
      set: (t, e, i) => ((t._storage || (t._storage = n()))[e] = i, delete t[e], delete t._keys, !0)
    })
  }

  function zi(s, e, i, n) {
    var t = {
      _cacheable: !1,
      _proxy: s,
      _context: e,
      _subProxy: i,
      _stack: new Set,
      _descriptors: Ri(s, n),
      setContext: t => zi(s, t, i, n),
      override: t => zi(s.override(t), e, i, n)
    };
    return new Proxy(t, {
      deleteProperty: (t, e) => (delete t[e], delete s[e], !0),
      get: (t, e, i) => Wi(t, e, () => function (r, t, e) {
        const {
          _proxy: i,
          _context: s,
          _subProxy: n,
          _descriptors: a
        } = r;
        let o = i[t];
        return rt(o) && a.isScriptable(t) && (o = function (t, e, i) {
          const {
            _proxy: s,
            _context: n,
            _subProxy: a,
            _stack: o
          } = r;
          if (o.has(t)) throw new Error("Recursion detected: " + [...o].join("->") + "->" + t);
          return o.add(t), e = e(n, a || i), o.delete(t), e = j(e) ? Yi(s._scopes, s, t, e) : e
        }(t, o, e)), B(o) && o.length && (o = function (t, e, i, s) {
          const {
            _proxy: n,
            _context: a,
            _subProxy: o,
            _descriptors: r
          } = i;
          if (ot(a.index) && s(t)) e = e[a.index % e.length];
          else if (j(e[0])) {
            const i = e,
              s = n._scopes.filter(t => t !== i);
            e = [];
            for (const l of i) {
              const i = Yi(s, n, t, l);
              e.push(zi(i, a, o && o[t], r))
            }
          }
          return e
        }(t, o, r, a.isIndexable)), ji(t, o) && (o = zi(o, s, n && n[t], a)), o
      }(t, e, i)),
      getOwnPropertyDescriptor: (t, e) => t._descriptors.allKeys ? Reflect.has(s, e) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(s, e),
      getPrototypeOf: () => Reflect.getPrototypeOf(s),
      has: (t, e) => Reflect.has(s, e),
      ownKeys: () => Reflect.ownKeys(s),
      set: (t, e, i) => (s[e] = i, delete t[e], !0)
    })
  }

  function Ri(t, e = {
    scriptable: !0,
    indexable: !0
  }) {
    const {
      _scriptable: i = e.scriptable,
      _indexable: s = e.indexable,
      _allKeys: n = e.allKeys
    } = t;
    return {
      allKeys: n,
      scriptable: i,
      indexable: s,
      isScriptable: rt(i) ? i : () => i,
      isIndexable: rt(s) ? s : () => s
    }
  }
  const Bi = (t, e) => t ? t + at(e) : e,
    ji = (t, e) => j(e) && "adapters" !== t;

  function Wi(t, e, i) {
    let s = t[e];
    return ot(s) || (s = i(), ot(s) && (t[e] = s)), s
  }

  function Vi(t, e, i) {
    return rt(t) ? t(e, i) : t
  }
  const qi = (t, e) => !0 === t ? e : "string" == typeof t ? nt(e, t) : void 0;

  function Yi(t, e, i, s) {
    const n = e._rootScopes,
      a = Vi(e._fallback, i, s),
      o = [...t, ...n],
      r = new Set;
    r.add(s);
    s = Ui(r, o, i, a || i);
    return null !== s && (!ot(a) || a === i || null !== (s = Ui(r, o, a, s))) && Fi([...r], [""], n, a, () => {
      const t = e._getTarget();
      return i in t || (t[i] = {}), t[i]
    })
  }

  function Ui(t, e, i, s) {
    for (; i;) i = function (t, e, i, s) {
      for (const a of e) {
        const e = qi(i, a);
        if (e) {
          t.add(e);
          var n = Vi(e._fallback, i, e);
          if (ot(n) && n !== i && n !== s) return n
        } else if (!1 === e && ot(s) && i !== s) return null
      }
      return !1
    }(t, e, i, s);
    return i
  }

  function Xi(t, e) {
    for (const i of e)
      if (i) {
        const e = i[t];
        if (ot(e)) return e
      }
  }

  function Gi(t) {
    let e = t._keys;
    return e = e || (t._keys = function (t) {
      const e = new Set;
      for (const i of t)
        for (const t of Object.keys(i).filter(t => !t.startsWith("_"))) e.add(t);
      return [...e]
    }(t._scopes)), e
  }
  const Ki = Number.EPSILON || 1e-14,
    Qi = (t, e) => e < t.length && !t[e].skip && t[e];

  function Ji(t, e, i, s) {
    var n = t.skip ? e : t,
      a = e,
      t = i.skip ? e : i,
      e = $t(a, n),
      i = $t(t, a);
    let o = e / (e + i),
      r = i / (e + i);
    o = isNaN(o) ? 0 : o, r = isNaN(r) ? 0 : r;
    i = s * o, s *= r;
    return {
      previous: {
        x: a.x - i * (t.x - n.x),
        y: a.y - i * (t.y - n.y)
      },
      next: {
        x: a.x + s * (t.x - n.x),
        y: a.y + s * (t.y - n.y)
      }
    }
  }

  function Zi(t) {
    const e = t.length,
      i = Array(e).fill(0),
      s = Array(e);
    let n, a, o, r = Qi(t, 0);
    for (n = 0; n < e; ++n)
      if (a = o, o = r, r = Qi(t, n + 1), o) {
        if (r) {
          const t = r.x - o.x;
          i[n] = 0 != t ? (r.y - o.y) / t : 0
        }
        s[n] = a ? r ? Ct(i[n - 1]) !== Ct(i[n]) ? 0 : (i[n - 1] + i[n]) / 2 : i[n - 1] : i[n]
      }!
    function (e, i, s) {
      var n = e.length;
      let a, o, r, l, c, d = Qi(e, 0);
      for (let t = 0; t < n - 1; ++t) c = d, d = Qi(e, t + 1), c && d && (St(i[t], 0, Ki) ? s[t] = s[t + 1] = 0 : (a = s[t] / i[t], o = s[t + 1] / i[t], (l = Math.pow(a, 2) + Math.pow(o, 2)) <= 9 || (r = 3 / Math.sqrt(l), s[t] = a * r * i[t], s[t + 1] = o * r * i[t])))
    }(t, i, s),
    function (e, i) {
      const s = e.length;
      let n, a, o, r = Qi(e, 0);
      for (let t = 0; t < s; ++t)
        if (a = o, o = r, r = Qi(e, t + 1), o) {
          const {
            x: s,
            y: l
          } = o;
          a && (n = (s - a.x) / 3, o.cp1x = s - n, o.cp1y = l - n * i[t]), r && (n = (r.x - s) / 3, o.cp2x = s + n, o.cp2y = l + n * i[t])
        }
    }(t, s)
  }

  function ts(t, e, i) {
    return Math.max(Math.min(t, i), e)
  }

  function es(e, i, t, s) {
    let n, a, o, r;
    if (i.spanGaps && (e = e.filter(t => !t.skip)), "monotone" === i.cubicInterpolationMode) Zi(e);
    else {
      let t = s ? e[e.length - 1] : e[0];
      for (n = 0, a = e.length; n < a; ++n) o = e[n], r = Ji(t, o, e[Math.min(n + 1, a - (s ? 0 : 1)) % a], i.tension), o.cp1x = r.previous.x, o.cp1y = r.previous.y, o.cp2x = r.next.x, o.cp2y = r.next.y, t = o
    }
    i.capBezierPoints && function (t, e) {
      let i, s, n, a, o, r = Yt(t[0], e);
      for (i = 0, s = t.length; i < s; ++i) o = a, a = r, r = i < s - 1 && Yt(t[i + 1], e), a && (n = t[i], o && (n.cp1x = ts(n.cp1x, e.left, e.right), n.cp1y = ts(n.cp1y, e.top, e.bottom)), r && (n.cp2x = ts(n.cp2x, e.left, e.right), n.cp2y = ts(n.cp2y, e.top, e.bottom)))
    }(e, t)
  }

  function is(t, e, i, s) {
    return {
      x: t.x + i * (e.x - t.x),
      y: t.y + i * (e.y - t.y)
    }
  }

  function ss(t, e, i, s) {
    return {
      x: t.x + i * (e.x - t.x),
      y: ("middle" === s ? i < .5 ? t : e : "after" === s ? i < 1 ? t : e : 0 < i ? e : t).y
    }
  }

  function ns(t, e, i, s) {
    var n = {
        x: t.cp2x,
        y: t.cp2y
      },
      a = {
        x: e.cp1x,
        y: e.cp1y
      },
      t = is(t, n, i),
      n = is(n, a, i),
      e = is(a, e, i),
      t = is(t, n, i),
      e = is(n, e, i);
    return is(t, e, i)
  }

  function as(t, e, i) {
    return t ? (s = e, n = i, {
      x: t => s + s + n - t,
      setWidth(t) {
        n = t
      },
      textAlign: t => "center" === t ? t : "right" === t ? "left" : "right",
      xPlus: (t, e) => t - e,
      leftForLtr: (t, e) => t - e
    }) : {
      x: t => t,
      setWidth(t) {},
      textAlign: t => t,
      xPlus: (t, e) => t + e,
      leftForLtr: (t, e) => t
    };
    var s, n
  }

  function os(t, e) {
    let i, s;
    "ltr" !== e && "rtl" !== e || (i = t.canvas.style, s = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")], i.setProperty("direction", e, "important"), t.prevTextDirection = s)
  }

  function rs(t, e) {
    void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]))
  }

  function ls(t) {
    return "angle" === t ? {
      between: Ht,
      compare: Lt,
      normalize: Nt
    } : {
      between: (t, e, i) => t >= Math.min(e, i) && t <= Math.max(i, e),
      compare: (t, e) => t - e,
      normalize: t => t
    }
  }

  function cs({
    start: t,
    end: e,
    count: i,
    loop: s,
    style: n
  }) {
    return {
      start: t % i,
      end: e % i,
      loop: s && (e - t + 1) % i == 0,
      style: n
    }
  }

  function ds(t, i, p) {
    if (!p) return [t];
    const {
      property: s,
      start: n,
      end: a
    } = p, o = i.length, {
      compare: r,
      between: l,
      normalize: c
    } = ls(s), {
      start: d,
      end: h,
      loop: u,
      style: f
    } = function (t, e) {
      const {
        property: i,
        start: s,
        end: n
      } = p, {
        between: a,
        normalize: o
      } = ls(i), r = e.length;
      let l, c, {
        start: d,
        end: h,
        loop: u
      } = t;
      if (u) {
        for (d += r, h += r, l = 0, c = r; l < c && a(o(e[d % r][i]), s, n); ++l) d--, h--;
        d %= r, h %= r
      }
      return h < d && (h += r), {
        start: d,
        end: h,
        loop: u,
        style: t.style
      }
    }(t, i), m = [];
    let g, v, b, _ = !1,
      y = null;
    for (let t = d, e = d; t <= h; ++t)(v = i[t % o]).skip || (g = c(v[s]), _ = l(g, n, a), null === y && (_ || l(n, b, g) && 0 !== r(n, b)) && (y = 0 === r(g, n) ? t : e), null === y || _ && 0 !== r(a, g) && !l(a, b, g) || (m.push(cs({
      start: y,
      end: t,
      loop: u,
      count: o,
      style: f
    })), y = null), e = t, b = g);
    return null !== y && m.push(cs({
      start: y,
      end: h,
      loop: u,
      count: o,
      style: f
    })), m
  }

  function hs(e, i) {
    const s = [],
      n = e.segments;
    for (let t = 0; t < n.length; t++) {
      var a = ds(n[t], e.points, i);
      a.length && s.push(...a)
    }
    return s
  }

  function us(t, e) {
    var i = t.points,
      a = t.options.spanGaps,
      s = i.length;
    if (!s) return [];
    var n = !!t._loop,
      {
        start: o,
        end: r
      } = function (t, e, i) {
        let s = 0,
          n = e - 1;
        if (i && !a)
          for (; s < e && !t[s].skip;) s++;
        for (; s < e && t[s].skip;) s++;
        for (s %= e, i && (n += s); n > s && t[n % e].skip;) n--;
        return n %= e, {
          start: s,
          end: n
        }
      }(i, s, n);
    return ps(!0 === a ? [{
      start: o,
      end: r,
      loop: n
    }] : function (t, e, i, s) {
      const n = t.length,
        a = [];
      let o, r = e,
        l = t[e];
      for (o = e + 1; o <= i; ++o) {
        const i = t[o % n];
        i.skip || i.stop ? l.skip || (s = !1, a.push({
          start: e % n,
          end: (o - 1) % n,
          loop: s
        }), e = r = i.stop ? o : null) : (r = o, l.skip && (e = o)), l = i
      }
      return null !== r && a.push({
        start: e % n,
        end: r % n,
        loop: s
      }), a
    }(i, o, r < o ? r + s : r, !!t._fullLoop && 0 === o && r === s - 1), i, e)
  }

  function ps(t, e, i) {
    return i && i.setContext && e ? function (s, n) {
      const a = s.length,
        o = [];
      let r = t[0].start,
        l = r;
      for (const u of t) {
        let t, e, i = s[r % a];
        for (l = r + 1; l <= u.end; l++) {
          var c = s[l % a];
          e = {
            backgroundColor: (h = n.setContext({
              type: "segment",
              p0: i,
              p1: c
            })).backgroundColor,
            borderCapStyle: h.borderCapStyle,
            borderDash: h.borderDash,
            borderDashOffset: h.borderDashOffset,
            borderJoinStyle: h.borderJoinStyle,
            borderWidth: h.borderWidth,
            borderColor: h.borderColor
          }, d = e, (h = t) && JSON.stringify(d) !== JSON.stringify(h) && (o.push({
            start: r,
            end: l - 1,
            loop: u.loop,
            style: t
          }), t = e, r = l - 1), i = c, t = e
        }
        r < l - 1 && (o.push({
          start: r,
          end: l - 1,
          loop: u.loop,
          style: e
        }), r = l - 1)
      }
      var d, h;
      return o
    }(e, i) : t
  }
  var fs = Object.freeze({
    __proto__: null,
    easingEffects: ci,
    color: H,
    getHoverColor: F,
    noop: t,
    uid: z,
    isNullOrUndef: R,
    isArray: B,
    isObject: j,
    isFinite: W,
    finiteOrDefault: V,
    valueOrDefault: q,
    toPercentage: Y,
    toDimension: U,
    callback: X,
    each: G,
    _elementsEqual: K,
    clone: Q,
    _merger: Z,
    merge: tt,
    mergeIf: et,
    _mergerIf: it,
    _deprecated: function (t, e, i, s) {
      void 0 !== e && console.warn(t + ': "' + i + '" is deprecated. Please use "' + s + '" instead')
    },
    resolveObjectKey: nt,
    _capitalize: at,
    defined: ot,
    isFunction: rt,
    setsEqual: lt,
    toFontString: Rt,
    _measureText: Bt,
    _longestText: jt,
    _alignPixel: Wt,
    clearCanvas: Vt,
    drawPoint: qt,
    _isPointInArea: Yt,
    clipArea: Ut,
    unclipArea: Xt,
    _steppedLineTo: Gt,
    _bezierCurveTo: Kt,
    renderText: Qt,
    addRoundedRectPath: Jt,
    _lookup: Zt,
    _lookupByKey: te,
    _rlookupByKey: ee,
    _filterBetween: ie,
    listenArrayEvents: ne,
    unlistenArrayEvents: ae,
    _arrayUnique: oe,
    _createResolver: Fi,
    _attachContext: zi,
    _descriptors: Ri,
    splineCurve: Ji,
    splineCurveMonotone: Zi,
    _updateBezierControlPoints: es,
    _getParentNode: re,
    getStyle: de,
    getRelativePosition: pe,
    getMaximumSize: me,
    retinaScale: ge,
    supportsEventListenerOptions: ve,
    readUsedSize: be,
    fontString: function (t, e, i) {
      return e + " " + t + "px " + i
    },
    requestAnimFrame: o,
    throttled: l,
    debounce: r,
    _toLeftRightCenter: f,
    _alignStartEnd: P,
    _textX: I,
    _pointInLine: is,
    _steppedInterpolation: ss,
    _bezierInterpolation: ns,
    formatNumber: Mi,
    toLineHeight: Se,
    _readValueToProps: Me,
    toTRBL: Ee,
    toTRBLCorners: Ae,
    toPadding: Pe,
    toFont: Ie,
    resolve: Oe,
    _addGrace: $e,
    PI: ft,
    TAU: mt,
    PITAU: gt,
    INFINITY: vt,
    RAD_PER_DEG: bt,
    HALF_PI: _t,
    QUARTER_PI: yt,
    TWO_THIRDS_PI: wt,
    log10: xt,
    sign: Ct,
    niceNum: kt,
    _factorize: Tt,
    isNumber: Dt,
    almostEquals: St,
    almostWhole: Mt,
    _setMinAndMaxByKey: Et,
    toRadians: At,
    toDegrees: Pt,
    _decimalPlaces: It,
    getAngleFromPoint: Ot,
    distanceBetweenPoints: $t,
    _angleDiff: Lt,
    _normalizeAngle: Nt,
    _angleBetween: Ht,
    _limitValue: Ft,
    _int16Range: zt,
    getRtlAdapter: as,
    overrideTextDirection: os,
    restoreTextDirection: rs,
    _boundSegment: ds,
    _boundSegments: hs,
    _computeSegments: us
  });
  class ms {
    constructor(t, e, i) {
      this.type = t, this.scope = e, this.override = i, this.items = Object.create(null)
    }
    isForType(t) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
    }
    register(t) {
      var e, i, r, l, s = Object.getPrototypeOf(t);
      let n;
      "id" in (i = s) && "defaults" in i && (n = this.register(s));
      const a = this.items,
        o = t.id,
        c = this.scope + "." + o;
      if (!o) throw new Error("class does not have id: " + t);
      return o in a || (a[o] = t, e = t, i = c, s = n, s = tt(Object.create(null), [s ? pt.get(s) : {}, pt.get(i), e.defaults]), pt.set(i, s), e.defaultRoutes && (r = i, l = e.defaultRoutes, Object.keys(l).forEach(t => {
        const e = t.split("."),
          i = e.pop(),
          s = [r].concat(e).join("."),
          n = l[t].split("."),
          a = n.pop(),
          o = n.join(".");
        pt.route(s, i, o, a)
      })), e.descriptors && pt.describe(i, e.descriptors), this.override && pt.override(t.id, t.overrides)), c
    }
    get(t) {
      return this.items[t]
    }
    unregister(t) {
      const e = this.items,
        i = t.id,
        s = this.scope;
      i in e && delete e[i], s && i in pt[s] && (delete pt[s][i], this.override && delete ct[i])
    }
  }
  var gs = new class {
    constructor() {
      this.controllers = new ms(Ti, "datasets", !0), this.elements = new ms(Di, "elements"), this.plugins = new ms(Object, "plugins"), this.scales = new ms(Hi, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements]
    }
    add(...t) {
      this._each("register", t)
    }
    remove(...t) {
      this._each("unregister", t)
    }
    addControllers(...t) {
      this._each("register", t, this.controllers)
    }
    addElements(...t) {
      this._each("register", t, this.elements)
    }
    addPlugins(...t) {
      this._each("register", t, this.plugins)
    }
    addScales(...t) {
      this._each("register", t, this.scales)
    }
    getController(t) {
      return this._get(t, this.controllers, "controller")
    }
    getElement(t) {
      return this._get(t, this.elements, "element")
    }
    getPlugin(t) {
      return this._get(t, this.plugins, "plugin")
    }
    getScale(t) {
      return this._get(t, this.scales, "scale")
    }
    removeControllers(...t) {
      this._each("unregister", t, this.controllers)
    }
    removeElements(...t) {
      this._each("unregister", t, this.elements)
    }
    removePlugins(...t) {
      this._each("unregister", t, this.plugins)
    }
    removeScales(...t) {
      this._each("unregister", t, this.scales)
    }
    _each(i, t, s) {
      const n = this;
      [...t].forEach(t => {
        const e = s || n._getRegistryForType(t);
        s || e.isForType(t) || e === n.plugins && t.id ? n._exec(i, e, t) : G(t, t => {
          var e = s || n._getRegistryForType(t);
          n._exec(i, e, t)
        })
      })
    }
    _exec(t, e, i) {
      var s = at(t);
      X(i["before" + s], [], i), e[t](i), X(i["after" + s], [], i)
    }
    _getRegistryForType(e) {
      for (let t = 0; t < this._typedRegistries.length; t++) {
        const i = this._typedRegistries[t];
        if (i.isForType(e)) return i
      }
      return this.plugins
    }
    _get(t, e, i) {
      e = e.get(t);
      if (void 0 === e) throw new Error('"' + t + '" is not a registered ' + i + ".");
      return e
    }
  };
  class vs {
    constructor() {
      this._init = []
    }
    notify(t, e, i, s) {
      var n = this;
      "beforeInit" === e && (n._init = n._createDescriptors(t, !0), n._notify(n._init, t, "install"));
      s = s ? n._descriptors(t).filter(s) : n._descriptors(t), i = n._notify(s, t, e, i);
      return "destroy" === e && (n._notify(s, t, "stop"), n._notify(n._init, t, "uninstall")), i
    }
    _notify(t, e, i, s) {
      s = s || {};
      for (const n of t) {
        const t = n.plugin;
        if (!1 === X(t[i], [e, s, n.options], t) && s.cancelable) return !1
      }
      return !0
    }
    invalidate() {
      R(this._cache) || (this._oldCache = this._cache, this._cache = void 0)
    }
    _descriptors(t) {
      if (this._cache) return this._cache;
      var e = this._cache = this._createDescriptors(t);
      return this._notifyStateChanges(t), e
    }
    _createDescriptors(t, e) {
      var i = t && t.config,
        s = q(i.options && i.options.plugins, {}),
        i = function (t) {
          const e = [],
            i = Object.keys(gs.plugins.items);
          for (let t = 0; t < i.length; t++) e.push(gs.getPlugin(i[t]));
          var s = t.plugins || [];
          for (let t = 0; t < s.length; t++) {
            const i = s[t]; - 1 === e.indexOf(i) && e.push(i)
          }
          return e
        }(i);
      return !1 !== s || e ? function (e, i, s, n) {
        const a = [],
          o = e.getContext();
        for (let t = 0; t < i.length; t++) {
          var r = i[t],
            l = (l = s[r.id], n || !1 !== l ? !0 === l ? {} : l : null);
          null !== l && a.push({
            plugin: r,
            options: function (t, e, i, s) {
              e = t.pluginScopeKeys(e), e = t.getOptionScopes(i, e);
              return t.createResolver(e, s, [""], {
                scriptable: !1,
                indexable: !1,
                allKeys: !0
              })
            }(e.config, r, l, o)
          })
        }
        var l;
        return a
      }(t, i, s, e) : []
    }
    _notifyStateChanges(t) {
      var e = this._oldCache || [],
        i = this._cache,
        s = (t, i) => t.filter(e => !i.some(t => e.plugin.id === t.plugin.id));
      this._notify(s(e, i), t, "stop"), this._notify(s(i, e), t, "start")
    }
  }

  function bs(t, e) {
    var i = pt.datasets[t] || {};
    return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x"
  }

  function _s(t, e) {
    return "x" === t || "y" === t ? t : e.axis || ("top" === (e = e.position) || "bottom" === e ? "x" : "left" === e || "right" === e ? "y" : void 0) || t.charAt(0).toLowerCase()
  }

  function ys(t) {
    const e = t.options || (t.options = {});
    e.plugins = q(e.plugins, {}), e.scales = function (e, i) {
      const a = ct[e.type] || {
          scales: {}
        },
        o = i.scales || {},
        r = bs(e.type, i),
        l = Object.create(null),
        c = Object.create(null);
      return Object.keys(o).forEach(t => {
        const e = o[t],
          i = _s(t, e),
          s = i === r ? "_index_" : "_value_",
          n = a.scales || {};
        l[i] = l[i] || t, c[t] = et(Object.create(null), [{
          axis: i
        }, e, n[i], n[s]])
      }), e.data.datasets.forEach(s => {
        const t = s.type || e.type,
          n = s.indexAxis || bs(t, i),
          a = (ct[t] || {}).scales || {};
        Object.keys(a).forEach(t => {
          var e = function (t, e) {
              let i = t;
              return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i
            }(t, n),
            i = s[e + "AxisID"] || l[e] || e;
          c[i] = c[i] || Object.create(null), et(c[i], [{
            axis: e
          }, o[i], a[t]])
        })
      }), Object.keys(c).forEach(t => {
        t = c[t];
        et(t, [pt.scales[t.type], pt.scale])
      }), c
    }(t, e)
  }

  function ws(t) {
    return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t
  }
  const xs = new Map,
    Cs = new Set;

  function ks(t, e) {
    let i = xs.get(t);
    return i || (i = e(), xs.set(t, i), Cs.add(i)), i
  }
  const Ts = (t, e, i) => {
    i = nt(e, i);
    void 0 !== i && t.add(i)
  };
  class Ds {
    constructor(t) {
      this._config = ((t = (t = t) || {}).data = ws(t.data), ys(t), t), this._scopeCache = new Map, this._resolverCache = new Map
    }
    get type() {
      return this._config.type
    }
    set type(t) {
      this._config.type = t
    }
    get data() {
      return this._config.data
    }
    set data(t) {
      this._config.data = ws(t)
    }
    get options() {
      return this._config.options
    }
    set options(t) {
      this._config.options = t
    }
    get plugins() {
      return this._config.plugins
    }
    update() {
      var t = this._config;
      this.clearCache(), ys(t)
    }
    clearCache() {
      this._scopeCache.clear(), this._resolverCache.clear()
    }
    datasetScopeKeys(t) {
      return ks(t, () => [
        ["datasets." + t, ""]
      ])
    }
    datasetAnimationScopeKeys(t, e) {
      return ks(`${t}.transition.${e}`, () => [
        [`datasets.${t}.transitions.${e}`, "transitions." + e],
        ["datasets." + t, ""]
      ])
    }
    datasetElementScopeKeys(t, e) {
      return ks(`${t}-${e}`, () => [
        [`datasets.${t}.elements.${e}`, "datasets." + t, "elements." + e, ""]
      ])
    }
    pluginScopeKeys(t) {
      const e = t.id;
      return ks(`${this.type}-plugin-${e}`, () => [
        ["plugins." + e, ...t.additionalOptionScopes || []]
      ])
    }
    _cachedScopes(t, e) {
      const i = this._scopeCache;
      let s = i.get(t);
      return s && !e || (s = new Map, i.set(t, s)), s
    }
    getOptionScopes(e, t, i) {
      const {
        options: s,
        type: n
      } = this, a = this._cachedScopes(e, i), o = a.get(t);
      if (o) return o;
      const r = new Set;
      t.forEach(t => {
        e && (r.add(e), t.forEach(t => Ts(r, e, t))), t.forEach(t => Ts(r, s, t)), t.forEach(t => Ts(r, ct[n] || {}, t)), t.forEach(t => Ts(r, pt, t)), t.forEach(t => Ts(r, dt, t))
      });
      i = [...r];
      return Cs.has(t) && a.set(t, i), i
    }
    chartOptionScopes() {
      var {
        options: t,
        type: e
      } = this;
      return [t, ct[e] || {}, pt.datasets[e] || {}, {
        type: e
      }, pt, dt]
    }
    resolveNamedOptions(t, e, i, s = [""]) {
      const n = {
          $shared: !0
        },
        {
          resolver: a,
          subPrefixes: o
        } = Ss(this._resolverCache, t, s);
      let r = a;
      ! function (t, e) {
        const {
          isScriptable: i,
          isIndexable: s
        } = Ri(t);
        for (const n of e)
          if (i(n) && rt(t[n]) || s(n) && B(t[n])) return 1
      }(a, e) || (n.$shared = !1, r = zi(a, i = rt(i) ? i() : i, this.createResolver(t, i, o)));
      for (const t of e) n[t] = r[t];
      return n
    }
    createResolver(t, e, i = [""], s) {
      var {
        resolver: i
      } = Ss(this._resolverCache, t, i);
      return j(e) ? zi(i, e, void 0, s) : i
    }
  }

  function Ss(t, e, i) {
    let s = t.get(e);
    s || (s = new Map, t.set(e, s));
    t = i.join();
    let n = s.get(t);
    return n || (n = {
      resolver: Fi(e, i),
      subPrefixes: i.filter(t => !t.toLowerCase().includes("hover"))
    }, s.set(t, n)), n
  }
  const Ms = ["top", "bottom", "left", "right", "chartArea"];

  function Es(t, e) {
    return "top" === t || "bottom" === t || -1 === Ms.indexOf(t) && "x" === e
  }

  function As(i, s) {
    return function (t, e) {
      return t[i] === e[i] ? t[s] - e[s] : t[i] - e[i]
    }
  }

  function Ps(t) {
    const e = t.chart,
      i = e.options.animation;
    e.notifyPlugins("afterRender"), X(i && i.onComplete, [t], e)
  }

  function Is(t) {
    var e = t.chart,
      i = e.options.animation;
    X(i && i.onProgress, [t], e)
  }

  function Os() {
    return "undefined" != typeof window && "undefined" != typeof document
  }

  function $s(t) {
    return Os() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t = t && t.canvas ? t.canvas : t
  }
  const Ls = {},
    Ns = t => {
      const e = $s(t);
      return Object.values(Ls).filter(t => t.canvas === e).pop()
    };
  class Hs {
    constructor(t, e) {
      var i = this;
      this.config = e = new Ds(e);
      var s = $s(t),
        n = Ns(s);
      if (n) throw new Error("Canvas is already in use. Chart with ID '" + n.id + "' must be destroyed before the canvas can be reused.");
      var a = e.createResolver(e.chartOptionScopes(), i.getContext());
      this.platform = i._initializePlatform(s, e);
      t = i.platform.acquireContext(s, a.aspectRatio), n = t && t.canvas, e = n && n.height, s = n && n.width;
      this.id = z(), this.ctx = t, this.canvas = n, this.width = s, this.height = e, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._sortedMetasets = [], this.scales = {}, this.scale = void 0, this._plugins = new vs, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = r(() => this.update("resize"), a.resizeDelay || 0), Ls[i.id] = i, t && n ? (c.listen(i, "complete", Ps), c.listen(i, "progress", Is), i._initialize(), i.attached && i.update()) : console.clear("Failed to create chart: can't acquire context from the given item")
    }
    get aspectRatio() {
      var {
        options: {
          aspectRatio: t,
          maintainAspectRatio: e
        },
        width: i,
        height: s,
        _aspectRatio: n
      } = this;
      return R(t) ? e && n ? n : s ? i / s : null : t
    }
    get data() {
      return this.config.data
    }
    set data(t) {
      this.config.data = t
    }
    get options() {
      return this._options
    }
    set options(t) {
      this.config.options = t
    }
    _initialize() {
      return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : ge(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this
    }
    _initializePlatform(t, e) {
      return new(e.platform || (!Os() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? Ye : ni))
    }
    clear() {
      return Vt(this.canvas, this.ctx), this
    }
    stop() {
      return c.stop(this), this
    }
    resize(t, e) {
      c.running(this) ? this._resizeBeforeDraw = {
        width: t,
        height: e
      } : this._resize(t, e)
    }
    _resize(t, e) {
      var i = this,
        s = i.options,
        n = i.canvas,
        a = s.maintainAspectRatio && i.aspectRatio,
        t = i.platform.getMaximumSize(n, t, e, a),
        e = i.currentDevicePixelRatio,
        a = s.devicePixelRatio || i.platform.getDevicePixelRatio();
      i.width === t.width && i.height === t.height && e === a || (i.width = t.width, i.height = t.height, i._aspectRatio = i.aspectRatio, ge(i, a, !0), i.notifyPlugins("resize", {
        size: t
      }), X(s.onResize, [i, t], i), i.attached && i._doResize() && i.render())
    }
    ensureScalesHaveIDs() {
      G(this.options.scales || {}, (t, e) => {
        t.id = e
      })
    }
    buildOrUpdateScales() {
      const o = this,
        r = o.options,
        s = r.scales,
        l = o.scales,
        c = Object.keys(l).reduce((t, e) => (t[e] = !1, t), {});
      let t = [];
      s && (t = t.concat(Object.keys(s).map(t => {
        var e = s[t],
          i = _s(t, e),
          t = "r" === i,
          i = "x" === i;
        return {
          options: e,
          dposition: t ? "chartArea" : i ? "bottom" : "left",
          dtype: t ? "radialLinear" : i ? "category" : "linear"
        }
      }))), G(t, t => {
        const e = t.options,
          i = e.id,
          s = _s(i, e),
          n = q(e.type, t.dtype);
        void 0 !== e.position && Es(e.position, s) === Es(t.dposition) || (e.position = t.dposition), c[i] = !0;
        let a = null;
        i in l && l[i].type === n ? a = l[i] : (a = new(gs.getScale(n))({
          id: i,
          type: n,
          ctx: o.ctx,
          chart: o
        }), l[a.id] = a), a.init(e, r)
      }), G(c, (t, e) => {
        t || delete l[e]
      }), G(l, t => {
        Ve.configure(o, t, t.options), Ve.addBox(o, t)
      })
    }
    _updateMetasetIndex(t, e) {
      const i = this._metasets,
        s = t.index;
      s !== e && (i[s] = i[e], (i[e] = t).index = e)
    }
    _updateMetasets() {
      const t = this._metasets,
        e = this.data.datasets.length,
        i = t.length;
      if (e < i) {
        for (let t = e; t < i; ++t) this._destroyDatasetMeta(t);
        t.splice(e, i - e)
      }
      this._sortedMetasets = t.slice(0).sort(As("order", "index"))
    }
    _removeUnreferencedMetasets() {
      const i = this,
        {
          _metasets: t,
          data: {
            datasets: s
          }
        } = i;
      t.length > s.length && delete i._stacks, t.forEach((e, t) => {
        0 === s.filter(t => t === e._dataset).length && i._destroyDatasetMeta(t)
      })
    }
    buildOrUpdateControllers() {
      const e = this,
        i = [],
        s = e.data.datasets;
      let n, a;
      for (e._removeUnreferencedMetasets(), n = 0, a = s.length; n < a; n++) {
        const a = s[n];
        let t = e.getDatasetMeta(n);
        var o = a.type || e.config.type;
        if (t.type && t.type !== o && (e._destroyDatasetMeta(n), t = e.getDatasetMeta(n)), t.type = o, t.indexAxis = a.indexAxis || bs(o, e.options), t.order = a.order || 0, e._updateMetasetIndex(t, n), t.label = "" + a.label, t.visible = e.isDatasetVisible(n), t.controller) t.controller.updateIndex(n), t.controller.linkScales();
        else {
          const s = gs.getController(o),
            {
              datasetElementType: a,
              dataElementType: r
            } = pt.datasets[o];
          Object.assign(s.prototype, {
            dataElementType: gs.getElement(r),
            datasetElementType: a && gs.getElement(a)
          }), t.controller = new s(e, n), i.push(t.controller)
        }
      }
      return e._updateMetasets(), i
    }
    _resetElements() {
      const i = this;
      G(i.data.datasets, (t, e) => {
        i.getDatasetMeta(e).controller.reset()
      }, i)
    }
    reset() {
      this._resetElements(), this.notifyPlugins("reset")
    }
    update(t) {
      const s = this,
        n = s.config;
      n.update(), s._options = n.createResolver(n.chartOptionScopes(), s.getContext()), G(s.scales, t => {
        Ve.removeBox(s, t)
      });
      var a = s._animationsDisabled = !s.options.animation;
      s.ensureScalesHaveIDs(), s.buildOrUpdateScales();
      const o = new Set(Object.keys(s._listeners)),
        e = new Set(s.options.events);
      if (lt(o, e) || (s.unbindEvents(), s.bindEvents()), s._plugins.invalidate(), !1 !== s.notifyPlugins("beforeUpdate", {
          mode: t,
          cancelable: !0
        })) {
        const r = s.buildOrUpdateControllers();
        s.notifyPlugins("beforeElementsUpdate");
        let i = 0;
        for (let t = 0, e = s.data.datasets.length; t < e; t++) {
          const {
            controller: n
          } = s.getDatasetMeta(t), o = !a && -1 === r.indexOf(n);
          n.buildOrUpdateElements(o), i = Math.max(+n.getMaxOverflow(), i)
        }
        s._minPadding = i, s._updateLayout(i), a || G(r, t => {
          t.reset()
        }), s._updateDatasets(t), s.notifyPlugins("afterUpdate", {
          mode: t
        }), s._layers.sort(As("z", "_idx")), s._lastEvent && s._eventHandler(s._lastEvent, !0), s.render()
      }
    }
    _updateLayout(t) {
      const e = this;
      if (!1 !== e.notifyPlugins("beforeLayout", {
          cancelable: !0
        })) {
        Ve.update(e, e.width, e.height, t);
        const i = e.chartArea,
          s = i.width <= 0 || i.height <= 0;
        e._layers = [], G(e.boxes, t => {
          s && "chartArea" === t.position || (t.configure && t.configure(), e._layers.push(...t._layers()))
        }, e), e._layers.forEach((t, e) => {
          t._idx = e
        }), e.notifyPlugins("afterLayout")
      }
    }
    _updateDatasets(i) {
      var s = "function" == typeof i;
      if (!1 !== this.notifyPlugins("beforeDatasetsUpdate", {
          mode: i,
          cancelable: !0
        })) {
        for (let t = 0, e = this.data.datasets.length; t < e; ++t) this._updateDataset(t, s ? i({
          datasetIndex: t
        }) : i);
        this.notifyPlugins("afterDatasetsUpdate", {
          mode: i
        })
      }
    }
    _updateDataset(t, e) {
      const i = this.getDatasetMeta(t),
        s = {
          meta: i,
          index: t,
          mode: e,
          cancelable: !0
        };
      !1 !== this.notifyPlugins("beforeDatasetUpdate", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", s))
    }
    render() {
      !1 !== this.notifyPlugins("beforeRender", {
        cancelable: !0
      }) && (c.has(this) ? this.attached && !c.running(this) && c.start(this) : (this.draw(), Ps({
        chart: this
      })))
    }
    draw() {
      var t = this;
      let e;
      if (t._resizeBeforeDraw) {
        const {
          width: e,
          height: i
        } = t._resizeBeforeDraw;
        t._resize(e, i), t._resizeBeforeDraw = null
      }
      if (t.clear(), !(t.width <= 0 || t.height <= 0) && !1 !== t.notifyPlugins("beforeDraw", {
          cancelable: !0
        })) {
        const i = t._layers;
        for (e = 0; e < i.length && i[e].z <= 0; ++e) i[e].draw(t.chartArea);
        for (t._drawDatasets(); e < i.length; ++e) i[e].draw(t.chartArea);
        t.notifyPlugins("afterDraw")
      }
    }
    _getSortedDatasetMetas(t) {
      const e = this._sortedMetasets,
        i = [];
      let s, n;
      for (s = 0, n = e.length; s < n; ++s) {
        const n = e[s];
        t && !n.visible || i.push(n)
      }
      return i
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(!0)
    }
    _drawDatasets() {
      if (!1 !== this.notifyPlugins("beforeDatasetsDraw", {
          cancelable: !0
        })) {
        var e = this.getSortedVisibleDatasetMetas();
        for (let t = e.length - 1; 0 <= t; --t) this._drawDataset(e[t]);
        this.notifyPlugins("afterDatasetsDraw")
      }
    }
    _drawDataset(t) {
      const e = this.ctx,
        i = t._clip,
        s = this.chartArea,
        n = {
          meta: t,
          index: t.index,
          cancelable: !0
        };
      !1 !== this.notifyPlugins("beforeDatasetDraw", n) && (Ut(e, {
        left: !1 === i.left ? 0 : s.left - i.left,
        right: !1 === i.right ? this.width : s.right + i.right,
        top: !1 === i.top ? 0 : s.top - i.top,
        bottom: !1 === i.bottom ? this.height : s.bottom + i.bottom
      }), t.controller.draw(), Xt(e), n.cancelable = !1, this.notifyPlugins("afterDatasetDraw", n))
    }
    getElementsAtEventForMode(t, e, i, s) {
      const n = ke.modes[e];
      return "function" == typeof n ? n(this, t, i, s) : []
    }
    getDatasetMeta(t) {
      const e = this.data.datasets[t],
        i = this._metasets;
      let s = i.filter(t => t && t._dataset === e).pop();
      return s = s || (i[t] = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: e && e.order || 0,
        index: t,
        _dataset: e,
        _parsed: [],
        _sorted: !1
      }), s
    }
    getContext() {
      return this.$context || (this.$context = {
        chart: this,
        type: "chart"
      })
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length
    }
    isDatasetVisible(t) {
      var e = this.data.datasets[t];
      if (!e) return !1;
      t = this.getDatasetMeta(t);
      return "boolean" == typeof t.hidden ? !t.hidden : !e.hidden
    }
    setDatasetVisibility(t, e) {
      this.getDatasetMeta(t).hidden = !e
    }
    toggleDataVisibility(t) {
      this._hiddenIndices[t] = !this._hiddenIndices[t]
    }
    getDataVisibility(t) {
      return !this._hiddenIndices[t]
    }
    _updateDatasetVisibility(e, t) {
      const i = t ? "show" : "hide",
        s = this.getDatasetMeta(e),
        n = s.controller._resolveAnimations(void 0, i);
      this.setDatasetVisibility(e, t), n.update(s, {
        visible: t
      }), this.update(t => t.datasetIndex === e ? i : void 0)
    }
    hide(t) {
      this._updateDatasetVisibility(t, !1)
    }
    show(t) {
      this._updateDatasetVisibility(t, !0)
    }
    _destroyDatasetMeta(t) {
      const e = this._metasets && this._metasets[t];
      e && e.controller && (e.controller._destroy(), delete this._metasets[t])
    }
    destroy() {
      var t = this,
        {
          canvas: e,
          ctx: i
        } = t;
      let s, n;
      for (t.stop(), c.remove(t), s = 0, n = t.data.datasets.length; s < n; ++s) t._destroyDatasetMeta(s);
      t.config.clearCache(), e && (t.unbindEvents(), Vt(e, i), t.platform.releaseContext(i), t.canvas = null, t.ctx = null), t.notifyPlugins("destroy"), delete Ls[t.id]
    }
    toBase64Image(...t) {
      return this.canvas.toDataURL(...t)
    }
    bindEvents() {
      const s = this,
        i = s._listeners,
        n = s.platform,
        e = (t, e) => {
          n.addEventListener(s, t, e), i[t] = e
        },
        a = (t, e) => {
          i[t] && (n.removeEventListener(s, t, e), delete i[t])
        };
      let o = function (t, e, i) {
        t.offsetX = e, t.offsetY = i, s._eventHandler(t)
      };
      if (G(s.options.events, t => e(t, o)), s.options.responsive) {
        let t;
        o = (t, e) => {
          s.canvas && s.resize(t, e)
        };
        const r = () => {
          a("attach", r), s.attached = !0, s.resize(), e("resize", o), e("detach", t)
        };
        t = () => {
          s.attached = !1, a("resize", o), e("attach", r)
        }, (n.isAttached(s.canvas) ? r : t)()
      } else s.attached = !0
    }
    unbindEvents() {
      const i = this,
        t = i._listeners;
      t && (i._listeners = {}, G(t, (t, e) => {
        i.platform.removeEventListener(i, e, t)
      }))
    }
    updateHoverStyle(t, e, i) {
      var s = i ? "set" : "remove";
      let n, a, o, r;
      for ("dataset" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller["_" + s + "DatasetHoverStyle"]()), o = 0, r = t.length; o < r; ++o) {
        const e = (a = t[o]) && this.getDatasetMeta(a.datasetIndex).controller;
        e && e[s + "HoverStyle"](a.element, a.datasetIndex, a.index)
      }
    }
    getActiveElements() {
      return this._active || []
    }
    setActiveElements(t) {
      const s = this,
        e = s._active || [],
        i = t.map(({
          datasetIndex: t,
          index: e
        }) => {
          var i = s.getDatasetMeta(t);
          if (!i) throw new Error("No dataset found at index " + t);
          return {
            datasetIndex: t,
            element: i.data[e],
            index: e
          }
        });
      K(i, e) || (s._active = i, s._updateHoverStyles(i, e))
    }
    notifyPlugins(t, e, i) {
      return this._plugins.notify(this, t, e, i)
    }
    _updateHoverStyles(t, e, i) {
      var s = this.options.hover,
        n = (t, i) => t.filter(e => !i.some(t => e.datasetIndex === t.datasetIndex && e.index === t.index)),
        a = n(e, t),
        e = i ? t : n(t, e);
      a.length && this.updateHoverStyle(a, s.mode, !1), e.length && s.mode && this.updateHoverStyle(e, s.mode, !0)
    }
    _eventHandler(e, t) {
      const i = {
          event: e,
          replay: t,
          cancelable: !0
        },
        s = t => (t.options.events || this.options.events).includes(e.type);
      if (!1 !== this.notifyPlugins("beforeEvent", i, s)) {
        t = this._handleEvent(e, t);
        return i.cancelable = !1, this.notifyPlugins("afterEvent", i, s), (t || i.changed) && this.render(), this
      }
    }
    _handleEvent(t, e) {
      var i = this,
        {
          _active: s = [],
          options: n
        } = i,
        a = n.hover;
      let o = [],
        r, l = null;
      return "mouseout" !== t.type && (o = i.getElementsAtEventForMode(t, a.mode, a, e), l = "click" === t.type ? i._lastEvent : t), i._lastEvent = null, Yt(t, i.chartArea, i._minPadding) && (X(n.onHover, [t, o, i], i), "mouseup" !== t.type && "click" !== t.type && "contextmenu" !== t.type || X(n.onClick, [t, o, i], i)), ((r = !K(o, s)) || e) && (i._active = o, i._updateHoverStyles(o, s, e)), i._lastEvent = l, r
    }
  }
  const Fs = () => G(Hs.instances, t => t._plugins.invalidate());

  function zs() {
    throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.")
  }
  Object.defineProperties(Hs, {
    defaults: {
      enumerable: !0,
      value: pt
    },
    instances: {
      enumerable: !0,
      value: Ls
    },
    overrides: {
      enumerable: !0,
      value: ct
    },
    registry: {
      enumerable: !0,
      value: gs
    },
    version: {
      enumerable: !0,
      value: "3.2.0"
    },
    getChart: {
      enumerable: !0,
      value: Ns
    },
    register: {
      enumerable: !0,
      value: (...t) => {
        gs.add(...t), Fs()
      }
    },
    unregister: {
      enumerable: !0,
      value: (...t) => {
        gs.remove(...t), Fs()
      }
    }
  });
  class Rs {
    constructor(t) {
      this.options = t || {}
    }
    formats() {
      return zs()
    }
    parse(t, e) {
      return zs()
    }
    format(t, e) {
      return zs()
    }
    add(t, e, i) {
      return zs()
    }
    diff(t, e, i) {
      return zs()
    }
    startOf(t, e, i) {
      return zs()
    }
    endOf(t, e) {
      return zs()
    }
  }
  Rs.override = function (t) {
    Object.assign(Rs.prototype, t)
  };
  var Bs = {
    _date: Rs
  };

  function js(t, e, i, s) {
    return B(t) ? function (t, e, i, s) {
      var n = i.parse(t[0], s),
        a = i.parse(t[1], s),
        t = Math.min(n, a),
        s = Math.max(n, a);
      let o = t,
        r = s;
      Math.abs(t) > Math.abs(s) && (o = s, r = t), e[i.axis] = r, e._custom = {
        barStart: o,
        barEnd: r,
        start: n,
        end: a,
        min: t,
        max: s
      }
    }(t, e, i, s) : e[i.axis] = i.parse(t, s), e
  }

  function Ws(t, e, i, s) {
    const n = t.iScale,
      a = t.vScale,
      o = n.getLabels(),
      r = n === a,
      l = [];
    let c, d, h, u;
    for (d = (c = i) + s; c < d; ++c) u = e[c], h = {}, h[n.axis] = r || n.parse(o[c], c), l.push(js(u, h, a, c));
    return l
  }

  function Vs(t) {
    return t && void 0 !== t.barStart && void 0 !== t.barEnd
  }
  class qs extends Ti {
    parsePrimitiveData(t, e, i, s) {
      return Ws(t, e, i, s)
    }
    parseArrayData(t, e, i, s) {
      return Ws(t, e, i, s)
    }
    parseObjectData(t, e, i, s) {
      const {
        iScale: n,
        vScale: a
      } = t, {
        xAxisKey: o = "x",
        yAxisKey: r = "y"
      } = this._parsing, l = "x" === n.axis ? o : r, c = "x" === a.axis ? o : r, d = [];
      let h, u, p, f;
      for (u = (h = i) + s; h < u; ++h) f = e[h], p = {}, p[n.axis] = n.parse(nt(f, l), h), d.push(js(nt(f, c), p, a, h));
      return d
    }
    updateRangeFromParsed(t, e, i, s) {
      super.updateRangeFromParsed(t, e, i, s);
      i = i._custom;
      i && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, i.min), t.max = Math.max(t.max, i.max))
    }
    getLabelAndValue(t) {
      const e = this._cachedMeta,
        {
          iScale: i,
          vScale: s
        } = e,
        n = this.getParsed(t),
        a = n._custom,
        o = Vs(a) ? "[" + a.start + ", " + a.end + "]" : "" + s.getLabelForValue(n[s.axis]);
      return {
        label: "" + i.getLabelForValue(n[i.axis]),
        value: o
      }
    }
    initialize() {
      this.enableOptionSharing = !0, super.initialize(), this._cachedMeta.stack = this.getDataset().stack
    }
    update(t) {
      var e = this._cachedMeta;
      this.updateElements(e.data, 0, e.data.length, t)
    }
    updateElements(e, i, s, n) {
      const a = this,
        o = "reset" === n,
        r = a._cachedMeta.vScale,
        l = r.getBasePixel(),
        c = r.isHorizontal(),
        d = a._getRuler(),
        t = a.resolveDataElementOptions(i, n),
        h = a.getSharedOptions(t),
        u = a.includeOptions(n, h);
      a.updateSharedOptions(h, n, t);
      for (let t = i; t < i + s; t++) {
        const i = a.getParsed(t),
          s = o || R(i[r.axis]) ? {
            base: l,
            head: l
          } : a._calculateBarValuePixels(t),
          p = a._calculateBarIndexPixels(t, d),
          f = (i._stacks || {})[r.axis],
          m = {
            horizontal: c,
            base: s.base,
            enableBorderRadius: !f || Vs(i._custom) || a.index === f._top || a.index === f._bottom,
            x: c ? s.head : p.center,
            y: c ? p.center : s.head,
            height: c ? p.size : void 0,
            width: c ? void 0 : p.size
          };
        u && (m.options = h || a.resolveDataElementOptions(t, n)), a.updateElement(e[t], t, m, n)
      }
    }
    _getStacks(t, e) {
      const i = this._cachedMeta.iScale,
        s = i.getMatchingVisibleMetas(this._type),
        n = i.options.stacked,
        a = s.length,
        o = [];
      let r, l;
      for (r = 0; r < a; ++r) {
        if (l = s[r], void 0 !== e) {
          const t = l.controller.getParsed(e)[l.controller._cachedMeta.vScale.axis];
          if (R(t) || isNaN(t)) continue
        }
        if ((!1 === n || -1 === o.indexOf(l.stack) || void 0 === n && void 0 === l.stack) && o.push(l.stack), l.index === t) break
      }
      return o.length || o.push(void 0), o
    }
    _getStackCount(t) {
      return this._getStacks(void 0, t).length
    }
    _getStackIndex(t, e, i) {
      const s = this._getStacks(t, i),
        n = void 0 !== e ? s.indexOf(e) : -1;
      return -1 === n ? s.length - 1 : n
    }
    _getRuler() {
      const t = this.options,
        e = this._cachedMeta,
        i = e.iScale,
        s = [];
      let n, a;
      for (n = 0, a = e.data.length; n < a; ++n) s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));
      var o = t.barThickness;
      return {
        min: o || function (t) {
          var e = function (s) {
            if (!s._cache.$bar) {
              const n = s.getMatchingVisibleMetas("bar");
              let i = [];
              for (let t = 0, e = n.length; t < e; t++) i = i.concat(n[t].controller.getAllParsedValues(s));
              s._cache.$bar = oe(i.sort((t, e) => t - e))
            }
            return s._cache.$bar
          }(t);
          let i, s, n, a, o = t._length;
          var r = () => {
            o = Math.min(o, i && Math.abs(n - a) || o), a = n
          };
          for (i = 0, s = e.length; i < s; ++i) n = t.getPixelForValue(e[i]), r();
          for (i = 0, s = t.ticks.length; i < s; ++i) n = t.getPixelForTick(i), r();
          return o
        }(i),
        pixels: s,
        start: i._startPixel,
        end: i._endPixel,
        stackCount: this._getStackCount(),
        scale: i,
        grouped: t.grouped,
        ratio: o ? 1 : t.categoryPercentage * t.barPercentage
      }
    }
    _calculateBarValuePixels(t) {
      const {
        vScale: e,
        _stacked: i
      } = this._cachedMeta, {
        base: s,
        minBarLength: n
      } = this.options, a = this.getParsed(t), o = a._custom, r = Vs(o);
      let l, c, d = a[e.axis],
        h = 0,
        u = i ? this.applyStack(e, a, i) : d;
      u !== d && (h = u - d, u = d), r && (d = o.barStart, u = o.barEnd - o.barStart, 0 !== d && Ct(d) !== Ct(o.barEnd) && (h = 0), h += d);
      var p = R(s) || r ? h : s;
      let f = e.getPixelForValue(p);
      l = this.chart.getDataVisibility(t) ? e.getPixelForValue(h + u) : f, c = l - f, void 0 !== n && Math.abs(c) < n && (c = c < 0 ? -n : n, 0 === d && (f -= c / 2), l = f + c);
      t = s || 0;
      if (f === e.getPixelForValue(t)) {
        const m = e.getLineWidthForValue(t) / 2;
        0 < c ? (f += m, c -= m) : c < 0 && (f -= m, c += m)
      }
      return {
        size: c,
        base: f,
        head: l,
        center: l + c / 2
      }
    }
    _calculateBarIndexPixels(t, e) {
      const i = e.scale,
        s = this.options,
        n = s.skipNull,
        a = q(s.maxBarThickness, 1 / 0);
      let o, r;
      if (e.grouped) {
        const i = n ? this._getStackCount(t) : e.stackCount,
          l = ("flex" === s.barThickness ? function (t, e, i, s) {
            var n = e.pixels,
              a = n[t];
            let o = 0 < t ? n[t - 1] : null,
              r = t < n.length - 1 ? n[t + 1] : null;
            t = i.categoryPercentage;
            null === o && (o = a - (null === r ? e.end - e.start : r - a)), null === r && (r = a + a - o);
            a -= (a - Math.min(o, r)) / 2 * t;
            return {
              chunk: Math.abs(r - o) / 2 * t / s,
              ratio: i.barPercentage,
              start: a
            }
          } : function (t, e, i, s) {
            var n = i.barThickness;
            let a, o;
            return o = R(n) ? (a = e.min * i.categoryPercentage, i.barPercentage) : (a = n * s, 1), {
              chunk: a / s,
              ratio: o,
              start: e.pixels[t] - a / 2
            }
          })(t, e, s, i),
          c = this._getStackIndex(this.index, this._cachedMeta.stack, n ? t : void 0);
        o = l.start + l.chunk * c + l.chunk / 2, r = Math.min(a, l.chunk * l.ratio)
      } else o = i.getPixelForValue(this.getParsed(t)[i.axis], t), r = Math.min(a, e.min * e.ratio);
      return {
        base: o - r / 2,
        head: o + r / 2,
        center: o,
        size: r
      }
    }
    draw() {
      const t = this.chart,
        e = this._cachedMeta,
        i = e.vScale,
        s = e.data,
        n = s.length;
      let a = 0;
      for (Ut(t.ctx, t.chartArea); a < n; ++a) null !== this.getParsed(a)[i.axis] && s[a].draw(this._ctx);
      Xt(t.ctx)
    }
  }
  qs.id = "bar", qs.defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: .8,
    barPercentage: .9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "base", "width", "height"]
      }
    }
  }, qs.overrides = {
    interaction: {
      mode: "index"
    },
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  class Ys extends Ti {
    initialize() {
      this.enableOptionSharing = !0, super.initialize()
    }
    parseObjectData(t, e, i, s) {
      const {
        xScale: n,
        yScale: a
      } = t, {
        xAxisKey: o = "x",
        yAxisKey: r = "y"
      } = this._parsing, l = [];
      let c, d, h;
      for (d = (c = i) + s; c < d; ++c) h = e[c], l.push({
        x: n.parse(nt(h, o), c),
        y: a.parse(nt(h, r), c),
        _custom: h && h.r && +h.r
      });
      return l
    }
    getMaxOverflow() {
      const {
        data: e,
        _parsed: i
      } = this._cachedMeta;
      let s = 0;
      for (let t = e.length - 1; 0 <= t; --t) s = Math.max(s, e[t].size() / 2, i[t]._custom);
      return 0 < s && s
    }
    getLabelAndValue(t) {
      const e = this._cachedMeta,
        {
          xScale: i,
          yScale: s
        } = e,
        n = this.getParsed(t),
        a = i.getLabelForValue(n.x),
        o = s.getLabelForValue(n.y),
        r = n._custom;
      return {
        label: e.label,
        value: "(" + a + ", " + o + (r ? ", " + r : "") + ")"
      }
    }
    update(t) {
      var e = this._cachedMeta.data;
      this.updateElements(e, 0, e.length, t)
    }
    updateElements(e, i, s, n) {
      const a = "reset" === n,
        {
          xScale: o,
          yScale: r
        } = this._cachedMeta,
        t = this.resolveDataElementOptions(i, n),
        l = this.getSharedOptions(t),
        c = this.includeOptions(n, l);
      for (let t = i; t < i + s; t++) {
        const i = e[t],
          s = !a && this.getParsed(t),
          l = a ? o.getPixelForDecimal(.5) : o.getPixelForValue(s.x),
          d = a ? r.getBasePixel() : r.getPixelForValue(s.y),
          h = {
            x: l,
            y: d,
            skip: isNaN(l) || isNaN(d)
          };
        c && (h.options = this.resolveDataElementOptions(t, n), a && (h.options.radius = 0)), this.updateElement(i, t, h, n)
      }
      this.updateSharedOptions(l, n, t)
    }
    resolveDataElementOptions(t, e) {
      var i = this.getParsed(t);
      let s = super.resolveDataElementOptions(t, e);
      s.$shared && (s = Object.assign({}, s, {
        $shared: !1
      }));
      t = s.radius;
      return "active" !== e && (s.radius = 0), s.radius += q(i && i._custom, t), s
    }
  }
  Ys.id = "bubble", Ys.defaults = {
    datasetElementType: !1,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "borderWidth", "radius"]
      }
    }
  }, Ys.overrides = {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          title: () => ""
        }
      }
    }
  };
  class Us extends Ti {
    constructor(t, e) {
      super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0
    }
    linkScales() {}
    parse(t, e) {
      const i = this.getDataset().data,
        s = this._cachedMeta;
      let n, a;
      for (a = (n = t) + e; n < a; ++n) s._parsed[n] = +i[n]
    }
    _getRotation() {
      return At(this.options.rotation - 90)
    }
    _getCircumference() {
      return At(this.options.circumference)
    }
    _getRotationExtents() {
      let e = mt,
        i = -mt;
      for (let t = 0; t < this.chart.data.datasets.length; ++t)
        if (this.chart.isDatasetVisible(t)) {
          const s = this.chart.getDatasetMeta(t).controller,
            n = s._getRotation(),
            a = s._getCircumference();
          e = Math.min(e, n), i = Math.max(i, n + a)
        } return {
        rotation: e,
        circumference: i - e
      }
    }
    update(t) {
      const e = this,
        i = e.chart,
        {
          chartArea: s
        } = i,
        n = e._cachedMeta,
        a = n.data,
        o = e.getMaxBorderWidth() + e.getMaxOffset(a),
        r = Math.max((Math.min(s.width, s.height) - o) / 2, 0),
        l = Math.min(Y(e.options.cutout, r), 1),
        c = e._getRingWeight(e.index),
        {
          circumference: d,
          rotation: h
        } = e._getRotationExtents(),
        {
          ratioX: u,
          ratioY: p,
          offsetX: f,
          offsetY: m
        } = function (t, e, s) {
          let i = 1,
            n = 1,
            a = 0,
            o = 0;
          if (e < mt) {
            const r = t,
              l = r + e,
              c = Math.cos(r),
              d = Math.sin(r),
              h = Math.cos(l),
              u = Math.sin(l),
              p = (t, e, i) => Ht(t, r, l) ? 1 : Math.max(e, e * s, i, i * s),
              f = (t, e, i) => Ht(t, r, l) ? -1 : Math.min(e, e * s, i, i * s),
              m = p(0, c, h),
              g = p(_t, d, u),
              v = f(ft, c, h),
              b = f(ft + _t, d, u);
            i = (m - v) / 2, n = (g - b) / 2, a = -(m + v) / 2, o = -(g + b) / 2
          }
          return {
            ratioX: i,
            ratioY: n,
            offsetX: a,
            offsetY: o
          }
        }(h, d, l),
        g = (s.width - o) / u,
        v = (s.height - o) / p,
        b = Math.max(Math.min(g, v) / 2, 0),
        _ = U(e.options.radius, b),
        y = (_ - Math.max(_ * l, 0)) / e._getVisibleDatasetWeightTotal();
      e.offsetX = f * _, e.offsetY = m * _, n.total = e.calculateTotal(), e.outerRadius = _ - y * e._getRingWeightOffset(e.index), e.innerRadius = Math.max(e.outerRadius - y * c, 0), e.updateElements(a, 0, a.length, t)
    }
    _circumference(t, e) {
      var i = this.options,
        s = this._cachedMeta,
        n = this._getCircumference();
      return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] ? 0 : this.calculateCircumference(s._parsed[t] * n / mt)
    }
    updateElements(t, e, i, s) {
      const n = this,
        a = "reset" === s,
        o = n.chart,
        r = o.chartArea,
        l = o.options.animation,
        c = (r.left + r.right) / 2,
        d = (r.top + r.bottom) / 2,
        h = a && l.animateScale,
        u = h ? 0 : n.innerRadius,
        p = h ? 0 : n.outerRadius,
        f = n.resolveDataElementOptions(e, s),
        m = n.getSharedOptions(f),
        g = n.includeOptions(s, m);
      let v, b = n._getRotation();
      for (v = 0; v < e; ++v) b += n._circumference(v, a);
      for (v = e; v < e + i; ++v) {
        const e = n._circumference(v, a),
          i = t[v],
          o = {
            x: c + n.offsetX,
            y: d + n.offsetY,
            startAngle: b,
            endAngle: b + e,
            circumference: e,
            outerRadius: p,
            innerRadius: u
          };
        g && (o.options = m || n.resolveDataElementOptions(v, s)), b += e, n.updateElement(i, v, o, s)
      }
      n.updateSharedOptions(m, s, f)
    }
    calculateTotal() {
      const t = this._cachedMeta,
        e = t.data;
      let i, s = 0;
      for (i = 0; i < e.length; i++) {
        const e = t._parsed[i];
        null !== e && !isNaN(e) && this.chart.getDataVisibility(i) && (s += Math.abs(e))
      }
      return s
    }
    calculateCircumference(t) {
      var e = this._cachedMeta.total;
      return 0 < e && !isNaN(t) ? mt * (Math.abs(t) / e) : 0
    }
    getLabelAndValue(t) {
      var e = this._cachedMeta,
        i = this.chart,
        s = i.data.labels || [],
        i = Mi(e._parsed[t], i.options.locale);
      return {
        label: s[t] || "",
        value: i
      }
    }
    getMaxBorderWidth(t) {
      let e = 0;
      const i = this.chart;
      let s, n, a, o, r;
      if (!t)
        for (s = 0, n = i.data.datasets.length; s < n; ++s)
          if (i.isDatasetVisible(s)) {
            t = (a = i.getDatasetMeta(s)).data, o = a.controller, o !== this && o.configure();
            break
          } if (!t) return 0;
      for (s = 0, n = t.length; s < n; ++s) "inner" !== (r = o.resolveDataElementOptions(s)).borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));
      return e
    }
    getMaxOffset(i) {
      let s = 0;
      for (let t = 0, e = i.length; t < e; ++t) {
        const i = this.resolveDataElementOptions(t);
        s = Math.max(s, i.offset || 0, i.hoverOffset || 0)
      }
      return s
    }
    _getRingWeightOffset(e) {
      let i = 0;
      for (let t = 0; t < e; ++t) this.chart.isDatasetVisible(t) && (i += this._getRingWeight(t));
      return i
    }
    _getRingWeight(t) {
      return Math.max(q(this.chart.data.datasets[t].weight, 1), 0)
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
    }
  }
  Us.id = "doughnut", Us.defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth"]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    indexAxis: "r"
  }, Us.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(s) {
            const t = s.data;
            return t.labels.length && t.datasets.length ? t.labels.map((t, e) => {
              var i = s.getDatasetMeta(0).controller.getStyle(e);
              return {
                text: t,
                fillStyle: i.backgroundColor,
                strokeStyle: i.borderColor,
                lineWidth: i.borderWidth,
                hidden: !s.getDataVisibility(e),
                index: e
              }
            }) : []
          }
        },
        onClick(t, e, i) {
          i.chart.toggleDataVisibility(e.index), i.chart.update()
        }
      },
      tooltip: {
        callbacks: {
          title: () => "",
          label(t) {
            let e = t.label;
            t = ": " + t.formattedValue;
            return B(e) ? (e = e.slice(), e[0] += t) : e += t, e
          }
        }
      }
    }
  };
  class Xs extends Ti {
    initialize() {
      this.enableOptionSharing = !0, super.initialize()
    }
    update(t) {
      const e = this._cachedMeta,
        {
          dataset: i,
          data: s = [],
          _dataset: n
        } = e,
        a = this.chart._animationsDisabled;
      let {
        start: o,
        count: r
      } = function (t, e, i) {
        var s = e.length;
        let n = 0,
          a = s;
        if (t._sorted) {
          const {
            iScale: o,
            _parsed: r
          } = t, l = o.axis, {
            min: c,
            max: d,
            minDefined: h,
            maxDefined: u
          } = o.getUserBounds();
          h && (n = Ft(Math.min(te(r, o.axis, c).lo, i ? s : te(e, l, o.getPixelForValue(c)).lo), 0, s - 1)), a = u ? Ft(Math.max(te(r, o.axis, d).hi + 1, i ? 0 : te(e, l, o.getPixelForValue(d)).hi + 1), n, s) - n : s - n
        }
        return {
          start: n,
          count: a
        }
      }(e, s, a);
      this._drawStart = o, this._drawCount = r,
        function (t) {
          var {
            xScale: e,
            yScale: i,
            _scaleRanges: s
          } = t, n = {
            xmin: e.min,
            xmax: e.max,
            ymin: i.min,
            ymax: i.max
          };
          if (!s) return t._scaleRanges = n, 1;
          i = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;
          return Object.assign(s, n), i
        }(e) && (o = 0, r = s.length), i._decimated = !!n._decimated, i.points = s;
      const l = this.resolveDatasetElementOptions(t);
      this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {
        animated: !a,
        options: l
      }, t), this.updateElements(s, o, r, t)
    }
    updateElements(e, i, s, n) {
      const a = this,
        o = "reset" === n,
        {
          xScale: r,
          yScale: l,
          _stacked: c
        } = a._cachedMeta,
        t = a.resolveDataElementOptions(i, n),
        d = a.getSharedOptions(t),
        h = a.includeOptions(n, d),
        u = a.options.spanGaps,
        p = Dt(u) ? u : Number.POSITIVE_INFINITY,
        f = a.chart._animationsDisabled || o || "none" === n;
      let m = 0 < i && a.getParsed(i - 1);
      for (let t = i; t < i + s; ++t) {
        const i = e[t],
          s = a.getParsed(t),
          u = f ? i : {},
          g = R(s.y),
          v = u.x = r.getPixelForValue(s.x, t),
          b = u.y = o || g ? l.getBasePixel() : l.getPixelForValue(c ? a.applyStack(l, s, c) : s.y, t);
        u.skip = isNaN(v) || isNaN(b) || g, u.stop = 0 < t && s.x - m.x > p, u.parsed = s, h && (u.options = d || a.resolveDataElementOptions(t, n)), f || a.updateElement(i, t, u, n), m = s
      }
      a.updateSharedOptions(d, n, t)
    }
    getMaxOverflow() {
      const t = this._cachedMeta,
        e = t.dataset,
        i = e.options && e.options.borderWidth || 0,
        s = t.data || [];
      if (!s.length) return i;
      var n = s[0].size(this.resolveDataElementOptions(0)),
        a = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));
      return Math.max(i, n, a) / 2
    }
    draw() {
      this._cachedMeta.dataset.updateControlPoints(this.chart.chartArea), super.draw()
    }
  }
  Xs.id = "line", Xs.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  }, Xs.overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  class Gs extends Ti {
    constructor(t, e) {
      super(t, e), this.innerRadius = void 0, this.outerRadius = void 0
    }
    update(t) {
      var e = this._cachedMeta.data;
      this._updateRadius(), this.updateElements(e, 0, e.length, t)
    }
    _updateRadius() {
      const t = this.chart,
        e = t.chartArea,
        i = t.options,
        s = Math.min(e.right - e.left, e.bottom - e.top),
        n = Math.max(s / 2, 0),
        a = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();
      this.outerRadius = n - a * this.index, this.innerRadius = this.outerRadius - a
    }
    updateElements(s, n, t, a) {
      const o = "reset" === a,
        r = this.chart,
        l = this.getDataset(),
        c = r.options.animation,
        d = this._cachedMeta.rScale,
        h = d.xCenter,
        u = d.yCenter,
        p = d.getIndexAngle(0) - .5 * ft;
      let f, m = p;
      var g = 360 / this.countVisibleElements();
      for (f = 0; f < n; ++f) m += this._computeAngle(f, a, g);
      for (f = n; f < n + t; f++) {
        const n = s[f];
        let t = m,
          e = m + this._computeAngle(f, a, g),
          i = r.getDataVisibility(f) ? d.getDistanceFromCenterForValue(l.data[f]) : 0;
        m = e, o && (c.animateScale && (i = 0), c.animateRotate && (t = e = p));
        var v = {
          x: h,
          y: u,
          innerRadius: 0,
          outerRadius: i,
          startAngle: t,
          endAngle: e,
          options: this.resolveDataElementOptions(f, a)
        };
        this.updateElement(n, f, v, a)
      }
    }
    countVisibleElements() {
      const i = this.getDataset(),
        t = this._cachedMeta;
      let s = 0;
      return t.data.forEach((t, e) => {
        !isNaN(i.data[e]) && this.chart.getDataVisibility(e) && s++
      }), s
    }
    _computeAngle(t, e, i) {
      return this.chart.getDataVisibility(t) ? At(this.resolveDataElementOptions(t, e).angle || i) : 0
    }
  }
  Gs.id = "polarArea", Gs.defaults = {
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !0
    },
    animations: {
      numbers: {
        type: "number",
        properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
      }
    },
    indexAxis: "r",
    startAngle: 0
  }, Gs.overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(s) {
            const t = s.data;
            return t.labels.length && t.datasets.length ? t.labels.map((t, e) => {
              var i = s.getDatasetMeta(0).controller.getStyle(e);
              return {
                text: t,
                fillStyle: i.backgroundColor,
                strokeStyle: i.borderColor,
                lineWidth: i.borderWidth,
                hidden: !s.getDataVisibility(e),
                index: e
              }
            }) : []
          }
        },
        onClick(t, e, i) {
          i.chart.toggleDataVisibility(e.index), i.chart.update()
        }
      },
      tooltip: {
        callbacks: {
          title: () => "",
          label: t => t.chart.data.labels[t.dataIndex] + ": " + t.formattedValue
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: !1
        },
        beginAtZero: !0,
        grid: {
          circular: !0
        },
        pointLabels: {
          display: !1
        },
        startAngle: 0
      }
    }
  };
  class Ks extends Us {}
  Ks.id = "pie", Ks.defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
  class Qs extends Ti {
    getLabelAndValue(t) {
      const e = this._cachedMeta.vScale,
        i = this.getParsed(t);
      return {
        label: e.getLabels()[t],
        value: "" + e.getLabelForValue(i[e.axis])
      }
    }
    update(t) {
      const e = this._cachedMeta,
        i = e.dataset,
        s = e.data || [],
        n = e.iScale.getLabels();
      if (i.points = s, "resize" !== t) {
        const e = this.resolveDatasetElementOptions(t);
        this.options.showLine || (e.borderWidth = 0);
        var a = {
          _loop: !0,
          _fullLoop: n.length === s.length,
          options: e
        };
        this.updateElement(i, void 0, a, t)
      }
      this.updateElements(s, 0, s.length, t)
    }
    updateElements(e, i, s, n) {
      const a = this.getDataset(),
        o = this._cachedMeta.rScale,
        r = "reset" === n;
      for (let t = i; t < i + s; t++) {
        const i = e[t],
          s = this.resolveDataElementOptions(t, n),
          l = o.getPointPositionForValue(t, a.data[t]),
          c = r ? o.xCenter : l.x,
          d = r ? o.yCenter : l.y,
          h = {
            x: c,
            y: d,
            angle: l.angle,
            skip: isNaN(c) || isNaN(d),
            options: s
          };
        this.updateElement(i, t, h, n)
      }
    }
  }
  Qs.id = "radar", Qs.defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: !0,
    elements: {
      line: {
        fill: "start"
      }
    }
  }, Qs.overrides = {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  };
  class Js extends Xs {}
  Js.id = "scatter", Js.defaults = {
    showLine: !1,
    fill: !1
  }, Js.overrides = {
    interaction: {
      mode: "point"
    },
    plugins: {
      tooltip: {
        callbacks: {
          title: () => "",
          label: t => "(" + t.label + ", " + t.formattedValue + ")"
        }
      }
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  };
  var Zs = Object.freeze({
    __proto__: null,
    BarController: qs,
    BubbleController: Ys,
    DoughnutController: Us,
    LineController: Xs,
    PolarAreaController: Gs,
    PieController: Ks,
    RadarController: Qs,
    ScatterController: Js
  });

  function tn(t, e) {
    var {
      startAngle: i,
      endAngle: s,
      pixelMargin: n,
      x: a,
      y: o,
      outerRadius: r,
      innerRadius: l
    } = e, e = n / r;
    t.beginPath(), t.arc(a, o, r, i - e, s + e), n < l ? t.arc(a, o, l, s + (e = n / l), i - e, !0) : t.arc(a, o, n, s + _t, i - _t), t.closePath(), t.clip()
  }

  function en(t, e, i, s) {
    return {
      x: i + t * Math.cos(e),
      y: s + t * Math.sin(e)
    }
  }

  function sn(t, e) {
    var {
      x: i,
      y: s,
      startAngle: n,
      endAngle: a,
      pixelMargin: o
    } = e, r = Math.max(e.outerRadius - o, 0), l = e.innerRadius + o, {
      outerStart: c,
      outerEnd: d,
      innerStart: h,
      innerEnd: u
    } = function (t, e, i, s) {
      t = Me(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
      const n = (i - e) / 2,
        a = Math.min(n, s * e / 2),
        o = t => {
          var e = (i - Math.min(n, t)) * s / 2;
          return Ft(t, 0, Math.min(n, e))
        };
      return {
        outerStart: o(t.outerStart),
        outerEnd: o(t.outerEnd),
        innerStart: Ft(t.innerStart, 0, a),
        innerEnd: Ft(t.innerEnd, 0, a)
      }
    }(e, l, r, a - n), p = r - c, f = r - d, m = n + c / p, g = a - d / f, v = l + h, b = l + u, o = n + h / v, e = a - u / b;
    if (t.beginPath(), t.arc(i, s, r, m, g), 0 < d) {
      const _ = en(f, g, i, s);
      t.arc(_.x, _.y, d, g, a + _t)
    }
    g = en(b, a, i, s);
    if (t.lineTo(g.x, g.y), 0 < u) {
      const _ = en(b, e, i, s);
      t.arc(_.x, _.y, u, a + _t, e + Math.PI)
    }
    if (t.arc(i, s, l, a - u / l, n + h / l, !0), 0 < h) {
      const _ = en(v, o, i, s);
      t.arc(_.x, _.y, h, o + Math.PI, n - _t)
    }
    o = en(p, n, i, s);
    if (t.lineTo(o.x, o.y), 0 < c) {
      const _ = en(p, m, i, s);
      t.arc(_.x, _.y, c, n - _t, m)
    }
    t.closePath()
  }

  function nn(t, e) {
    var {
      options: i
    } = e, s = "inner" === i.borderAlign;
    i.borderWidth && (s ? (t.lineWidth = 2 * i.borderWidth, t.lineJoin = "round") : (t.lineWidth = i.borderWidth, t.lineJoin = "bevel"), e.fullCircles && function (t, e, i) {
      var {
        x: s,
        y: n,
        startAngle: a,
        endAngle: o,
        pixelMargin: r
      } = e, l = Math.max(e.outerRadius - r, 0), r = e.innerRadius + r;
      let c;
      for (i && (e.endAngle = e.startAngle + mt, tn(t, e), e.endAngle = o, e.endAngle === e.startAngle && (e.endAngle += mt, e.fullCircles--)), t.beginPath(), t.arc(s, n, r, a + mt, a, !0), c = 0; c < e.fullCircles; ++c) t.stroke();
      for (t.beginPath(), t.arc(s, n, l, a, a + mt), c = 0; c < e.fullCircles; ++c) t.stroke()
    }(t, e, s), s && tn(t, e), sn(t, e), t.stroke())
  }
  class an extends Di {
    constructor(t) {
      super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t)
    }
    inRange(t, e, i) {
      var {
        angle: s,
        distance: n
      } = Ot(this.getProps(["x", "y"], i), {
        x: t,
        y: e
      }), {
        startAngle: a,
        endAngle: o,
        innerRadius: t,
        outerRadius: e,
        circumference: i
      } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i);
      return (i >= mt || Ht(s, a, o)) && t <= n && n <= e
    }
    getCenterPoint(t) {
      var {
        x: e,
        y: i,
        startAngle: s,
        endAngle: n,
        innerRadius: a,
        outerRadius: t
      } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"], t), n = (s + n) / 2, t = (a + t) / 2;
      return {
        x: e + Math.cos(n) * t,
        y: i + Math.sin(n) * t
      }
    }
    tooltipPosition(t) {
      return this.getCenterPoint(t)
    }
    draw(t) {
      const e = this,
        i = e.options,
        s = i.offset || 0;
      if (e.pixelMargin = "inner" === i.borderAlign ? .33 : 0, e.fullCircles = Math.floor(e.circumference / mt), !(0 === e.circumference || e.innerRadius < 0 || e.outerRadius < 0)) {
        if (t.save(), s && e.circumference < mt) {
          const i = (e.startAngle + e.endAngle) / 2;
          t.translate(Math.cos(i) * s, Math.sin(i) * s)
        }
        t.fillStyle = i.backgroundColor, t.strokeStyle = i.borderColor,
          function (e, i) {
            if (i.fullCircles) {
              i.endAngle = i.startAngle + mt, sn(e, i);
              for (let t = 0; t < i.fullCircles; ++t) e.fill()
            }
            isNaN(i.circumference) || (i.endAngle = i.startAngle + i.circumference % mt), sn(e, i), e.fill()
          }(t, e), nn(t, e), t.restore()
      }
    }
  }

  function on(t, e, i = e) {
    t.lineCap = q(i.borderCapStyle, e.borderCapStyle), t.setLineDash(q(i.borderDash, e.borderDash)), t.lineDashOffset = q(i.borderDashOffset, e.borderDashOffset), t.lineJoin = q(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = q(i.borderWidth, e.borderWidth), t.strokeStyle = q(i.borderColor, e.borderColor)
  }

  function rn(t, e, i) {
    t.lineTo(i.x, i.y)
  }

  function ln(t, e, i = {}) {
    var s = t.length,
      {
        start: n = 0,
        end: a = s - 1
      } = i,
      {
        start: o,
        end: r
      } = e,
      t = Math.max(n, o),
      i = Math.min(a, r);
    return {
      count: s,
      start: t,
      loop: e.loop,
      ilen: i < t && !(n < o && a < o || r < n && r < a) ? s + i - t : i - t
    }
  }

  function cn(t, e, i, s) {
    const {
      points: n,
      options: a
    } = e, {
      count: o,
      start: r,
      loop: l,
      ilen: c
    } = ln(n, i, s), d = a.stepped ? Gt : a.tension ? Kt : rn;
    let h, u, p, {
      move: f = !0,
      reverse: m
    } = s || {};
    for (h = 0; h <= c; ++h) u = n[(r + (m ? c - h : h)) % o], u.skip || (f ? (t.moveTo(u.x, u.y), f = !1) : d(t, p, u, m, a.stepped), p = u);
    return l && (u = n[(r + (m ? c : 0)) % o], d(t, p, u, m, a.stepped)), !!l
  }

  function dn(t, e, i, s) {
    const n = e.points,
      {
        count: a,
        start: o,
        ilen: r
      } = ln(n, i, s),
      {
        move: l = !0,
        reverse: c
      } = s || {};
    let d, h, u, p, f, m, g = 0,
      v = 0;
    var b = t => (o + (c ? r - t : t)) % a,
      _ = () => {
        p !== f && (t.lineTo(g, f), t.lineTo(g, p), t.lineTo(g, m))
      };
    for (l && (h = n[b(0)], t.moveTo(h.x, h.y)), d = 0; d <= r; ++d)
      if (h = n[b(d)], !h.skip) {
        const e = h.x,
          i = h.y,
          s = 0 | e;
        s === u ? (i < p ? p = i : i > f && (f = i), g = (v * g + e) / ++v) : (_(), t.lineTo(e, i), u = s, v = 0, p = f = i), m = i
      } _()
  }

  function hn(t) {
    var e = t.options,
      i = e.borderDash && e.borderDash.length;
    return t._decimated || t._loop || e.tension || e.stepped || i ? cn : dn
  }
  an.id = "arc", an.defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    angle: void 0
  }, an.defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  const un = "function" == typeof Path2D;
  class pn extends Di {
    constructor(t) {
      super(), this.animated = !0, this.options = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, t && Object.assign(this, t)
    }
    updateControlPoints(t) {
      var e, i = this.options;
      !i.tension || i.stepped || this._pointsUpdated || (e = i.spanGaps ? this._loop : this._fullLoop, es(this._points, i, t, e), this._pointsUpdated = !0)
    }
    set points(t) {
      this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1
    }
    get points() {
      return this._points
    }
    get segments() {
      return this._segments || (this._segments = us(this, this.options.segment))
    }
    first() {
      var t = this.segments,
        e = this.points;
      return t.length && e[t[0].start]
    }
    last() {
      var t = this.segments,
        e = this.points,
        i = t.length;
      return i && e[t[i - 1].end]
    }
    interpolate(i, s) {
      const n = this,
        a = n.options,
        o = i[s],
        r = n.points,
        l = hs(n, {
          property: s,
          start: o,
          end: o
        });
      if (l.length) {
        const c = [],
          d = a.stepped ? ss : a.tension ? ns : is;
        let e, t;
        for (e = 0, t = l.length; e < t; ++e) {
          const {
            start: n,
            end: t
          } = l[e], h = r[n], u = r[t];
          if (h !== u) {
            const p = d(h, u, Math.abs((o - h[s]) / (u[s] - h[s])), a.stepped);
            p[s] = i[s], c.push(p)
          } else c.push(h)
        }
        return 1 === c.length ? c[0] : c
      }
    }
    pathSegment(t, e, i) {
      return hn(this)(t, this, e, i)
    }
    path(t, e, i) {
      const s = this.segments,
        n = hn(this);
      let a = this._loop;
      e = e || 0, i = i || this.points.length - e;
      for (const o of s) a &= n(t, this, o, {
        start: e,
        end: e + i - 1
      });
      return !!a
    }
    draw(t, e, i, s) {
      var n, a = this.options || {};
      (this.points || []).length && a.borderWidth && (t.save(), n = t, a = this, i = i, s = s, (un && 1 === a.segments.length ? function (t, e, i, s) {
        let n = e._path;
        n || (n = e._path = new Path2D, e.path(n, i, s) && n.closePath()), on(t, e.options), t.stroke(n)
      } : function (t, e, i, s) {
        const {
          segments: n,
          options: a
        } = e, o = hn(e);
        for (const r of n) on(t, a, r.style), t.beginPath(), o(t, e, r, {
          start: i,
          end: i + s - 1
        }) && t.closePath(), t.stroke()
      })(n, a, i, s), t.restore(), this.animated && (this._pointsUpdated = !1, this._path = void 0))
    }
  }

  function fn(t, e, i, s) {
    var n = t.options,
      {
        [i]: i
      } = t.getProps([i], s);
    return Math.abs(e - i) < n.radius + n.hitRadius
  }
  pn.id = "line", pn.defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  }, pn.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  }, pn.descriptors = {
    _scriptable: !0,
    _indexable: t => "borderDash" !== t && "fill" !== t
  };
  class mn extends Di {
    constructor(t) {
      super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t)
    }
    inRange(t, e, i) {
      var s = this.options,
        {
          x: n,
          y: i
        } = this.getProps(["x", "y"], i);
      return Math.pow(t - n, 2) + Math.pow(e - i, 2) < Math.pow(s.hitRadius + s.radius, 2)
    }
    inXRange(t, e) {
      return fn(this, t, "x", e)
    }
    inYRange(t, e) {
      return fn(this, t, "y", e)
    }
    getCenterPoint(t) {
      var {
        x: e,
        y: t
      } = this.getProps(["x", "y"], t);
      return {
        x: e,
        y: t
      }
    }
    size(t) {
      var e = (t = t || this.options || {}).radius || 0;
      return 2 * ((e = Math.max(e, e && t.hoverRadius || 0)) + (e && t.borderWidth || 0))
    }
    draw(t) {
      var e = this.options;
      this.skip || e.radius < .1 || (t.strokeStyle = e.borderColor, t.lineWidth = e.borderWidth, t.fillStyle = e.backgroundColor, qt(t, e, this.x, this.y))
    }
    getRange() {
      var t = this.options || {};
      return t.radius + t.hitRadius
    }
  }

  function gn(t, e) {
    var {
      x: i,
      y: s,
      base: n,
      width: a,
      height: e
    } = t.getProps(["x", "y", "base", "width", "height"], e);
    let o, r, l, c, d;
    return c = t.horizontal ? (d = e / 2, o = Math.min(i, n), r = Math.max(i, n), l = s - d, s + d) : (d = a / 2, o = i - d, r = i + d, l = Math.min(s, n), Math.max(s, n)), {
      left: o,
      top: l,
      right: r,
      bottom: c
    }
  }

  function vn(t) {
    let e = t.options.borderSkipped;
    const i = {};
    return e && (e = t.horizontal ? bn(e, "left", "right", t.base > t.x) : bn(e, "bottom", "top", t.base < t.y), i[e] = !0), i
  }

  function bn(t, e, i, s) {
    return t = s ? _n(t = t === e ? i : t === i ? e : t, i, e) : _n(t, e, i)
  }

  function _n(t, e, i) {
    return "start" === t ? e : "end" === t ? i : t
  }

  function yn(t, e, i, s) {
    return t ? 0 : Math.max(Math.min(e, s), i)
  }

  function wn(t, e, i, s) {
    var n = null === e,
      a = null === i,
      s = t && !(n && a) && gn(t, s);
    return s && (n || e >= s.left && e <= s.right) && (a || i >= s.top && i <= s.bottom)
  }

  function xn(t, e) {
    t.rect(e.x, e.y, e.w, e.h)
  }
  mn.id = "point", mn.defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  }, mn.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  class Cn extends Di {
    constructor(t) {
      super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, t && Object.assign(this, t)
    }
    draw(t) {
      const e = this.options,
        {
          inner: i,
          outer: s
        } = (c = gn(a = this), d = c.right - c.left, h = c.bottom - c.top, u = d / 2, r = h / 2, l = (o = a).options.borderWidth, o = vn(o), l = Ee(l), u = {
          t: yn(o.top, l.top, 0, r),
          r: yn(o.right, l.right, 0, u),
          b: yn(o.bottom, l.bottom, 0, r),
          l: yn(o.left, l.left, 0, u)
        }, a = function (t, e, i) {
          var {
            enableBorderRadius: s
          } = t.getProps(["enableBorderRadius"]), n = t.options.borderRadius, a = Ae(n), i = Math.min(e, i), t = vn(t), n = s || j(n);
          return {
            topLeft: yn(!n || t.top || t.left, a.topLeft, 0, i),
            topRight: yn(!n || t.top || t.right, a.topRight, 0, i),
            bottomLeft: yn(!n || t.bottom || t.left, a.bottomLeft, 0, i),
            bottomRight: yn(!n || t.bottom || t.right, a.bottomRight, 0, i)
          }
        }(a, d / 2, h / 2), {
          outer: {
            x: c.left,
            y: c.top,
            w: d,
            h: h,
            radius: a
          },
          inner: {
            x: c.left + u.l,
            y: c.top + u.t,
            w: d - u.l - u.r,
            h: h - u.t - u.b,
            radius: {
              topLeft: Math.max(0, a.topLeft - Math.max(u.t, u.l)),
              topRight: Math.max(0, a.topRight - Math.max(u.t, u.r)),
              bottomLeft: Math.max(0, a.bottomLeft - Math.max(u.b, u.l)),
              bottomRight: Math.max(0, a.bottomRight - Math.max(u.b, u.r))
            }
          }
        }),
        n = (u = s.radius).topLeft || u.topRight || u.bottomLeft || u.bottomRight ? Jt : xn;
      var a, o, r, l, c, d, h, u;
      t.save(), s.w === i.w && s.h === i.h || (t.beginPath(), n(t, s), t.clip(), n(t, i), t.fillStyle = e.borderColor, t.fill("evenodd")), t.beginPath(), n(t, i), t.fillStyle = e.backgroundColor, t.fill(), t.restore()
    }
    inRange(t, e, i) {
      return wn(this, t, e, i)
    }
    inXRange(t, e) {
      return wn(this, t, null, e)
    }
    inYRange(t, e) {
      return wn(this, null, t, e)
    }
    getCenterPoint(t) {
      var {
        x: e,
        y: i,
        base: s,
        horizontal: t
      } = this.getProps(["x", "y", "base", "horizontal"], t);
      return {
        x: t ? (e + s) / 2 : e,
        y: t ? i : (i + s) / 2
      }
    }
    getRange(t) {
      return "x" === t ? this.width / 2 : this.height / 2
    }
  }
  Cn.id = "bar", Cn.defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    enableBorderRadius: !0,
    pointStyle: void 0
  }, Cn.defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  var kn = Object.freeze({
    __proto__: null,
    ArcElement: an,
    LineElement: pn,
    PointElement: mn,
    BarElement: Cn
  });

  function Tn(t) {
    var e;
    t._decimated && (e = t._data, delete t._decimated, delete t._data, Object.defineProperty(t, "data", {
      value: e
    }))
  }

  function Dn(t) {
    t.data.datasets.forEach(t => {
      Tn(t)
    })
  }
  var Sn = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: !1
    },
    beforeElementsUpdate: (i, t, x) => {
      if (x.enabled) {
        const o = i.width;
        i.data.datasets.forEach((s, t) => {
          var {
            _data: n,
            indexAxis: e
          } = s, c = i.getDatasetMeta(t), a = n || s.data;
          if ("y" !== Oe([e, i.options.indexAxis]) && "line" === c.type) {
            e = i.scales[c.xAxisID];
            if (("linear" === e.type || "time" === e.type) && !i.options.parsing) {
              let t, {
                start: e,
                count: i
              } = function (t) {
                var e = t.length;
                let i, s = 0;
                const {
                  iScale: n
                } = c, {
                  min: a,
                  max: o,
                  minDefined: r,
                  maxDefined: l
                } = n.getUserBounds();
                return r && (s = Ft(te(t, n.axis, a).lo, 0, e - 1)), i = l ? Ft(te(t, n.axis, o).hi + 1, s, e) - s : e - s, {
                  start: s,
                  count: i
                }
              }(a);
              if (i <= 4 * o) Tn(s);
              else {
                switch (R(n) && (s._data = a, delete s.data, Object.defineProperty(s, "data", {
                  configurable: !0,
                  enumerable: !0,
                  get: function () {
                    return this._decimated
                  },
                  set: function (t) {
                    this._data = t
                  }
                })), x.algorithm) {
                  case "lttb":
                    t = function (s, n, a, t) {
                      var e = x.samples || t;
                      if (a <= e) return s.slice(n, n + a);
                      const o = [],
                        r = (a - 2) / (e - 2);
                      let l = 0;
                      const c = n + a - 1;
                      let d, h, u, p, f, m = n;
                      for (o[l++] = s[m], d = 0; d < e - 2; d++) {
                        let t, e = 0,
                          i = 0;
                        const c = Math.floor((d + 1) * r) + 1 + n,
                          y = Math.min(Math.floor((d + 2) * r) + 1, a) + n,
                          w = y - c;
                        for (t = c; t < y; t++) e += s[t].x, i += s[t].y;
                        e /= w, i /= w;
                        var g = Math.floor(d * r) + 1 + n,
                          v = Math.floor((d + 1) * r) + 1 + n,
                          {
                            x: b,
                            y: _
                          } = s[m];
                        for (u = -1, t = g; t < v; t++)(p = .5 * Math.abs((b - e) * (s[t].y - _) - (b - s[t].x) * (i - _))) > u && (u = p, h = s[t], f = t);
                        o[l++] = h, m = f
                      }
                      return o[l++] = s[c], o
                    }(a, e, i, o);
                    break;
                  case "min-max":
                    t = function (t, e, i, s) {
                      let n, a, o, r, l, c, d, h, u, p, f = 0,
                        m = 0;
                      const g = [],
                        v = e + i - 1,
                        b = t[e].x,
                        _ = t[v].x - b;
                      for (n = e; n < e + i; ++n) {
                        o = ((a = t[n]).x - b) / _ * s, r = a.y;
                        const e = 0 | o;
                        if (e === l) r < u ? (u = r, c = n) : r > p && (p = r, d = n), f = (m * f + a.x) / ++m;
                        else {
                          const i = n - 1;
                          if (!R(c) && !R(d)) {
                            const e = Math.min(c, d),
                              s = Math.max(c, d);
                            e !== h && e !== i && g.push({
                              ...t[e],
                              x: f
                            }), s !== h && s !== i && g.push({
                              ...t[s],
                              x: f
                            })
                          }
                          0 < n && i !== h && g.push(t[i]), g.push(a), l = e, m = 0, u = p = r, c = d = h = n
                        }
                      }
                      return g
                    }(a, e, i, o);
                    break;
                  default:
                    throw new Error(`Unsupported decimation algorithm '${x.algorithm}'`)
                }
                s._decimated = t
              }
            }
          }
        })
      } else Dn(i)
    },
    destroy(t) {
      Dn(t)
    }
  };
  class Mn {
    constructor(t) {
      this.x = t.x, this.y = t.y, this.radius = t.radius
    }
    pathSegment(t, e, i) {
      var {
        x: s,
        y: n,
        radius: a
      } = this;
      return e = e || {
        start: 0,
        end: mt
      }, t.arc(s, n, a, e.end, e.start, !0), !i.bounds
    }
    interpolate(t) {
      var {
        x: e,
        y: i,
        radius: s
      } = this, t = t.angle;
      return {
        x: e + Math.cos(t) * s,
        y: i + Math.sin(t) * s,
        angle: t
      }
    }
  }

  function En(t) {
    const {
      chart: e,
      scale: i,
      index: s,
      line: n
    } = t, a = [], o = n.segments, r = n.points, l = function (t, e) {
      const i = [],
        s = t.getSortedVisibleDatasetMetas();
      for (let t = 0; t < s.length; t++) {
        var n = s[t];
        if (n.index === e) break;
        An(n) && i.unshift(n.dataset)
      }
      return i
    }(e, s);
    l.push(Pn({
      x: null,
      y: i.bottom
    }, n));
    for (let t = 0; t < o.length; t++) {
      const e = o[t];
      for (let t = e.start; t <= e.end; t++) ! function (e, i, s) {
        const n = [];
        for (let t = 0; t < s.length; t++) {
          var {
            first: a,
            last: o,
            point: r
          } = function (t, e, i) {
            const s = t.interpolate(e, i);
            if (!s) return {};
            var n = s[i],
              a = t.segments,
              o = t.points;
            let r = !1,
              l = !1;
            for (let t = 0; t < a.length; t++) {
              const e = a[t],
                s = o[e.start][i],
                c = o[e.end][i];
              if (n >= s && n <= c) {
                r = n === s, l = n === c;
                break
              }
            }
            return {
              first: r,
              last: l,
              point: s
            }
          }(s[t], i, "x");
          if (!(!r || a && o))
            if (a) n.unshift(r);
            else if (e.push(r), !o) break
        }
        e.push(...n)
      }(a, r[t], l)
    }
    return new pn({
      points: a,
      options: {}
    })
  }
  const An = t => "line" === t.type && !t.hidden;

  function Pn(e, t) {
    let i = [],
      s = !1;
    return i = B(e) ? (s = !0, e) : function (t) {
      const {
        x: i = null,
        y: s = null
      } = e || {}, n = t.points, a = [];
      return t.segments.forEach(t => {
        var e = n[t.start],
          t = n[t.end];
        null !== s ? (a.push({
          x: e.x,
          y: s
        }), a.push({
          x: t.x,
          y: s
        })) : null !== i && (a.push({
          x: i,
          y: e.y
        }), a.push({
          x: i,
          y: t.y
        }))
      }), a
    }(t), i.length ? new pn({
      points: i,
      options: {
        tension: 0
      },
      _loop: s,
      _fullLoop: s
    }) : null
  }

  function In(t, e, i) {
    t.beginPath(), e.path(t), t.lineTo(e.last().x, i), t.lineTo(e.first().x, i), t.closePath(), t.clip()
  }

  function On(i, s, n, t) {
    if (!t) {
      let t = s[i],
        e = n[i];
      return "angle" === i && (t = Nt(t), e = Nt(e)), {
        property: i,
        start: t,
        end: e
      }
    }
  }

  function $n(t, e, i, s) {
    return t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0
  }

  function Ln(t, e, i, s) {
    s = e.interpolate(i, s);
    s && t.lineTo(s.x, s.y)
  }

  function Nn(t, e) {
    const {
      line: i,
      target: s,
      property: n,
      color: a,
      scale: o
    } = e, r = function (t, e, i) {
      const s = t.segments,
        n = t.points,
        a = e.points,
        o = [];
      for (const t of s) {
        const s = On(i, n[t.start], n[t.end], t.loop);
        if (e.segments) {
          var r = hs(e, s);
          for (const e of r) {
            var l = On(i, a[e.start], a[e.end], e.loop),
              c = ds(t, n, l);
            for (const t of c) o.push({
              source: t,
              target: e,
              start: {
                [i]: $n(s, l, "start", Math.max)
              },
              end: {
                [i]: $n(s, l, "end", Math.min)
              }
            })
          }
        } else o.push({
          source: t,
          target: s,
          start: n[t.start],
          end: n[t.end]
        })
      }
      return o
    }(i, s, n);
    for (const {
        source: e,
        target: d,
        start: h,
        end: u
      } of r) {
      const {
        style: {
          backgroundColor: r = a
        } = {}
      } = e;
      t.save(), t.fillStyle = r,
        function (t, e, i) {
          var {
            top: s,
            bottom: n
          } = e.chart.chartArea, {
            property: a,
            start: e,
            end: i
          } = i || {};
          "x" === a && (t.beginPath(), t.rect(e, s, i - e, n - s), t.clip())
        }(t, o, On(n, h, u)), t.beginPath();
      var l = !!i.pathSegment(t, e);
      l ? t.closePath() : Ln(t, s, u, n);
      var c = !!s.pathSegment(t, d, {
          move: l,
          reverse: !0
        }),
        c = l && c;
      c || Ln(t, s, h, n), t.closePath(), t.fill(c ? "evenodd" : "nonzero"), t.restore()
    }
  }

  function Hn(t, e, i) {
    var s = function (t) {
        var e, i, {
          chart: s,
          fill: n,
          line: a
        } = t;
        if (W(n)) return i = n, (s = (e = s).getDatasetMeta(i)) && e.isDatasetVisible(i) ? s.dataset : null;
        if ("stack" === n) return En(t);
        var d, t = (((d = t).scale || {}).getPointPositionForValue ? function () {
          const {
            scale: t,
            fill: e
          } = d, i = t.options, s = t.getLabels().length, n = [], a = i.reverse ? t.max : t.min, o = i.reverse ? t.min : t.max;
          let r, l, c;
          if (c = "start" === e ? a : "end" === e ? o : j(e) ? e.value : t.getBaseValue(), i.grid.circular) return l = t.getPointPositionForValue(0, a), new Mn({
            x: l.x,
            y: l.y,
            radius: t.getDistanceFromCenterForValue(c)
          });
          for (r = 0; r < s; ++r) n.push(t.getPointPositionForValue(r, c));
          return n
        } : function () {
          const {
            scale: t = {},
            fill: e
          } = d;
          let i, s = null;
          return "start" === e ? s = t.bottom : "end" === e ? s = t.top : j(e) ? s = t.getPixelForValue(e.value) : t.getBasePixel && (s = t.getBasePixel()), W(s) ? {
            x: (i = t.isHorizontal()) ? s : null,
            y: i ? null : s
          } : null
        })();
        return t instanceof Mn ? t : Pn(t, a)
      }(e),
      {
        line: n,
        scale: a,
        axis: o
      } = e,
      r = n.options,
      e = r.fill,
      r = r.backgroundColor,
      {
        above: e = r,
        below: r = r
      } = e || {};
    s && n.points.length && (Ut(t, i), function (t, e) {
      var {
        line: i,
        target: s,
        above: n,
        below: a,
        area: o,
        scale: r
      } = e, e = i._loop ? "angle" : e.axis;
      t.save(), "x" === e && a !== n && (In(t, s, o.top), Nn(t, {
        line: i,
        target: s,
        color: n,
        scale: r,
        property: e
      }), t.restore(), t.save(), In(t, s, o.bottom)), Nn(t, {
        line: i,
        target: s,
        color: a,
        scale: r,
        property: e
      }), t.restore()
    }(t, {
      line: n,
      target: s,
      above: e,
      below: r,
      area: i,
      scale: a,
      axis: o
    }), Xt(t))
  }
  var Fn = {
    id: "filler",
    afterDatasetsUpdate(t, e, i) {
      const s = (t.data.datasets || []).length,
        n = [];
      let a, o, r, l;
      for (o = 0; o < s; ++o) a = t.getDatasetMeta(o), r = a.dataset, l = null, r && r.options && r instanceof pn && (l = {
        visible: t.isDatasetVisible(o),
        index: o,
        fill: function (s, t, e) {
          var i = function () {
            var t = s.options,
              e = t.fill;
            let i = q(e && e.target, e);
            return void 0 === i && (i = !!t.backgroundColor), !1 !== i && null !== i && (!0 === i ? "origin" : i)
          }();
          if (j(i)) return !isNaN(i.value) && i;
          let n = parseFloat(i);
          return W(n) && Math.floor(n) === n ? ("-" !== i[0] && "+" !== i[0] || (n = t + n), !(n === t || n < 0 || n >= e) && n) : 0 <= ["origin", "start", "end", "stack"].indexOf(i) && i
        }(r, o, s),
        chart: t,
        axis: a.controller.options.indexAxis,
        scale: a.vScale,
        line: r
      }), a.$filler = l, n.push(l);
      for (o = 0; o < s; ++o) l = n[o], l && !1 !== l.fill && (l.fill = function (t, e, i) {
        let s = t[e].fill;
        const n = [e];
        var a;
        if (!i) return s;
        for (; !1 !== s && -1 === n.indexOf(s);) {
          if (!W(s)) return s;
          if (!(a = t[s])) return !1;
          if (a.visible) return s;
          n.push(s), s = a.fill
        }
        return !1
      }(n, o, i.propagate))
    },
    beforeDraw(e, t, i) {
      var s = "beforeDraw" === i.drawTime,
        n = e.getSortedVisibleDatasetMetas(),
        a = e.chartArea;
      for (let t = n.length - 1; 0 <= t; --t) {
        const i = n[t].$filler;
        i && (i.line.updateControlPoints(a), s && Hn(e.ctx, i, a))
      }
    },
    beforeDatasetsDraw(e, t, i) {
      if ("beforeDatasetsDraw" === i.drawTime) {
        var s = e.getSortedVisibleDatasetMetas();
        for (let t = s.length - 1; 0 <= t; --t) {
          const i = s[t].$filler;
          i && Hn(e.ctx, i, e.chartArea)
        }
      }
    },
    beforeDatasetDraw(t, e, i) {
      e = e.meta.$filler;
      e && !1 !== e.fill && "beforeDatasetDraw" === i.drawTime && Hn(t.ctx, e, t.chartArea)
    },
    defaults: {
      propagate: !0,
      drawTime: "beforeDatasetDraw"
    }
  };
  const zn = (t, e) => {
    let {
      boxHeight: i = e,
      boxWidth: s = e
    } = t;
    return t.usePointStyle && (i = Math.min(i, e), s = Math.min(s, e)), {
      boxWidth: s,
      boxHeight: i,
      itemHeight: Math.max(e, i)
    }
  };
  class Rn extends Di {
    constructor(t) {
      super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
    }
    update(t, e, i) {
      this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit()
    }
    setDimensions() {
      var t = this;
      t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height)
    }
    buildLabels() {
      const i = this,
        s = i.options.labels || {};
      let t = X(s.generateLabels, [i.chart], i) || [];
      s.filter && (t = t.filter(t => s.filter(t, i.chart.data))), s.sort && (t = t.sort((t, e) => s.sort(t, e, i.chart.data))), i.options.reverse && t.reverse(), i.legendItems = t
    }
    fit() {
      const i = this,
        {
          options: s,
          ctx: n
        } = i;
      if (s.display) {
        var a = s.labels,
          o = Ie(a.font),
          r = o.size,
          l = i._computeTitleHeight(),
          {
            boxWidth: c,
            itemHeight: a
          } = zn(a, r);
        let t, e;
        n.font = o.string, i.isHorizontal() ? (t = i.maxWidth, e = i._fitRows(l, r, c, a) + 10) : (e = i.maxHeight, t = i._fitCols(l, r, c, a) + 10), i.width = Math.min(t, s.maxWidth || i.maxWidth), i.height = Math.min(e, s.maxHeight || i.maxHeight)
      } else i.width = i.height = 0
    }
    _fitRows(t, i, s, n) {
      const {
        ctx: a,
        maxWidth: o,
        options: {
          labels: {
            padding: r
          }
        }
      } = this, l = this.legendHitBoxes = [], c = this.lineWidths = [0], d = n + r;
      let h = t;
      a.textAlign = "left", a.textBaseline = "middle";
      let u = -1,
        p = -d;
      return this.legendItems.forEach((t, e) => {
        t = s + i / 2 + a.measureText(t.text).width;
        (0 === e || c[c.length - 1] + t + 2 * r > o) && (h += d, c[c.length - (0 < e ? 0 : 1)] = 0, p += d, u++), l[e] = {
          left: 0,
          top: p,
          row: u,
          width: t,
          height: n
        }, c[c.length - 1] += t + r
      }), h
    }
    _fitCols(t, i, s, n) {
      const {
        ctx: a,
        maxHeight: e,
        options: {
          labels: {
            padding: o
          }
        }
      } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], c = e - t;
      let d = o,
        h = 0,
        u = 0,
        p = 0,
        f = 0,
        m = 0;
      return this.legendItems.forEach((t, e) => {
        t = s + i / 2 + a.measureText(t.text).width;
        0 < e && u + i + 2 * o > c && (d += h + o, l.push({
          width: h,
          height: u
        }), p += h + o, m++, f = 0, h = u = 0), h = Math.max(h, t), u += i + o, r[e] = {
          left: p,
          top: f,
          col: m,
          width: t,
          height: n
        }, f += n + o
      }), d += h, l.push({
        width: h,
        height: u
      }), d
    }
    adjustHitBoxes() {
      var i = this;
      if (i.options.display) {
        var s = i._computeTitleHeight(),
          {
            legendHitBoxes: n,
            options: {
              align: a,
              labels: {
                padding: o
              }
            }
          } = i;
        if (this.isHorizontal()) {
          let t = 0,
            e = P(a, i.left + o, i.right - i.lineWidths[t]);
          for (const r of n) t !== r.row && (t = r.row, e = P(a, i.left + o, i.right - i.lineWidths[t])), r.top += i.top + s + o, r.left = e, e += r.width + o
        } else {
          let t = 0,
            e = P(a, i.top + s + o, i.bottom - i.columnSizes[t].height);
          for (const l of n) l.col !== t && (t = l.col, e = P(a, i.top + s + o, i.bottom - i.columnSizes[t].height)), l.top = e, l.left += i.left + o, e += l.height + o
        }
      }
    }
    isHorizontal() {
      return "top" === this.options.position || "bottom" === this.options.position
    }
    draw() {
      var t;
      this.options.display && (Ut(t = this.ctx, this), this._draw(), Xt(t))
    }
    _draw() {
      const h = this,
        {
          options: t,
          columnSizes: u,
          lineWidths: p,
          ctx: f
        } = h,
        {
          align: m,
          labels: g
        } = t,
        v = pt.color,
        b = as(t.rtl, h.left, h.width),
        _ = Ie(g.font),
        {
          color: y,
          padding: w
        } = g,
        x = _.size,
        C = x / 2;
      let k;
      h.drawTitle(), f.textAlign = b.textAlign("left"), f.textBaseline = "middle", f.lineWidth = .5, f.font = _.string;
      const {
        boxWidth: T,
        boxHeight: D,
        itemHeight: S
      } = zn(g, x), M = h.isHorizontal(), E = this._computeTitleHeight();
      k = M ? {
        x: P(m, h.left + w, h.right - p[0]),
        y: h.top + w + E,
        line: 0
      } : {
        x: h.left + w,
        y: P(m, h.top + E + w, h.bottom - u[0].height),
        line: 0
      }, os(h.ctx, t.textDirection);
      const A = S + w;
      h.legendItems.forEach((t, e) => {
        f.strokeStyle = t.fontColor || y, f.fillStyle = t.fontColor || y;
        var i, s, n, a, o = f.measureText(t.text).width,
          r = b.textAlign(t.textAlign || (t.textAlign = g.textAlign)),
          l = T + x / 2 + o;
        let c = k.x,
          d = k.y;
        b.setWidth(h.width), M ? 0 < e && c + l + w > h.right && (d = k.y += A, k.line++, c = k.x = P(m, h.left + w, h.right - p[k.line])) : 0 < e && d + A > h.bottom && (c = k.x = c + u[k.line].width + w, k.line++, d = k.y = P(m, h.top + E + w, h.bottom - u[k.line].height)), i = b.x(c), s = d, n = t, isNaN(T) || T <= 0 || isNaN(D) || D < 0 || (f.save(), a = q(n.lineWidth, 1), f.fillStyle = q(n.fillStyle, v), f.lineCap = q(n.lineCap, "butt"), f.lineDashOffset = q(n.lineDashOffset, 0), f.lineJoin = q(n.lineJoin, "miter"), f.lineWidth = a, f.strokeStyle = q(n.strokeStyle, v), f.setLineDash(q(n.lineDash, [])), g.usePointStyle ? (o = {
          radius: T * Math.SQRT2 / 2,
          pointStyle: n.pointStyle,
          rotation: n.rotation,
          borderWidth: a
        }, e = b.xPlus(i, T / 2), qt(f, o, e, s + C)) : (s = s + Math.max((x - D) / 2, 0), i = b.leftForLtr(i, T), n = Ae(n.borderRadius), f.beginPath(), Object.values(n).some(t => 0 !== t) ? Jt(f, {
          x: i,
          y: s,
          w: T,
          h: D,
          radius: n
        }) : f.rect(i, s, T, D), f.fill(), 0 !== a && f.stroke()), f.restore()), c = I(r, c + T + C, h.right), a = b.x(c), r = d, t = t, Qt(f, t.text, a, r + S / 2, _, {
          strikethrough: t.hidden,
          textAlign: t.textAlign
        }), M ? k.x += l + w : k.y += A
      }), rs(h.ctx, t.textDirection)
    }
    drawTitle() {
      const s = this,
        n = s.options,
        a = n.title,
        o = Ie(a.font),
        r = Pe(a.padding);
      if (a.display) {
        const c = as(n.rtl, s.left, s.width),
          d = s.ctx,
          h = a.position,
          u = o.size / 2,
          p = r.top + u;
        let t, e = s.left,
          i = s.width;
        if (this.isHorizontal()) i = Math.max(...s.lineWidths), t = s.top + p, e = P(n.align, e, s.right - i);
        else {
          const a = s.columnSizes.reduce((t, e) => Math.max(t, e.height), 0);
          t = p + P(n.align, s.top, s.bottom - a - n.labels.padding - s._computeTitleHeight())
        }
        var l = P(h, e, e + i);
        d.textAlign = c.textAlign(f(h)), d.textBaseline = "middle", d.strokeStyle = a.color, d.fillStyle = a.color, d.font = o.string, Qt(d, a.text, l, t, o)
      }
    }
    _computeTitleHeight() {
      var t = this.options.title,
        e = Ie(t.font),
        i = Pe(t.padding);
      return t.display ? e.lineHeight + i.height : 0
    }
    _getLegendItemAt(t, e) {
      let i, s, n;
      if (t >= this.left && t <= this.right && e >= this.top && e <= this.bottom)
        for (n = this.legendHitBoxes, i = 0; i < n.length; ++i)
          if (t >= (s = n[i]).left && t <= s.left + s.width && e >= s.top && e <= s.top + s.height) return this.legendItems[i];
      return null
    }
    handleEvent(t) {
      var e, i, s, n = this,
        a = n.options;
      ("mousemove" === (s = t.type) && (a.onHover || a.onLeave) || a.onClick && ("click" === s || "mouseup" === s)) && (e = n._getLegendItemAt(t.x, t.y), "mousemove" === t.type ? (s = null !== (i = n._hoveredItem) && null !== e && i.datasetIndex === e.datasetIndex && i.index === e.index, i && !s && X(a.onLeave, [t, i, n], n), (n._hoveredItem = e) && !s && X(a.onHover, [t, e, n], n)) : e && X(a.onClick, [t, e, n], n))
    }
  }
  var Bn = {
    id: "legend",
    _element: Rn,
    start(t, e, i) {
      var s = t.legend = new Rn({
        ctx: t.ctx,
        options: i,
        chart: t
      });
      Ve.configure(t, s, i), Ve.addBox(t, s)
    },
    stop(t) {
      Ve.removeBox(t, t.legend), delete t.legend
    },
    beforeUpdate(t, e, i) {
      const s = t.legend;
      Ve.configure(t, s, i), s.options = i
    },
    afterUpdate(t) {
      const e = t.legend;
      e.buildLabels(), e.adjustHitBoxes()
    },
    afterEvent(t, e) {
      e.replay || t.legend.handleEvent(e.event)
    },
    defaults: {
      display: !0,
      position: "top",
      align: "center",
      fullSize: !0,
      reverse: !1,
      weight: 1e3,
      onClick(t, e, i) {
        const s = e.datasetIndex,
          n = i.chart;
        n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1)
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: t => t.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(t) {
          const s = t.data.datasets,
            {
              labels: {
                usePointStyle: n,
                pointStyle: a,
                textAlign: o,
                color: r
              }
            } = t.legend.options;
          return t._getSortedDatasetMetas().map(t => {
            var e = t.controller.getStyle(n ? 0 : void 0),
              i = Pe(e.borderWidth);
            return {
              text: s[t.index].label,
              fillStyle: e.backgroundColor,
              fontColor: r,
              hidden: !t.visible,
              lineCap: e.borderCapStyle,
              lineDash: e.borderDash,
              lineDashOffset: e.borderDashOffset,
              lineJoin: e.borderJoinStyle,
              lineWidth: (i.width + i.height) / 4,
              strokeStyle: e.borderColor,
              pointStyle: a || e.pointStyle,
              rotation: e.rotation,
              textAlign: o || e.textAlign,
              borderRadius: 0,
              datasetIndex: t.index
            }
          }, this)
        }
      },
      title: {
        color: t => t.chart.options.color,
        display: !1,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: t => !t.startsWith("on"),
      labels: {
        _scriptable: t => !["generateLabels", "filter", "sort"].includes(t)
      }
    }
  };
  class jn extends Di {
    constructor(t) {
      super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0
    }
    update(t, e) {
      var i = this,
        s = i.options;
      i.left = 0, i.top = 0, s.display ? (i.width = i.right = t, i.height = i.bottom = e, e = B(s.text) ? s.text.length : 1, i._padding = Pe(s.padding), s = e * Ie(s.font).lineHeight + i._padding.height, i.isHorizontal() ? i.height = s : i.width = s) : i.width = i.height = i.right = i.bottom = 0
    }
    isHorizontal() {
      var t = this.options.position;
      return "top" === t || "bottom" === t
    }
    _drawArgs(t) {
      var {
        top: e,
        left: i,
        bottom: s,
        right: n,
        options: a
      } = this, o = a.align;
      let r, l, c, d = 0;
      return r = this.isHorizontal() ? (l = P(o, i, n), c = e + t, n - i) : (d = "left" === a.position ? (l = i + t, c = P(o, s, e), -.5 * ft) : (l = n - t, c = P(o, e, s), .5 * ft), s - e), {
        titleX: l,
        titleY: c,
        maxWidth: r,
        rotation: d
      }
    }
    draw() {
      var t, e, i, s, n, a = this.ctx,
        o = this.options;
      o.display && (n = (t = Ie(o.font)).lineHeight / 2 + this._padding.top, {
        titleX: e,
        titleY: i,
        maxWidth: s,
        rotation: n
      } = this._drawArgs(n), Qt(a, o.text, 0, 0, t, {
        color: o.color,
        maxWidth: s,
        rotation: n,
        textAlign: f(o.align),
        textBaseline: "middle",
        translation: [e, i]
      }))
    }
  }
  var Wn = {
    id: "title",
    _element: jn,
    start(t, e, i) {
      var s;
      s = t, t = i, i = new jn({
        ctx: s.ctx,
        options: t,
        chart: s
      }), Ve.configure(s, i, t), Ve.addBox(s, i), s.titleBlock = i
    },
    stop(t) {
      var e = t.titleBlock;
      Ve.removeBox(t, e), delete t.titleBlock
    },
    beforeUpdate(t, e, i) {
      const s = t.titleBlock;
      Ve.configure(t, s, i), s.options = i
    },
    defaults: {
      align: "center",
      display: !1,
      font: {
        weight: "bold"
      },
      fullSize: !0,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: !0,
      _indexable: !1
    }
  };
  const Vn = {
    average(t) {
      if (!t.length) return !1;
      let e, i, s = 0,
        n = 0,
        a = 0;
      for (e = 0, i = t.length; e < i; ++e) {
        const i = t[e].element;
        if (i && i.hasValue()) {
          const t = i.tooltipPosition();
          s += t.x, n += t.y, ++a
        }
      }
      return {
        x: s / a,
        y: n / a
      }
    },
    nearest(t, e) {
      if (!t.length) return !1;
      let i, s, n, a = e.x,
        o = e.y,
        r = Number.POSITIVE_INFINITY;
      for (i = 0, s = t.length; i < s; ++i) {
        const s = t[i].element;
        if (s && s.hasValue()) {
          const t = $t(e, s.getCenterPoint());
          t < r && (r = t, n = s)
        }
      }
      if (n) {
        const t = n.tooltipPosition();
        a = t.x, o = t.y
      }
      return {
        x: a,
        y: o
      }
    }
  };

  function qn(t, e) {
    return e && (B(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
  }

  function Yn(t) {
    return ("string" == typeof t || t instanceof String) && -1 < t.indexOf("\n") ? t.split("\n") : t
  }

  function Un(t, e) {
    const i = t._chart.ctx,
      {
        body: s,
        footer: n,
        title: a
      } = t,
      {
        boxWidth: o,
        boxHeight: r
      } = e,
      l = Ie(e.bodyFont),
      c = Ie(e.titleFont),
      d = Ie(e.footerFont),
      h = a.length,
      u = n.length,
      p = s.length,
      f = Pe(e.padding);
    let m = f.height,
      g = 0,
      v = s.reduce((t, e) => t + e.before.length + e.lines.length + e.after.length, 0);
    v += t.beforeBody.length + t.afterBody.length, h && (m += h * c.lineHeight + (h - 1) * e.titleSpacing + e.titleMarginBottom), v && (m += p * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (v - p) * l.lineHeight + (v - 1) * e.bodySpacing), u && (m += e.footerMarginTop + u * d.lineHeight + (u - 1) * e.footerSpacing);
    let b = 0;
    const _ = function (t) {
      g = Math.max(g, i.measureText(t).width + b)
    };
    return i.save(), i.font = c.string, G(t.title, _), i.font = l.string, G(t.beforeBody.concat(t.afterBody), _), b = e.displayColors ? o + 2 : 0, G(s, t => {
      G(t.before, _), G(t.lines, _), G(t.after, _)
    }), b = 0, i.font = d.string, G(t.footer, _), i.restore(), g += f.width, {
      width: g,
      height: m
    }
  }

  function Xn(i, t, s) {
    var e = t.yAlign || function () {
      var {
        y: t,
        height: e
      } = s;
      return t < e / 2 ? "top" : t > i.height - e / 2 ? "bottom" : "center"
    }();
    return {
      xAlign: t.xAlign || function (n, a, o, t) {
        var {
          x: e,
          width: i
        } = o, {
          width: s,
          chartArea: {
            left: r,
            right: l
          }
        } = n;
        let c = "center";
        return "center" === t ? c = e <= (r + l) / 2 ? "left" : "right" : e <= i / 2 ? c = "left" : s - i / 2 <= e && (c = "right"),
          function (t) {
            var {
              x: e,
              width: i
            } = o, s = a.caretSize + a.caretPadding;
            return "left" === t && e + i + s > n.width || "right" === t && e - i - s < 0
          }(c) && (c = "center"), c
      }(i, t, s, e),
      yAlign: e
    }
  }

  function Gn(t, i, e, s) {
    var {
      caretSize: n,
      caretPadding: a,
      cornerRadius: t
    } = t, {
      xAlign: o,
      yAlign: r
    } = e, l = n + a, t = t + a;
    let c = function () {
      let {
        x: t,
        width: e
      } = i;
      return "right" === o ? t -= e : "center" === o && (t -= e / 2), t
    }();
    a = function () {
      let {
        y: t,
        height: e
      } = i;
      return "top" === r ? t += l : t -= "bottom" === r ? e + l : e / 2, t
    }();
    return "center" === r ? "left" === o ? c += l : "right" === o && (c -= l) : "left" === o ? c -= t : "right" === o && (c += t), {
      x: Ft(c, 0, s.width - i.width),
      y: Ft(a, 0, s.height - i.height)
    }
  }

  function Kn(t, e, i) {
    i = Pe(i.padding);
    return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - i.right : t.x + i.left
  }

  function Qn(t) {
    return qn([], Yn(t))
  }

  function Jn(t, e) {
    e = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;
    return e ? t.override(e) : t
  }
  class Zn extends Di {
    constructor(t) {
      super(), this.opacity = 0, this._active = [], this._chart = t._chart, this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0
    }
    initialize(t) {
      this.options = t, this._cachedAnimations = void 0, this.$context = void 0
    }
    _resolveAnimations() {
      var t = this._cachedAnimations;
      if (t) return t;
      var e = this._chart,
        t = this.options.setContext(this.getContext()),
        e = t.enabled && e.options.animation && t.animations,
        t = new fi(this._chart, e);
      return e._cacheable && (this._cachedAnimations = Object.freeze(t)), t
    }
    getContext() {
      var t, e;
      return this.$context || (this.$context = (t = this._chart.getContext(), e = this._tooltipItems, Object.assign(Object.create(t), {
        tooltip: this,
        tooltipItems: e,
        type: "tooltip"
      })))
    }
    getTitle(t, e) {
      const {
        callbacks: i
      } = e, s = i.beforeTitle.apply(this, [t]), n = i.title.apply(this, [t]), a = i.afterTitle.apply(this, [t]);
      t = qn(t = [], Yn(s));
      return t = qn(t, Yn(n)), t = qn(t, Yn(a))
    }
    getBeforeBody(t, e) {
      return Qn(e.callbacks.beforeBody.apply(this, [t]))
    }
    getBody(t, e) {
      const s = this,
        {
          callbacks: n
        } = e,
        a = [];
      return G(t, t => {
        const e = {
            before: [],
            lines: [],
            after: []
          },
          i = Jn(n, t);
        qn(e.before, Yn(i.beforeLabel.call(s, t))), qn(e.lines, i.label.call(s, t)), qn(e.after, Yn(i.afterLabel.call(s, t))), a.push(e)
      }), a
    }
    getAfterBody(t, e) {
      return Qn(e.callbacks.afterBody.apply(this, [t]))
    }
    getFooter(t, e) {
      const {
        callbacks: i
      } = e, s = i.beforeFooter.apply(this, [t]), n = i.footer.apply(this, [t]), a = i.afterFooter.apply(this, [t]);
      t = qn(t = [], Yn(s));
      return t = qn(t, Yn(n)), t = qn(t, Yn(a))
    }
    _createItems(s) {
      const i = this,
        t = i._active,
        n = i._chart.data,
        a = [],
        o = [],
        r = [];
      let e, l, c = [];
      for (e = 0, l = t.length; e < l; ++e) c.push(function (t, e) {
        const {
          element: i,
          datasetIndex: s,
          index: n
        } = e, a = t.getDatasetMeta(s).controller, {
          label: o,
          value: r
        } = a.getLabelAndValue(n);
        return {
          chart: t,
          label: o,
          parsed: a.getParsed(n),
          raw: t.data.datasets[s].data[n],
          formattedValue: r,
          dataset: a.getDataset(),
          dataIndex: n,
          datasetIndex: s,
          element: i
        }
      }(i._chart, t[e]));
      return s.filter && (c = c.filter((t, e, i) => s.filter(t, e, i, n))), s.itemSort && (c = c.sort((t, e) => s.itemSort(t, e, n))), G(c, t => {
        const e = Jn(s.callbacks, t);
        a.push(e.labelColor.call(i, t)), o.push(e.labelPointStyle.call(i, t)), r.push(e.labelTextColor.call(i, t))
      }), i.labelColors = a, i.labelPointStyles = o, i.labelTextColors = r, i.dataPoints = c, c
    }
    update(t, e) {
      const i = this,
        s = i.options.setContext(i.getContext()),
        n = i._active;
      let a, o = [];
      if (n.length) {
        const t = Vn[s.position].call(i, n, i._eventPosition);
        o = i._createItems(s), i.title = i.getTitle(o, s), i.beforeBody = i.getBeforeBody(o, s), i.body = i.getBody(o, s), i.afterBody = i.getAfterBody(o, s), i.footer = i.getFooter(o, s);
        const e = i._size = Un(i, s),
          r = Object.assign({}, t, e),
          l = Xn(i._chart, s, r),
          c = Gn(s, r, l, i._chart);
        i.xAlign = l.xAlign, i.yAlign = l.yAlign, a = {
          opacity: 1,
          x: c.x,
          y: c.y,
          width: e.width,
          height: e.height,
          caretX: t.x,
          caretY: t.y
        }
      } else 0 !== i.opacity && (a = {
        opacity: 0
      });
      i._tooltipItems = o, i.$context = void 0, a && i._resolveAnimations().update(i, a), t && s.external && s.external.call(i, {
        chart: i._chart,
        tooltip: i,
        replay: e
      })
    }
    drawCaret(t, e, i, s) {
      s = this.getCaretPosition(t, i, s);
      e.lineTo(s.x1, s.y1), e.lineTo(s.x2, s.y2), e.lineTo(s.x3, s.y3)
    }
    getCaretPosition(t, e, i) {
      var {
        xAlign: s,
        yAlign: n
      } = this, {
        cornerRadius: a,
        caretSize: o
      } = i, {
        x: r,
        y: i
      } = t, {
        width: t,
        height: e
      } = e;
      let l, c, d, h, u, p;
      return "center" === n ? (u = i + e / 2, p = "left" === s ? (l = r, c = l - o, h = u + o, u - o) : (l = r + t, c = l + o, h = u - o, u + o), d = l) : (c = "left" === s ? r + a + o : "right" === s ? r + t - a - o : this.caretX, d = "top" === n ? (h = i, u = h - o, l = c - o, c + o) : (h = i + e, u = h + o, l = c + o, c - o), p = h), {
        x1: l,
        x2: c,
        x3: d,
        y1: h,
        y2: u,
        y3: p
      }
    }
    drawTitle(t, e, i) {
      var s = this.title,
        n = s.length;
      let a, o, r;
      if (n) {
        const l = as(i.rtl, this.x, this.width);
        for (t.x = Kn(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = "middle", a = Ie(i.titleFont), o = i.titleSpacing, e.fillStyle = i.titleColor, e.font = a.string, r = 0; r < n; ++r) e.fillText(s[r], l.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + o, r + 1 === n && (t.y += i.titleMarginBottom - o)
      }
    }
    _drawColorBox(t, e, i, s, n) {
      const a = this,
        o = a.labelColors[i],
        r = a.labelPointStyles[i],
        {
          boxHeight: l,
          boxWidth: c
        } = n,
        d = Ie(n.bodyFont),
        h = Kn(a, "left", n),
        u = s.x(h),
        p = l < d.lineHeight ? (d.lineHeight - l) / 2 : 0,
        f = e.y + p;
      if (n.usePointStyle) {
        const e = {
            radius: Math.min(c, l) / 2,
            pointStyle: r.pointStyle,
            rotation: r.rotation,
            borderWidth: 1
          },
          i = s.leftForLtr(u, c) + c / 2,
          a = f + l / 2;
        t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, qt(t, e, i, a), t.strokeStyle = o.borderColor, t.fillStyle = o.backgroundColor, qt(t, e, i, a)
      } else {
        t.lineWidth = o.borderWidth || 1, t.strokeStyle = o.borderColor, t.setLineDash(o.borderDash || []), t.lineDashOffset = o.borderDashOffset || 0;
        const e = s.leftForLtr(u, c),
          i = s.leftForLtr(s.xPlus(u, 1), c - 2),
          a = Ae(o.borderRadius);
        Object.values(a).some(t => 0 !== t) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, Jt(t, {
          x: e,
          y: f,
          w: c,
          h: l,
          radius: a
        }), t.fill(), t.stroke(), t.fillStyle = o.backgroundColor, t.beginPath(), Jt(t, {
          x: i,
          y: f + 1,
          w: c - 2,
          h: l - 2,
          radius: a
        }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(e, f, c, l), t.strokeRect(e, f, c, l), t.fillStyle = o.backgroundColor, t.fillRect(i, f + 1, c - 2, l - 2))
      }
      t.fillStyle = a.labelTextColors[i]
    }
    drawBody(e, i, t) {
      const {
        body: s
      } = this, {
        bodySpacing: n,
        bodyAlign: a,
        displayColors: o,
        boxHeight: r,
        boxWidth: l
      } = t, c = Ie(t.bodyFont);
      let d = c.lineHeight,
        h = 0;
      const u = as(t.rtl, this.x, this.width),
        p = function (t) {
          i.fillText(t, u.x(e.x + h), e.y + d / 2), e.y += d + n
        },
        f = u.textAlign(a);
      let m, g, v, b, _, y, w;
      for (i.textAlign = a, i.textBaseline = "middle", i.font = c.string, e.x = Kn(this, f, t), i.fillStyle = t.bodyColor, G(this.beforeBody, p), h = o && "right" !== f ? "center" === a ? l / 2 + 1 : l + 2 : 0, b = 0, y = s.length; b < y; ++b) {
        for (m = s[b], g = this.labelTextColors[b], i.fillStyle = g, G(m.before, p), v = m.lines, o && v.length && (this._drawColorBox(i, e, b, u, t), d = Math.max(c.lineHeight, r)), _ = 0, w = v.length; _ < w; ++_) p(v[_]), d = c.lineHeight;
        G(m.after, p)
      }
      h = 0, d = c.lineHeight, G(this.afterBody, p), e.y -= n
    }
    drawFooter(t, e, i) {
      var s = this.footer,
        n = s.length;
      let a, o;
      if (n) {
        const r = as(i.rtl, this.x, this.width);
        for (t.x = Kn(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = "middle", a = Ie(i.footerFont), e.fillStyle = i.footerColor, e.font = a.string, o = 0; o < n; ++o) e.fillText(s[o], r.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + i.footerSpacing
      }
    }
    drawBackground(t, e, i, s) {
      var {
        xAlign: n,
        yAlign: a
      } = this, {
        x: o,
        y: r
      } = t, {
        width: l,
        height: c
      } = i, d = s.cornerRadius;
      e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(o + d, r), "top" === a && this.drawCaret(t, e, i, s), e.lineTo(o + l - d, r), e.quadraticCurveTo(o + l, r, o + l, r + d), "center" === a && "right" === n && this.drawCaret(t, e, i, s), e.lineTo(o + l, r + c - d), e.quadraticCurveTo(o + l, r + c, o + l - d, r + c), "bottom" === a && this.drawCaret(t, e, i, s), e.lineTo(o + d, r + c), e.quadraticCurveTo(o, r + c, o, r + c - d), "center" === a && "left" === n && this.drawCaret(t, e, i, s), e.lineTo(o, r + d), e.quadraticCurveTo(o, r, o + d, r), e.closePath(), e.fill(), 0 < s.borderWidth && e.stroke()
    }
    _updateAnimationTarget(t) {
      const e = this,
        i = e._chart,
        s = e.$animations,
        n = s && s.x,
        a = s && s.y;
      if (n || a) {
        const s = Vn[t.position].call(e, e._active, e._eventPosition);
        var o, r;
        s && (o = e._size = Un(e, t), r = Gn(t, r = Object.assign({}, s, e._size), t = Xn(i, t, r), i), n._to === r.x && a._to === r.y || (e.xAlign = t.xAlign, e.yAlign = t.yAlign, e.width = o.width, e.height = o.height, e.caretX = s.x, e.caretY = s.y, e._resolveAnimations().update(e, r)))
      }
    }
    draw(t) {
      var e = this,
        i = e.options.setContext(e.getContext());
      let s = e.opacity;
      if (s) {
        e._updateAnimationTarget(i);
        const o = {
            width: e.width,
            height: e.height
          },
          r = {
            x: e.x,
            y: e.y
          };
        s = Math.abs(s) < .001 ? 0 : s;
        var n = Pe(i.padding),
          a = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length;
        i.enabled && a && (t.save(), t.globalAlpha = s, e.drawBackground(r, t, o, i), os(t, i.textDirection), r.y += n.top, e.drawTitle(r, t, i), e.drawBody(r, t, i), e.drawFooter(r, t, i), rs(t, i.textDirection), t.restore())
      }
    }
    getActiveElements() {
      return this._active || []
    }
    setActiveElements(t, e) {
      const s = this,
        i = s._active,
        n = t.map(({
          datasetIndex: t,
          index: e
        }) => {
          var i = s._chart.getDatasetMeta(t);
          if (!i) throw new Error("Cannot find a dataset at index " + t);
          return {
            datasetIndex: t,
            element: i.data[e],
            index: e
          }
        }),
        a = !K(i, n),
        o = s._positionChanged(n, e);
      (a || o) && (s._active = n, s._eventPosition = e, s.update(!0))
    }
    handleEvent(t, e) {
      var i = this.options,
        s = this._active || [];
      let n, a = [];
      "mouseout" !== t.type && (a = this._chart.getElementsAtEventForMode(t, i.mode, i, e), i.reverse && a.reverse());
      var o = this._positionChanged(a, t);
      return (n = e || !K(a, s) || o) && (this._active = a, (i.enabled || i.external) && (this._eventPosition = {
        x: t.x,
        y: t.y
      }, this.update(!0, e))), n
    }
    _positionChanged(t, e) {
      var {
        caretX: i,
        caretY: s,
        options: n
      } = this, e = Vn[n.position].call(this, t, e);
      return !1 !== e && (i !== e.x || s !== e.y)
    }
  }
  Zn.positioners = Vn;
  ve = {
    id: "tooltip",
    _element: Zn,
    positioners: Vn,
    afterInit(t, e, i) {
      i && (t.tooltip = new Zn({
        _chart: t,
        options: i
      }))
    },
    beforeUpdate(t, e, i) {
      t.tooltip && t.tooltip.initialize(i)
    },
    reset(t, e, i) {
      t.tooltip && t.tooltip.initialize(i)
    },
    afterDraw(t) {
      const e = t.tooltip,
        i = {
          tooltip: e
        };
      !1 !== t.notifyPlugins("beforeTooltipDraw", i) && (e && e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i))
    },
    afterEvent(t, e) {
      var i;
      t.tooltip && (i = e.replay, t.tooltip.handleEvent(e.event, i) && (e.changed = !0))
    },
    defaults: {
      enabled: !0,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (t, e) => e.bodyFont.size,
      boxWidth: (t, e) => e.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: !0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: ["x", "y", "width", "height", "caretX", "caretY"]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: {
        beforeTitle: t,
        title(t) {
          if (0 < t.length) {
            var e = t[0],
              i = e.chart.data.labels,
              t = i ? i.length : 0;
            if (this && this.options && "dataset" === this.options.mode) return e.dataset.label || "";
            if (e.label) return e.label;
            if (0 < t && e.dataIndex < t) return i[e.dataIndex]
          }
          return ""
        },
        afterTitle: t,
        beforeBody: t,
        beforeLabel: t,
        label(t) {
          if (this && this.options && "dataset" === this.options.mode) return t.label + ": " + t.formattedValue || t.formattedValue;
          let e = t.dataset.label || "";
          e && (e += ": ");
          t = t.formattedValue;
          return R(t) || (e += t), e
        },
        labelColor(t) {
          t = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
          return {
            borderColor: t.borderColor,
            backgroundColor: t.backgroundColor,
            borderWidth: t.borderWidth,
            borderDash: t.borderDash,
            borderDashOffset: t.borderDashOffset,
            borderRadius: 0
          }
        },
        labelTextColor() {
          return this.options.bodyColor
        },
        labelPointStyle(t) {
          t = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);
          return {
            pointStyle: t.pointStyle,
            rotation: t.rotation
          }
        },
        afterLabel: t,
        afterBody: t,
        beforeFooter: t,
        footer: t,
        afterFooter: t
      }
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t,
      _indexable: !1,
      callbacks: {
        _scriptable: !1,
        _indexable: !1
      },
      animation: {
        _fallback: !1
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: ["interaction"]
  }, Wn = Object.freeze({
    __proto__: null,
    Decimation: Sn,
    Filler: Fn,
    Legend: Bn,
    Title: Wn,
    Tooltip: ve
  });
  class ta extends Hi {
    constructor(t) {
      super(t), this._startValue = void 0, this._valueRange = 0
    }
    parse(t, e) {
      if (R(t)) return null;
      var i, s, n, a, o, r = this.getLabels();
      return e = e = isFinite(e) && r[e] === t ? e : (n = q(e, s = t), -1 === (o = (i = r).indexOf(s)) ? (a = n, "string" == typeof (t = s) ? i.push(t) - 1 : isNaN(t) ? null : a) : o !== i.lastIndexOf(s) ? n : o), r = r.length - 1, null === e ? null : Ft(Math.round(e), 0, r)
    }
    determineDataLimits() {
      var {
        minDefined: t,
        maxDefined: e
      } = this.getUserBounds();
      let {
        min: i,
        max: s
      } = this.getMinMax(!0);
      "ticks" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s
    }
    buildTicks() {
      const e = this.min,
        i = this.max,
        t = this.options.offset,
        s = [];
      let n = this.getLabels();
      n = 0 === e && i === n.length - 1 ? n : n.slice(e, i + 1), this._valueRange = Math.max(n.length - (t ? 0 : 1), 1), this._startValue = this.min - (t ? .5 : 0);
      for (let t = e; t <= i; t++) s.push({
        value: t
      });
      return s
    }
    getLabelForValue(t) {
      var e = this.getLabels();
      return 0 <= t && t < e.length ? e[t] : t
    }
    configure() {
      super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels)
    }
    getPixelForValue(t) {
      return null === (t = "number" != typeof t ? this.parse(t) : t) ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    }
    getPixelForTick(t) {
      var e = this.ticks;
      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
    }
    getValueForPixel(t) {
      return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
    }
    getBasePixel() {
      return this.bottom
    }
  }
  ta.id = "category", ta.defaults = {
    ticks: {
      callback: ta.prototype.getLabelForValue
    }
  };
  class ea extends Hi {
    constructor(t) {
      super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0
    }
    parse(t, e) {
      return R(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t
    }
    handleTickRangeOptions() {
      const t = this,
        {
          beginAtZero: e,
          stacked: i
        } = t.options,
        {
          minDefined: s,
          maxDefined: n
        } = t.getUserBounds();
      let {
        min: a,
        max: o
      } = t;
      var r = t => a = s ? a : t,
        l = t => o = n ? o : t;
      if (e || i) {
        const t = Ct(a),
          e = Ct(o);
        t < 0 && e < 0 ? l(0) : 0 < t && 0 < e && r(0)
      }
      a === o && (l(o + 1), e || r(a - 1)), t.min = a, t.max = o
    }
    getTickLimit() {
      let t, {
        maxTicksLimit: e,
        stepSize: i
      } = this.options.ticks;
      return i ? t = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1 : (t = this.computeTickLimit(), e = e || 11), e && (t = Math.min(e, t)), t
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY
    }
    buildTicks() {
      var y = this,
        w = y.options,
        x = w.ticks,
        C = y.getTickLimit(),
        C = Math.max(2, C);
      const t = function () {
        const t = [],
          {
            step: e,
            min: i,
            max: s,
            precision: n,
            count: a,
            maxTicks: o
          } = {
            maxTicks: C,
            min: w.min,
            max: w.max,
            precision: x.precision,
            step: x.stepSize,
            count: x.count
          },
          r = e || 1,
          l = o - 1,
          {
            min: c,
            max: d
          } = y._range || y,
          h = !R(i),
          u = !R(s),
          p = !R(a);
        let f, m, g, v, b = kt((d - c) / l / r) * r;
        if (b < 1e-14 && !h && !u) return [{
          value: c
        }, {
          value: d
        }];
        v = Math.ceil(d / b) - Math.floor(c / b), v > l && (b = kt(v * b / l / r) * r), R(n) || (f = Math.pow(10, n), b = Math.ceil(b * f) / f), m = Math.floor(c / b) * b, g = Math.ceil(d / b) * b, h && u && e && Mt((s - i) / e, b / 1e3) ? (v = Math.min((s - i) / b, o), b = (s - i) / v, m = i, g = s) : p ? (m = h ? i : m, g = u ? s : g, v = a - 1, b = (g - m) / v) : (v = (g - m) / b, v = St(v, Math.round(v), b / 1e3) ? Math.round(v) : Math.ceil(v)), f = Math.pow(10, R(n) ? It(b) : n), m = Math.round(m * f) / f, g = Math.round(g * f) / f;
        let _ = 0;
        for (h && (t.push({
            value: i
          }), m <= i && _++, St(Math.round((m + _ * b) * f) / f, i, b / 10) && _++); _ < v; ++_) t.push({
          value: Math.round((m + _ * b) * f) / f
        });
        return u ? St(t[t.length - 1].value, s, b / 10) ? t[t.length - 1].value = s : t.push({
          value: s
        }) : t.push({
          value: g
        }), t
      }();
      return "ticks" === w.bounds && Et(t, y, "value"), w.reverse ? (t.reverse(), y.start = y.max, y.end = y.min) : (y.start = y.min, y.end = y.max), t
    }
    configure() {
      const t = this,
        e = t.ticks;
      let i = t.min,
        s = t.max;
      if (super.configure(), t.options.offset && e.length) {
        const t = (s - i) / Math.max(e.length - 1, 1) / 2;
        i -= t, s += t
      }
      t._startValue = i, t._endValue = s, t._valueRange = s - i
    }
    getLabelForValue(t) {
      return Mi(t, this.chart.options.locale)
    }
  }
  class ia extends ea {
    determineDataLimits() {
      var {
        min: t,
        max: e
      } = this.getMinMax(!0);
      this.min = W(t) ? t : 0, this.max = W(e) ? e : 1, this.handleTickRangeOptions()
    }
    computeTickLimit() {
      if (this.isHorizontal()) return Math.ceil(this.width / 40);
      var t = this._resolveTickFontOptions(0);
      return Math.ceil(this.height / t.lineHeight)
    }
    getPixelForValue(t) {
      return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
    }
    getValueForPixel(t) {
      return this._startValue + this.getDecimalForPixel(t) * this._valueRange
    }
  }

  function sa(t) {
    return 1 == t / Math.pow(10, Math.floor(xt(t)))
  }
  ia.id = "linear", ia.defaults = {
    ticks: {
      callback: Ai.formatters.numeric
    }
  };
  class na extends Hi {
    constructor(t) {
      super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0
    }
    parse(t, e) {
      e = ea.prototype.parse.apply(this, [t, e]);
      if (0 !== e) return W(e) && 0 < e ? e : null;
      this._zero = !0
    }
    determineDataLimits() {
      var {
        min: t,
        max: e
      } = this.getMinMax(!0);
      this.min = W(t) ? Math.max(0, t) : null, this.max = W(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this.handleTickRangeOptions()
    }
    handleTickRangeOptions() {
      const {
        minDefined: e,
        maxDefined: i
      } = this.getUserBounds();
      let s = this.min,
        n = this.max;
      var t = t => s = e ? s : t,
        a = t => n = i ? n : t,
        o = (t, e) => Math.pow(10, Math.floor(xt(t)) + e);
      s === n && (s <= 0 ? (t(1), a(10)) : (t(o(s, -1)), a(o(n, 1)))), s <= 0 && t(o(n, -1)), n <= 0 && a(o(s, 1)), this._zero && this.min !== this._suggestedMin && s === o(this.min, 0) && t(o(s, -1)), this.min = s, this.max = n
    }
    buildTicks() {
      const t = this,
        e = t.options,
        i = function (t, e) {
          const i = Math.floor(xt(e.max)),
            s = Math.ceil(e.max / Math.pow(10, i)),
            n = [];
          let a = V(t.min, Math.pow(10, Math.floor(xt(e.min)))),
            o = Math.floor(xt(a)),
            r = Math.floor(a / Math.pow(10, o)),
            l = o < 0 ? Math.pow(10, Math.abs(o)) : 1;
          for (; n.push({
              value: a,
              major: sa(a)
            }), ++r, 10 === r && (r = 1, ++o, l = 0 <= o ? 1 : l), a = Math.round(r * Math.pow(10, o) * l) / l, o < i || o === i && r < s;);
          t = V(t.max, a);
          return n.push({
            value: t,
            major: sa(a)
          }), n
        }({
          min: t._userMin,
          max: t._userMax
        }, t);
      return "ticks" === e.bounds && Et(i, t, "value"), e.reverse ? (i.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i
    }
    getLabelForValue(t) {
      return void 0 === t ? "0" : Mi(t, this.chart.options.locale)
    }
    configure() {
      var t = this.min;
      super.configure(), this._startValue = xt(t), this._valueRange = xt(this.max) - xt(t)
    }
    getPixelForValue(t) {
      return null === (t = void 0 === t || 0 === t ? this.min : t) || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (xt(t) - this._startValue) / this._valueRange)
    }
    getValueForPixel(t) {
      t = this.getDecimalForPixel(t);
      return Math.pow(10, this._startValue + t * this._valueRange)
    }
  }

  function aa(t) {
    var e = t.ticks;
    if (e.display && t.display) {
      const t = Pe(e.backdropPadding);
      return q(e.font && e.font.size, pt.font.size) + t.height
    }
    return 0
  }

  function oa(t, e, i, s, n) {
    return t === s || t === n ? {
      start: e - i / 2,
      end: e + i / 2
    } : t < s || n < t ? {
      start: e - i,
      end: e
    } : {
      start: e,
      end: e + i
    }
  }

  function ra(e, i, t, s) {
    const {
      ctx: n
    } = e;
    if (t) n.arc(e.xCenter, e.yCenter, i, 0, mt);
    else {
      var a = e.getPointPosition(0, i);
      n.moveTo(a.x, a.y);
      for (let t = 1; t < s; t++) a = e.getPointPosition(t, i), n.lineTo(a.x, a.y)
    }
  }

  function la(t) {
    return Dt(t) ? t : 0
  }
  na.id = "logarithmic", na.defaults = {
    ticks: {
      callback: Ai.formatters.logarithmic,
      major: {
        enabled: !0
      }
    }
  };
  class ca extends ea {
    constructor(t) {
      super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = []
    }
    setDimensions() {
      var t = this;
      t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = aa(t.options) / 2, t.xCenter = Math.floor(t.width / 2), t.yCenter = Math.floor((t.height - t.paddingTop) / 2), t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2
    }
    determineDataLimits() {
      var {
        min: t,
        max: e
      } = this.getMinMax(!1);
      this.min = W(t) && !isNaN(t) ? t : 0, this.max = W(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions()
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / aa(this.options))
    }
    generateTickLabels(t) {
      const i = this;
      ea.prototype.generateTickLabels.call(i, t), i._pointLabels = i.getLabels().map((t, e) => {
        e = X(i.options.pointLabels.callback, [t, e], i);
        return e || 0 === e ? e : ""
      })
    }
    fit() {
      var t = this.options;
      t.display && t.pointLabels.display ? function (t) {
        const e = {
            l: 0,
            r: t.width,
            t: 0,
            b: t.height - t.paddingTop
          },
          i = {};
        let s, n, a;
        const o = [],
          r = [],
          l = t.getLabels().length;
        for (s = 0; s < l; s++) {
          const l = t.options.pointLabels.setContext(t.getContext(s));
          r[s] = l.padding, a = t.getPointPosition(s, t.drawingArea + r[s]);
          const f = Ie(l.font);
          t.ctx.font = f.string, c = t.ctx, d = f.lineHeight, n = B(h = t._pointLabels[s]) ? {
            w: jt(c, c.font, h),
            h: h.length * d
          } : {
            w: c.measureText(h).width,
            h: d
          }, o[s] = n;
          const m = t.getIndexAngle(s),
            g = Pt(m),
            b = oa(g, a.x, n.w, 0, 180),
            _ = oa(g, a.y, n.h, 90, 270);
          b.start < e.l && (e.l = b.start, i.l = m), b.end > e.r && (e.r = b.end, i.r = m), _.start < e.t && (e.t = _.start, i.t = m), _.end > e.b && (e.b = _.end, i.b = m)
        }
        var c, d, h, u, p;
        t._setReductions(t.drawingArea, e, i), t._pointLabelItems = [];
        const f = t.options,
          m = aa(f),
          g = t.getDistanceFromCenterForValue(f.ticks.reverse ? t.min : t.max);
        for (s = 0; s < l; s++) {
          const e = 0 === s ? m / 2 : 0,
            i = t.getPointPosition(s, g + e + r[s]),
            n = Pt(t.getIndexAngle(s)),
            a = o[s];
          u = n, v = a, p = i, 90 === u || 270 === u ? p.y -= v.h / 2 : (270 < u || u < 90) && (p.y -= v.h);
          const l = 0 === (v = n) || 180 === v ? "center" : v < 180 ? "left" : "right";
          var v = "left" == l ? i.x : "center" == l ? i.x - a.w / 2 : i.x - a.w;
          const d = v + a.w;
          t._pointLabelItems[s] = {
            x: i.x,
            y: i.y,
            textAlign: l,
            left: v,
            top: i.y,
            right: d,
            bottom: i.y + a.h
          }
        }
      }(this) : this.setCenterPoint(0, 0, 0, 0)
    }
    _setReductions(t, e, i) {
      var s = e.l / Math.sin(i.l),
        n = Math.max(e.r - this.width, 0) / Math.sin(i.r),
        a = -e.t / Math.cos(i.t),
        i = -Math.max(e.b - (this.height - this.paddingTop), 0) / Math.cos(i.b),
        s = la(s),
        n = la(n),
        a = la(a),
        i = la(i);
      this.drawingArea = Math.max(t / 2, Math.min(Math.floor(t - (s + n) / 2), Math.floor(t - (a + i) / 2))), this.setCenterPoint(s, n, a, i)
    }
    setCenterPoint(t, e, i, s) {
      var n = this,
        e = n.width - e - n.drawingArea,
        t = t + n.drawingArea,
        i = i + n.drawingArea,
        s = n.height - n.paddingTop - s - n.drawingArea;
      n.xCenter = Math.floor((t + e) / 2 + n.left), n.yCenter = Math.floor((i + s) / 2 + n.top + n.paddingTop)
    }
    getIndexAngle(t) {
      return Nt(t * (mt / this.getLabels().length) + At(this.options.startAngle || 0))
    }
    getDistanceFromCenterForValue(t) {
      if (R(t)) return NaN;
      var e = this.drawingArea / (this.max - this.min);
      return this.options.reverse ? (this.max - t) * e : (t - this.min) * e
    }
    getValueForDistanceFromCenter(t) {
      if (R(t)) return NaN;
      t /= this.drawingArea / (this.max - this.min);
      return this.options.reverse ? this.max - t : this.min + t
    }
    getPointPosition(t, e) {
      t = this.getIndexAngle(t) - _t;
      return {
        x: Math.cos(t) * e + this.xCenter,
        y: Math.sin(t) * e + this.yCenter,
        angle: t
      }
    }
    getPointPositionForValue(t, e) {
      return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
    }
    getBasePosition(t) {
      return this.getPointPositionForValue(t || 0, this.getBaseValue())
    }
    getPointLabelPosition(t) {
      var {
        left: e,
        top: i,
        right: s,
        bottom: t
      } = this._pointLabelItems[t];
      return {
        left: e,
        top: i,
        right: s,
        bottom: t
      }
    }
    drawBackground() {
      var {
        backgroundColor: t,
        grid: {
          circular: e
        }
      } = this.options;
      if (t) {
        const i = this.ctx;
        i.save(), i.beginPath(), ra(this, this.getDistanceFromCenterForValue(this._endValue), e, this.getLabels().length), i.closePath(), i.fillStyle = t, i.fill(), i.restore()
      }
    }
    drawGrid() {
      const i = this,
        t = i.ctx,
        e = i.options,
        {
          angleLines: s,
          grid: n
        } = e,
        a = i.getLabels().length;
      let o, r, l;
      if (e.pointLabels.display && function (e, i) {
          const {
            ctx: s,
            options: {
              pointLabels: n
            }
          } = e;
          for (let t = i - 1; 0 <= t; t--) {
            const i = n.setContext(e.getContext(t)),
              a = Ie(i.font),
              {
                x: o,
                y: r,
                textAlign: l,
                left: c,
                top: d,
                right: h,
                bottom: u
              } = e._pointLabelItems[t],
              {
                backdropColor: p
              } = i;
            if (!R(p)) {
              const e = Pe(i.backdropPadding);
              s.fillStyle = p, s.fillRect(c - e.left, d - e.top, h - c + e.width, u - d + e.height)
            }
            Qt(s, e._pointLabels[t], o, r + a.lineHeight / 2, a, {
              color: i.color,
              textAlign: l,
              textBaseline: "middle"
            })
          }
        }(i, a), n.display && i.ticks.forEach((t, e) => {
          0 !== e && (r = i.getDistanceFromCenterForValue(t.value), e = n.setContext(i.getContext(e - 1)), function (t, e, i, s) {
            const n = t.ctx,
              a = e.circular,
              {
                color: o,
                lineWidth: r
              } = e;
            !a && !s || !o || !r || i < 0 || (n.save(), n.strokeStyle = o, n.lineWidth = r, n.setLineDash(e.borderDash), n.lineDashOffset = e.borderDashOffset, n.beginPath(), ra(t, i, a, s), n.closePath(), n.stroke(), n.restore())
          }(i, e, r, a))
        }), s.display) {
        for (t.save(), o = i.getLabels().length - 1; 0 <= o; o--) {
          const n = s.setContext(i.getContext(o)),
            {
              color: a,
              lineWidth: c
            } = n;
          c && a && (t.lineWidth = c, t.strokeStyle = a, t.setLineDash(n.borderDash), t.lineDashOffset = n.borderDashOffset, r = i.getDistanceFromCenterForValue(e.ticks.reverse ? i.min : i.max), l = i.getPointPosition(o, r), t.beginPath(), t.moveTo(i.xCenter, i.yCenter), t.lineTo(l.x, l.y), t.stroke())
        }
        t.restore()
      }
    }
    drawBorder() {}
    drawLabels() {
      const o = this,
        r = o.ctx,
        l = o.options,
        c = l.ticks;
      if (c.display) {
        var t = o.getIndexAngle(0);
        let n, a;
        r.save(), r.translate(o.xCenter, o.yCenter), r.rotate(t), r.textAlign = "center", r.textBaseline = "middle", o.ticks.forEach((t, e) => {
          if (0 !== e || l.reverse) {
            var i = c.setContext(o.getContext(e)),
              s = Ie(i.font);
            if (n = o.getDistanceFromCenterForValue(o.ticks[e].value), i.showLabelBackdrop) {
              a = r.measureText(t.label).width, r.fillStyle = i.backdropColor;
              const o = Pe(i.backdropPadding);
              r.fillRect(-a / 2 - o.left, -n - s.size / 2 - o.top, a + o.width, s.size + o.height)
            }
            Qt(r, t.label, 0, -n, s, {
              color: i.color
            })
          }
        }), r.restore()
      }
    }
    drawTitle() {}
  }
  ca.id = "radialLinear", ca.defaults = {
    display: !0,
    animate: !0,
    position: "chartArea",
    angleLines: {
      display: !0,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: !1
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: !0,
      callback: Ai.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: !0,
      font: {
        size: 10
      },
      callback: t => t,
      padding: 5
    }
  }, ca.defaultRoutes = {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  };
  const da = {
      millisecond: {
        common: !0,
        size: 1,
        steps: 1e3
      },
      second: {
        common: !0,
        size: 1e3,
        steps: 60
      },
      minute: {
        common: !0,
        size: 6e4,
        steps: 60
      },
      hour: {
        common: !0,
        size: 36e5,
        steps: 24
      },
      day: {
        common: !0,
        size: 864e5,
        steps: 30
      },
      week: {
        common: !(ca.descriptors = {
          angleLines: {
            _fallback: "grid"
          }
        }),
        size: 6048e5,
        steps: 4
      },
      month: {
        common: !0,
        size: 2628e6,
        steps: 12
      },
      quarter: {
        common: !1,
        size: 7884e6,
        steps: 4
      },
      year: {
        common: !0,
        size: 3154e7
      }
    },
    ha = Object.keys(da);

  function ua(t, e) {
    return t - e
  }

  function pa(t, e) {
    if (R(e)) return null;
    const i = t._adapter,
      {
        parser: s,
        round: n,
        isoWeekday: a
      } = t._parseOpts;
    let o = e;
    return "function" == typeof s && (o = s(o)), W(o) || (o = "string" == typeof s ? i.parse(o, s) : i.parse(o)), null === o ? null : (n && (o = "week" !== n || !Dt(a) && !0 !== a ? i.startOf(o, n) : i.startOf(o, "isoWeek", a)), +o)
  }

  function fa(e, i, s, n) {
    const a = ha.length;
    for (let t = ha.indexOf(e); t < a - 1; ++t) {
      const e = da[ha[t]],
        a = e.steps || Number.MAX_SAFE_INTEGER;
      if (e.common && Math.ceil((s - i) / (a * e.size)) <= n) return ha[t]
    }
    return ha[a - 1]
  }

  function ma(t, e, i) {
    var s, n;
    i ? i.length && ({
      lo: s,
      hi: n
    } = Zt(i, e), t[i[s] >= e ? i[s] : i[n]] = !0) : t[e] = !0
  }

  function ga(t, e, i) {
    const s = [],
      n = {},
      a = e.length;
    let o, r;
    for (o = 0; o < a; ++o) r = e[o], n[r] = o, s.push({
      value: r,
      major: !1
    });
    return 0 !== a && i ? function (t, e, i, s) {
      const n = t._adapter,
        a = +n.startOf(e[0].value, s),
        o = e[e.length - 1].value;
      let r, l;
      for (r = a; r <= o; r = +n.add(r, 1, s)) 0 <= (l = i[r]) && (e[l].major = !0);
      return e
    }(t, s, n, i) : s
  }
  class va extends Hi {
    constructor(t) {
      super(t), this._cache = {
        data: [],
        labels: [],
        all: []
      }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0
    }
    init(t, e) {
      const i = t.time || (t.time = {}),
        s = this._adapter = new Bs._date(t.adapters.date);
      et(i.displayFormats, s.formats()), this._parseOpts = {
        parser: i.parser,
        round: i.round,
        isoWeekday: i.isoWeekday
      }, super.init(t), this._normalized = e.normalized
    }
    parse(t, e) {
      return void 0 === t ? null : pa(this, t)
    }
    beforeLayout() {
      super.beforeLayout(), this._cache = {
        data: [],
        labels: [],
        all: []
      }
    }
    determineDataLimits() {
      const t = this.options,
        e = this._adapter,
        i = t.time.unit || "day";
      let {
        min: s,
        max: n,
        minDefined: a,
        maxDefined: o
      } = this.getUserBounds();

      function r(t) {
        a || isNaN(t.min) || (s = Math.min(s, t.min)), o || isNaN(t.max) || (n = Math.max(n, t.max))
      }
      a && o || (r(this._getLabelBounds()), "ticks" === t.bounds && "labels" === t.ticks.source || r(this.getMinMax(!1))), s = W(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = W(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n)
    }
    _getLabelBounds() {
      var t = this.getLabelTimestamps();
      let e = Number.POSITIVE_INFINITY,
        i = Number.NEGATIVE_INFINITY;
      return t.length && (e = t[0], i = t[t.length - 1]), {
        min: e,
        max: i
      }
    }
    buildTicks() {
      var t = this,
        e = t.options,
        i = e.time,
        s = e.ticks,
        n = "labels" === s.source ? t.getLabelTimestamps() : t._generate();
      "ticks" === e.bounds && n.length && (t.min = t._userMin || n[0], t.max = t._userMax || n[n.length - 1]);
      const a = t.min,
        o = ie(n, a, t.max);
      return t._unit = i.unit || (s.autoSkip ? fa(i.minUnit, t.min, t.max, t._getLabelCapacity(a)) : function (e, i, s, n, a) {
        for (let t = ha.length - 1; t >= ha.indexOf(s); t--) {
          const s = ha[t];
          if (da[s].common && e._adapter.diff(a, n, s) >= i - 1) return s
        }
        return ha[s ? ha.indexOf(s) : 0]
      }(t, o.length, i.minUnit, t.min, t.max)), t._majorUnit = s.major.enabled && "year" !== t._unit ? function (i) {
        for (let t = ha.indexOf(i) + 1, e = ha.length; t < e; ++t)
          if (da[ha[t]].common) return ha[t]
      }(t._unit) : void 0, t.initOffsets(n), e.reverse && o.reverse(), ga(t, o, t._majorUnit)
    }
    initOffsets(t) {
      let e, i, s = 0,
        n = 0;
      this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);
      t = t.length < 3 ? .5 : .25;
      s = Ft(s, 0, t), n = Ft(n, 0, t), this._offsets = {
        start: s,
        end: n,
        factor: 1 / (s + 1 + n)
      }
    }
    _generate() {
      const t = this._adapter,
        e = this.min,
        i = this.max,
        s = this.options,
        n = s.time,
        a = n.unit || fa(n.minUnit, e, i, this._getLabelCapacity(e)),
        o = q(n.stepSize, 1),
        r = "week" === a && n.isoWeekday,
        l = Dt(r) || !0 === r,
        c = {};
      let d, h, u = e;
      if (l && (u = +t.startOf(u, "isoWeek", r)), u = +t.startOf(u, l ? "day" : a), t.diff(i, e, a) > 1e5 * o) throw new Error(e + " and " + i + " are too far apart with stepSize of " + o + " " + a);
      var p = "data" === s.ticks.source && this.getDataTimestamps();
      for (d = u, h = 0; d < i; d = +t.add(d, o, a), h++) ma(c, d, p);
      return d !== i && "ticks" !== s.bounds && 1 !== h || ma(c, d, p), Object.keys(c).sort((t, e) => t - e).map(t => +t)
    }
    getLabelForValue(t) {
      const e = this._adapter,
        i = this.options.time;
      return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime)
    }
    _tickFormatFunction(t, e, i, s) {
      var n = this.options,
        a = n.time.displayFormats,
        o = this._unit,
        r = this._majorUnit,
        l = o && a[o],
        o = r && a[r],
        a = i[e],
        a = r && o && a && a.major,
        l = this._adapter.format(t, s || (a ? o : l)),
        n = n.ticks.callback;
      return n ? X(n, [l, e, i], this) : l
    }
    generateTickLabels(t) {
      let e, i, s;
      for (e = 0, i = t.length; e < i; ++e) s = t[e], s.label = this._tickFormatFunction(s.value, e, t)
    }
    getDecimalForValue(t) {
      return null === t ? NaN : (t - this.min) / (this.max - this.min)
    }
    getPixelForValue(t) {
      var e = this._offsets,
        t = this.getDecimalForValue(t);
      return this.getPixelForDecimal((e.start + t) * e.factor)
    }
    getValueForPixel(t) {
      var e = this._offsets,
        e = this.getDecimalForPixel(t) / e.factor - e.end;
      return this.min + e * (this.max - this.min)
    }
    _getLabelSize(t) {
      var e = this.options.ticks,
        i = this.ctx.measureText(t).width,
        s = At(this.isHorizontal() ? e.maxRotation : e.minRotation),
        t = Math.cos(s),
        e = Math.sin(s),
        s = this._resolveTickFontOptions(0).size;
      return {
        w: i * t + s * e,
        h: i * e + s * t
      }
    }
    _getLabelCapacity(t) {
      var e = this.options.time,
        i = e.displayFormats,
        i = i[e.unit] || i.millisecond,
        i = this._tickFormatFunction(t, 0, ga(this, [t], this._majorUnit), i),
        i = this._getLabelSize(i),
        i = Math.floor(this.isHorizontal() ? this.width / i.w : this.height / i.h) - 1;
      return 0 < i ? i : 1
    }
    getDataTimestamps() {
      let t, e, i = this._cache.data || [];
      if (i.length) return i;
      const s = this.getMatchingVisibleMetas();
      if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);
      for (t = 0, e = s.length; t < e; ++t) i = i.concat(s[t].controller.getAllParsedValues(this));
      return this._cache.data = this.normalize(i)
    }
    getLabelTimestamps() {
      const t = this._cache.labels || [];
      let e, i;
      if (t.length) return t;
      var s = this.getLabels();
      for (e = 0, i = s.length; e < i; ++e) t.push(pa(this, s[e]));
      return this._cache.labels = this._normalized ? t : this.normalize(t)
    }
    normalize(t) {
      return oe(t.sort(ua))
    }
  }

  function ba(t, e, i) {
    let s, n, a, o;
    if (i) s = Math.floor(e), n = Math.ceil(e), a = t[s], o = t[n];
    else {
      const i = Zt(t, e);
      a = i.lo, o = i.hi, s = t[a], n = t[o]
    }
    t = n - s;
    return t ? a + (o - a) * (e - s) / t : a
  }
  va.id = "time", va.defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      major: {
        enabled: !1
      }
    }
  };
  class _a extends va {
    constructor(t) {
      super(t), this._table = [], this._maxIndex = void 0
    }
    initOffsets() {
      var t = this._getTimestampsForTable();
      this._table = this.buildLookupTable(t), this._maxIndex = this._table.length - 1, super.initOffsets(t)
    }
    buildLookupTable(t) {
      var {
        min: e,
        max: i
      } = this;
      if (!t.length) return [{
        time: e,
        pos: 0
      }, {
        time: i,
        pos: 1
      }];
      const s = [e];
      let n, a, o;
      for (n = 0, a = t.length; n < a; ++n) e < (o = t[n]) && o < i && s.push(o);
      return s.push(i), s
    }
    _getTimestampsForTable() {
      let t = this._cache.all || [];
      if (t.length) return t;
      const e = this.getDataTimestamps(),
        i = this.getLabelTimestamps();
      return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t
    }
    getPixelForValue(t, e) {
      var i = this._offsets,
        t = this._normalized && 0 < this._maxIndex && !R(e) ? e / this._maxIndex : this.getDecimalForValue(t);
      return this.getPixelForDecimal((i.start + t) * i.factor)
    }
    getDecimalForValue(t) {
      return ba(this._table, t) / this._maxIndex
    }
    getValueForPixel(t) {
      var e = this._offsets,
        e = this.getDecimalForPixel(t) / e.factor - e.end;
      return ba(this._table, e * this._maxIndex, !0)
    }
  }
  _a.id = "timeseries", _a.defaults = va.defaults;
  ve = Object.freeze({
    __proto__: null,
    CategoryScale: ta,
    LinearScale: ia,
    LogarithmicScale: na,
    RadialLinearScale: ca,
    TimeScale: va,
    TimeSeriesScale: _a
  });
  return Hs.register(Zs, ve, kn, Wn), Hs.helpers = {
    ...fs
  }, Hs._adapters = Bs, Hs.Animation = ui, Hs.Animations = fi, Hs.animator = c, Hs.controllers = gs.controllers.items, Hs.DatasetController = Ti, Hs.Element = Di, Hs.elements = kn, Hs.Interaction = ke, Hs.layouts = Ve, Hs.platforms = ai, Hs.Scale = Hi, Hs.Ticks = Ai, Object.assign(Hs, Zs, ve, kn, Wn, ai), Hs.Chart = Hs, "undefined" != typeof window && (window.Chart = Hs), Hs
}), dataset1 = {
  labels: ["01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10"],
  datasets: [{
    label: "",
    fill: !0,
    data: [9850, 9750, 9550, 9650, 9700, 9750, 9750],
    backgroundColor: ["rgba(0, 171, 78, 0.1)"],
    borderColor: ["#00AB4E"],
    borderWidth: 1,
    pointRadius: 0,
    pointHoverRadius: 5,
    pointBackgroundColor: ["#00AB4E"],
    pointBorderColor: ["#fff"]
  }]
}, dataset2 = {
  labels: ["01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10", "08/10", "09/10", "10/10", "11/10", "12/09", "13/09", "14/10", "15/10", "16/10", "17/10", "18/10", "19/10", "20/10", "21/10", "22/10", "23/10", "24/10"],
  datasets: [{
    label: "",
    fill: !0,
    data: [9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670],
    backgroundColor: ["rgba(0, 171, 78, 0.1)"],
    borderColor: ["#00AB4E"],
    borderWidth: 1,
    pointRadius: 0,
    pointHoverRadius: 5,
    pointBackgroundColor: ["#00AB4E"],
    pointBorderColor: ["#fff"]
  }]
}, dataset3 = {
  labels: ["01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10", "08/10", "09/10", "10/10", "11/10", "12/09", "13/09", "14/10", "15/10", "16/10", "17/10", "18/10", "19/10", "20/10", "21/10", "22/10", "23/10", "24/10", "01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10", "08/10", "09/10", "10/10", "11/10", "12/09", "13/09", "14/10", "15/10", "16/10", "17/10", "18/10", "19/10", "20/10", "21/10", "22/10", "23/10", "24/10"],
  datasets: [{
    label: "",
    fill: !0,
    data: [9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670],
    backgroundColor: ["rgba(0, 171, 78, 0.1)"],
    borderColor: ["#00AB4E"],
    borderWidth: 1,
    pointRadius: 0,
    pointHoverRadius: 5,
    pointBackgroundColor: ["#00AB4E"],
    pointBorderColor: ["#fff"]
  }]
}, dataset4 = {
  labels: ["01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10", "08/10", "09/10", "10/10", "11/10", "01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10", "08/10", "09/10", "10/10", "11/10", "12/09", "13/09", "14/10", "15/10", "16/10", "17/10", "18/10", "19/10", "20/10", "21/10", "22/10", "23/10", "24/10", "01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10", "08/10", "09/10", "10/10", "11/10", "12/09", "13/09", "14/10", "15/10", "16/10", "17/10", "18/10", "19/10", "20/10", "21/10", "22/10", "23/10", "24/10", "01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10", "08/10", "09/10", "10/10", "11/10", "12/09", "13/09", "14/10", "15/10", "16/10", "17/10", "18/10", "19/10", "20/10", "21/10", "22/10", "23/10", "24/10", "01/09", "02/09", "03/10", "04/10", "05/10", "06/10", "07/10", "08/10", "09/10", "10/10", "11/10", "12/09", "13/09", "14/10", "15/10", "16/10", "17/10", "18/10", "19/10", "20/10", "21/10", "22/10", "23/10", "24/10"],
  datasets: [{
    label: "",
    fill: !0,
    data: [9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9700, 9720, 9780, 9750, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670, 9850, 9750, 9550, 9650, 9700, 9750, 9650, 9670],
    backgroundColor: ["rgba(0, 171, 78, 0.1)"],
    borderColor: ["#00AB4E"],
    borderWidth: 1,
    pointRadius: 0,
    pointHoverRadius: 5,
    pointBackgroundColor: ["#00AB4E"],
    pointBorderColor: ["#fff"]
  }]
}, config = {
  type: "line",
  data: dataset1,
  options: {
    plugins: {
      legend: {
        display: !1
      },
      tooltip: {
        backgroundColor: "rgba(255,255,255)",
        bodyColor: "#58585B",
        titleColor: "#58585B",
        borderColor: "#bbbdc0",
        borderWidth: 1,
        titleFont: {
          family: "NunitoSans-Regular",
          size: 10
        },
        bodyFont: {
          family: "NunitoSans-ExtraBold",
          size: 14
        },
        displayColors: !1,
        callbacks: {
          title: function (t) {
            let e = t[0].label,
              i = e.split("/");
            return i[1] = "Okt", i.push("2020"), i.join(" ")
          },
          label: function (t) {
            let e = t.parsed.y;
            return "Rp " + e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".")
          },
          labelTextColor: function (t) {
            return "rgba(37, 37, 40, 1)"
          }
        }
      }
    },
    scales: {
      y: {
        beginAtZero: !1
      },
      x: {
        grid: {
          color: "rgba(255, 255, 255, 0)"
        }
      }
    }
  }
}, config2 = {
  type: "line",
  data: dataset2,
  options: {
    plugins: {
      legend: {
        display: !1
      },
      tooltip: {
        backgroundColor: "rgba(255,255,255)",
        bodyColor: "#58585B",
        titleColor: "#58585B",
        borderColor: "#bbbdc0",
        borderWidth: 1,
        titleFont: {
          family: "NunitoSans-Regular",
          size: 10
        },
        bodyFont: {
          family: "NunitoSans-ExtraBold",
          size: 14
        },
        displayColors: !1,
        callbacks: {
          title: function (t) {
            let e = t[0].label,
              i = e.split("/");
            return i[1] = "Okt", i.push("2020"), i.join(" ")
          },
          label: function (t) {
            let e = t.parsed.y;
            return "Rp " + e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".")
          },
          labelTextColor: function (t) {
            return "rgba(37, 37, 40, 1)"
          }
        }
      }
    },
    scales: {
      y: {
        beginAtZero: !1
      },
      x: {
        grid: {
          color: "rgba(255, 255, 255, 0)"
        }
      }
    }
  }
}, config3 = {
  type: "line",
  data: dataset3,
  options: {
    plugins: {
      legend: {
        display: !1
      },
      tooltip: {
        backgroundColor: "rgba(255,255,255)",
        bodyColor: "#58585B",
        titleColor: "#58585B",
        borderColor: "#bbbdc0",
        borderWidth: 1,
        titleFont: {
          family: "NunitoSans-Regular",
          size: 10
        },
        bodyFont: {
          family: "NunitoSans-ExtraBold",
          size: 14
        },
        displayColors: !1,
        callbacks: {
          title: function (t) {
            let e = t[0].label,
              i = e.split("/");
            return i[1] = "Okt", i.push("2020"), i.join(" ")
          },
          label: function (t) {
            let e = t.parsed.y;
            return "Rp " + e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".")
          },
          labelTextColor: function (t) {
            return "rgba(37, 37, 40, 1)"
          }
        }
      }
    },
    scales: {
      y: {
        beginAtZero: !1
      },
      x: {
        grid: {
          color: "rgba(255, 255, 255, 0)"
        }
      }
    }
  }
}, config4 = {
  type: "line",
  data: dataset4,
  options: {
    plugins: {
      legend: {
        display: !1
      },
      tooltip: {
        backgroundColor: "rgba(255,255,255)",
        bodyColor: "#58585B",
        titleColor: "#58585B",
        borderColor: "#bbbdc0",
        borderWidth: 1,
        titleFont: {
          family: "NunitoSans-Regular",
          size: 10
        },
        bodyFont: {
          family: "NunitoSans-ExtraBold",
          size: 14
        },
        displayColors: !1,
        callbacks: {
          title: function (t) {
            let e = t[0].label,
              i = e.split("/");
            return i[1] = "Okt", i.push("2020"), i.join(" ")
          },
          label: function (t) {
            let e = t.parsed.y;
            return "Rp " + e.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ".")
          },
          labelTextColor: function (t) {
            return "rgba(37, 37, 40, 1)"
          }
        }
      }
    },
    scales: {
      y: {
        beginAtZero: !1
      },
      x: {
        grid: {
          color: "rgba(255, 255, 255, 0)"
        }
      }
    }
  }
};
let ctxEmas2 = document.getElementById("chart-beli"),
  ctxEmas3 = document.getElementById("chart-jual"),
  grafikEmas2 = new Chart(ctxEmas2, config),
  grafikEmas3;

function changeChart(t) {
  $(".grafik-box-top__tab").removeClass("tab-active"), "beli" == t ? (grafikEmas3.destroy(), grafikEmas2 = new Chart(ctxEmas2, config), $("#grafik-beli .grafik-box-top__tab").first().addClass("tab-active")) : "jual" == t && (grafikEmas2.destroy(), grafikEmas3 = new Chart(ctxEmas3, config), $("#grafik-jual .grafik-box-top__tab").first().addClass("tab-active"))
}
$(".tab-box-category").on("click", function () {
  $(".tab-box-category").removeClass("active"), $(this).addClass(" active")
}), $(".grafik-box-top__tab").on("click", function () {
  $(".grafik-box-top__tab").removeClass("tab-active"), $(this).addClass(" tab-active")
}), configMeter = {
  type: "bar",
  data: {
    labels: ["", "", "", "", "", "", "", "", "", "", "", "", ""],
    datasets: [{
      axis: "y",
      data: [4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44],
      backgroundColor: ["#00AB4E"],
      barThickness: 4,
      barPercentage: 9,
      categoryPercentage: 1
    }]
  },
  options: {
    plugins: {
      legend: {
        display: !1
      }
    },
    responsive: !0,
    indexAxis: "y",
    scales: {
      y: {
        beginAtZero: !0,
        grid: {
          display: !1,
          drawBorder: !1,
          lineWidth: 0
        }
      },
      x: {
        grid: {
          display: !1,
          drawBorder: !1,
          lineWidth: 0
        },
        ticks: {
          display: !1
        }
      }
    }
  }
};
let graphicChartMeter = Chart.getChart("chartMeter");
null != graphicChartMeter && graphicChartMeter.destroy();
let chartCanvas = $("#chartMeter"),
  chartInstance = new Chart(chartCanvas, configMeter);
! function (t) {
  "use strict";
  "function" == typeof define && define.amd ? define(["jquery"], t) : "undefined" != typeof exports ? module.exports = t(require("jquery")) : t(jQuery)
}(function (c) {
  "use strict";
  var s, a = window.Slick || {};
  s = 0, (a = function (t, e) {
    var i = this;
    i.defaults = {
      accessibility: !0,
      adaptiveHeight: !1,
      appendArrows: c(t),
      appendDots: c(t),
      arrows: !0,
      asNavFor: null,
      prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
      nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
      autoplay: !1,
      autoplaySpeed: 3e3,
      centerMode: !1,
      centerPadding: "50px",
      cssEase: "ease",
      customPaging: function (t, e) {
        return c('<button type="button" />').text(e + 1)
      },
      dots: !1,
      dotsClass: "slick-dots",
      draggable: !0,
      easing: "linear",
      edgeFriction: .35,
      fade: !1,
      focusOnSelect: !1,
      focusOnChange: !1,
      infinite: !0,
      initialSlide: 0,
      lazyLoad: "ondemand",
      mobileFirst: !1,
      pauseOnHover: !0,
      pauseOnFocus: !0,
      pauseOnDotsHover: !1,
      respondTo: "window",
      responsive: null,
      rows: 1,
      rtl: !1,
      slide: "",
      slidesPerRow: 1,
      slidesToShow: 1,
      slidesToScroll: 1,
      speed: 500,
      swipe: !0,
      swipeToSlide: !1,
      touchMove: !0,
      touchThreshold: 5,
      useCSS: !0,
      useTransform: !0,
      variableWidth: !1,
      vertical: !1,
      verticalSwiping: !1,
      waitForAnimate: !0,
      zIndex: 1e3
    }, i.initials = {
      animating: !1,
      dragging: !1,
      autoPlayTimer: null,
      currentDirection: 0,
      currentLeft: null,
      currentSlide: 0,
      direction: 1,
      $dots: null,
      listWidth: null,
      listHeight: null,
      loadIndex: 0,
      $nextArrow: null,
      $prevArrow: null,
      scrolling: !1,
      slideCount: null,
      slideWidth: null,
      $slideTrack: null,
      $slides: null,
      sliding: !1,
      slideOffset: 0,
      swipeLeft: null,
      swiping: !1,
      $list: null,
      touchObject: {},
      transformsEnabled: !1,
      unslicked: !1
    }, c.extend(i, i.initials), i.activeBreakpoint = null, i.animType = null, i.animProp = null, i.breakpoints = [], i.breakpointSettings = [], i.cssTransitions = !1, i.focussed = !1, i.interrupted = !1, i.hidden = "hidden", i.paused = !0, i.positionProp = null, i.respondTo = null, i.rowCount = 1, i.shouldClick = !0, i.$slider = c(t), i.$slidesCache = null, i.transformType = null, i.transitionType = null, i.visibilityChange = "visibilitychange", i.windowWidth = 0, i.windowTimer = null, t = c(t).data("slick") || {}, i.options = c.extend({}, i.defaults, e, t), i.currentSlide = i.options.initialSlide, i.originalSettings = i.options, void 0 !== document.mozHidden ? (i.hidden = "mozHidden", i.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (i.hidden = "webkitHidden", i.visibilityChange = "webkitvisibilitychange"), i.autoPlay = c.proxy(i.autoPlay, i), i.autoPlayClear = c.proxy(i.autoPlayClear, i), i.autoPlayIterator = c.proxy(i.autoPlayIterator, i), i.changeSlide = c.proxy(i.changeSlide, i), i.clickHandler = c.proxy(i.clickHandler, i), i.selectHandler = c.proxy(i.selectHandler, i), i.setPosition = c.proxy(i.setPosition, i), i.swipeHandler = c.proxy(i.swipeHandler, i), i.dragHandler = c.proxy(i.dragHandler, i), i.keyHandler = c.proxy(i.keyHandler, i), i.instanceUid = s++, i.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, i.registerBreakpoints(), i.init(!0)
  }).prototype.activateADA = function () {
    this.$slideTrack.find(".slick-active").attr({
      "aria-hidden": "false"
    }).find("a, input, button, select").attr({
      tabindex: "0"
    })
  }, a.prototype.addSlide = a.prototype.slickAdd = function (t, e, i) {
    var s = this;
    if ("boolean" == typeof e) i = e, e = null;
    else if (e < 0 || e >= s.slideCount) return !1;
    s.unload(), "number" == typeof e ? 0 === e && 0 === s.$slides.length ? c(t).appendTo(s.$slideTrack) : i ? c(t).insertBefore(s.$slides.eq(e)) : c(t).insertAfter(s.$slides.eq(e)) : !0 === i ? c(t).prependTo(s.$slideTrack) : c(t).appendTo(s.$slideTrack), s.$slides = s.$slideTrack.children(this.options.slide), s.$slideTrack.children(this.options.slide).detach(), s.$slideTrack.append(s.$slides), s.$slides.each(function (t, e) {
      c(e).attr("data-slick-index", t)
    }), s.$slidesCache = s.$slides, s.reinit()
  }, a.prototype.animateHeight = function () {
    var t;
    1 === this.options.slidesToShow && !0 === this.options.adaptiveHeight && !1 === this.options.vertical && (t = this.$slides.eq(this.currentSlide).outerHeight(!0), this.$list.animate({
      height: t
    }, this.options.speed))
  }, a.prototype.animateSlide = function (t, e) {
    var i = {},
      s = this;
    s.animateHeight(), !0 === s.options.rtl && !1 === s.options.vertical && (t = -t), !1 === s.transformsEnabled ? !1 === s.options.vertical ? s.$slideTrack.animate({
      left: t
    }, s.options.speed, s.options.easing, e) : s.$slideTrack.animate({
      top: t
    }, s.options.speed, s.options.easing, e) : !1 === s.cssTransitions ? (!0 === s.options.rtl && (s.currentLeft = -s.currentLeft), c({
      animStart: s.currentLeft
    }).animate({
      animStart: t
    }, {
      duration: s.options.speed,
      easing: s.options.easing,
      step: function (t) {
        t = Math.ceil(t), !1 === s.options.vertical ? i[s.animType] = "translate(" + t + "px, 0px)" : i[s.animType] = "translate(0px," + t + "px)", s.$slideTrack.css(i)
      },
      complete: function () {
        e && e.call()
      }
    })) : (s.applyTransition(), t = Math.ceil(t), !1 === s.options.vertical ? i[s.animType] = "translate3d(" + t + "px, 0px, 0px)" : i[s.animType] = "translate3d(0px," + t + "px, 0px)", s.$slideTrack.css(i), e && setTimeout(function () {
      s.disableTransition(), e.call()
    }, s.options.speed))
  }, a.prototype.getNavTarget = function () {
    var t = this.options.asNavFor;
    return t = t && null !== t ? c(t).not(this.$slider) : t
  }, a.prototype.asNavFor = function (e) {
    var t = this.getNavTarget();
    null !== t && "object" == typeof t && t.each(function () {
      var t = c(this).slick("getSlick");
      t.unslicked || t.slideHandler(e, !0)
    })
  }, a.prototype.applyTransition = function (t) {
    var e = this,
      i = {};
    !1 === e.options.fade ? i[e.transitionType] = e.transformType + " " + e.options.speed + "ms " + e.options.cssEase : i[e.transitionType] = "opacity " + e.options.speed + "ms " + e.options.cssEase, (!1 === e.options.fade ? e.$slideTrack : e.$slides.eq(t)).css(i)
  }, a.prototype.autoPlay = function () {
    this.autoPlayClear(), this.slideCount > this.options.slidesToShow && (this.autoPlayTimer = setInterval(this.autoPlayIterator, this.options.autoplaySpeed))
  }, a.prototype.autoPlayClear = function () {
    this.autoPlayTimer && clearInterval(this.autoPlayTimer)
  }, a.prototype.autoPlayIterator = function () {
    var t = this,
      e = t.currentSlide + t.options.slidesToScroll;
    t.paused || t.interrupted || t.focussed || (!1 === t.options.infinite && (1 === t.direction && t.currentSlide + 1 === t.slideCount - 1 ? t.direction = 0 : 0 === t.direction && (e = t.currentSlide - t.options.slidesToScroll, t.currentSlide - 1 == 0 && (t.direction = 1))), t.slideHandler(e))
  }, a.prototype.buildArrows = function () {
    var t = this;
    !0 === t.options.arrows && (t.$prevArrow = c(t.options.prevArrow).addClass("slick-arrow"), t.$nextArrow = c(t.options.nextArrow).addClass("slick-arrow"), t.slideCount > t.options.slidesToShow ? (t.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), t.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.prependTo(t.options.appendArrows), t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.appendTo(t.options.appendArrows), !0 !== t.options.infinite && t.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : t.$prevArrow.add(t.$nextArrow).addClass("slick-hidden").attr({
      "aria-disabled": "true",
      tabindex: "-1"
    }))
  }, a.prototype.buildDots = function () {
    var t, e, i = this;
    if (!0 === i.options.dots && i.slideCount > i.options.slidesToShow) {
      for (i.$slider.addClass("slick-dotted"), e = c("<ul />").addClass(i.options.dotsClass), t = 0; t <= i.getDotCount(); t += 1) e.append(c("<li />").append(i.options.customPaging.call(this, i, t)));
      i.$dots = e.appendTo(i.options.appendDots), i.$dots.find("li").first().addClass("slick-active")
    }
  }, a.prototype.buildOut = function () {
    var t = this;
    t.$slides = t.$slider.children(t.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), t.slideCount = t.$slides.length, t.$slides.each(function (t, e) {
      c(e).attr("data-slick-index", t).data("originalStyling", c(e).attr("style") || "")
    }), t.$slider.addClass("slick-slider"), t.$slideTrack = 0 === t.slideCount ? c('<div class="slick-track"/>').appendTo(t.$slider) : t.$slides.wrapAll('<div class="slick-track"/>').parent(), t.$list = t.$slideTrack.wrap('<div class="slick-list"/>').parent(), t.$slideTrack.css("opacity", 0), !0 !== t.options.centerMode && !0 !== t.options.swipeToSlide || (t.options.slidesToScroll = 1), c("img[data-lazy]", t.$slider).not("[src]").addClass("slick-loading"), t.setupInfinite(), t.buildArrows(), t.buildDots(), t.updateDots(), t.setSlideClasses("number" == typeof t.currentSlide ? t.currentSlide : 0), !0 === t.options.draggable && t.$list.addClass("draggable")
  }, a.prototype.buildRows = function () {
    var t, e, i, s = this,
      n = document.createDocumentFragment(),
      a = s.$slider.children();
    if (0 < s.options.rows) {
      for (i = s.options.slidesPerRow * s.options.rows, e = Math.ceil(a.length / i), t = 0; t < e; t++) {
        for (var o = document.createElement("div"), r = 0; r < s.options.rows; r++) {
          for (var l = document.createElement("div"), c = 0; c < s.options.slidesPerRow; c++) {
            var d = t * i + (r * s.options.slidesPerRow + c);
            a.get(d) && l.appendChild(a.get(d))
          }
          o.appendChild(l)
        }
        n.appendChild(o)
      }
      s.$slider.empty().append(n), s.$slider.children().children().children().css({
        width: 100 / s.options.slidesPerRow + "%",
        display: "inline-block"
      })
    }
  }, a.prototype.checkResponsive = function (t, e) {
    var i, s, n, a = this,
      o = !1,
      r = a.$slider.width(),
      l = window.innerWidth || c(window).width();
    if ("window" === a.respondTo ? n = l : "slider" === a.respondTo ? n = r : "min" === a.respondTo && (n = Math.min(l, r)), a.options.responsive && a.options.responsive.length && null !== a.options.responsive) {
      for (i in s = null, a.breakpoints) a.breakpoints.hasOwnProperty(i) && (!1 === a.originalSettings.mobileFirst ? n < a.breakpoints[i] && (s = a.breakpoints[i]) : n > a.breakpoints[i] && (s = a.breakpoints[i]));
      null !== s ? null !== a.activeBreakpoint && s === a.activeBreakpoint && !e || (a.activeBreakpoint = s, "unslick" === a.breakpointSettings[s] ? a.unslick(s) : (a.options = c.extend({}, a.originalSettings, a.breakpointSettings[s]), !0 === t && (a.currentSlide = a.options.initialSlide), a.refresh(t)), o = s) : null !== a.activeBreakpoint && (a.activeBreakpoint = null, a.options = a.originalSettings, !0 === t && (a.currentSlide = a.options.initialSlide), a.refresh(t), o = s), t || !1 === o || a.$slider.trigger("breakpoint", [a, o])
    }
  }, a.prototype.changeSlide = function (t, e) {
    var i, s = this,
      n = c(t.currentTarget);
    switch (n.is("a") && t.preventDefault(), n.is("li") || (n = n.closest("li")), i = s.slideCount % s.options.slidesToScroll != 0 ? 0 : (s.slideCount - s.currentSlide) % s.options.slidesToScroll, t.data.message) {
      case "previous":
        a = 0 == i ? s.options.slidesToScroll : s.options.slidesToShow - i, s.slideCount > s.options.slidesToShow && s.slideHandler(s.currentSlide - a, !1, e);
        break;
      case "next":
        a = 0 == i ? s.options.slidesToScroll : i, s.slideCount > s.options.slidesToShow && s.slideHandler(s.currentSlide + a, !1, e);
        break;
      case "index":
        var a = 0 === t.data.index ? 0 : t.data.index || n.index() * s.options.slidesToScroll;
        s.slideHandler(s.checkNavigable(a), !1, e), n.children().trigger("focus");
        break;
      default:
        return
    }
  }, a.prototype.checkNavigable = function (t) {
    var e = this.getNavigableIndexes(),
      i = 0;
    if (t > e[e.length - 1]) t = e[e.length - 1];
    else
      for (var s in e) {
        if (t < e[s]) {
          t = i;
          break
        }
        i = e[s]
      }
    return t
  }, a.prototype.cleanUpEvents = function () {
    var t = this;
    t.options.dots && null !== t.$dots && (c("li", t.$dots).off("click.slick", t.changeSlide).off("mouseenter.slick", c.proxy(t.interrupt, t, !0)).off("mouseleave.slick", c.proxy(t.interrupt, t, !1)), !0 === t.options.accessibility && t.$dots.off("keydown.slick", t.keyHandler)), t.$slider.off("focus.slick blur.slick"), !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && (t.$prevArrow && t.$prevArrow.off("click.slick", t.changeSlide), t.$nextArrow && t.$nextArrow.off("click.slick", t.changeSlide), !0 === t.options.accessibility && (t.$prevArrow && t.$prevArrow.off("keydown.slick", t.keyHandler), t.$nextArrow && t.$nextArrow.off("keydown.slick", t.keyHandler))), t.$list.off("touchstart.slick mousedown.slick", t.swipeHandler), t.$list.off("touchmove.slick mousemove.slick", t.swipeHandler), t.$list.off("touchend.slick mouseup.slick", t.swipeHandler), t.$list.off("touchcancel.slick mouseleave.slick", t.swipeHandler), t.$list.off("click.slick", t.clickHandler), c(document).off(t.visibilityChange, t.visibility), t.cleanUpSlideEvents(), !0 === t.options.accessibility && t.$list.off("keydown.slick", t.keyHandler), !0 === t.options.focusOnSelect && c(t.$slideTrack).children().off("click.slick", t.selectHandler), c(window).off("orientationchange.slick.slick-" + t.instanceUid, t.orientationChange), c(window).off("resize.slick.slick-" + t.instanceUid, t.resize), c("[draggable!=true]", t.$slideTrack).off("dragstart", t.preventDefault), c(window).off("load.slick.slick-" + t.instanceUid, t.setPosition)
  }, a.prototype.cleanUpSlideEvents = function () {
    this.$list.off("mouseenter.slick", c.proxy(this.interrupt, this, !0)), this.$list.off("mouseleave.slick", c.proxy(this.interrupt, this, !1))
  }, a.prototype.cleanUpRows = function () {
    var t;
    0 < this.options.rows && ((t = this.$slides.children().children()).removeAttr("style"), this.$slider.empty().append(t))
  }, a.prototype.clickHandler = function (t) {
    !1 === this.shouldClick && (t.stopImmediatePropagation(), t.stopPropagation(), t.preventDefault())
  }, a.prototype.destroy = function (t) {
    var e = this;
    e.autoPlayClear(), e.touchObject = {}, e.cleanUpEvents(), c(".slick-cloned", e.$slider).detach(), e.$dots && e.$dots.remove(), e.$prevArrow && e.$prevArrow.length && (e.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.remove()), e.$nextArrow && e.$nextArrow.length && (e.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.remove()), e.$slides && (e.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {
      c(this).attr("style", c(this).data("originalStyling"))
    }), e.$slideTrack.children(this.options.slide).detach(), e.$slideTrack.detach(), e.$list.detach(), e.$slider.append(e.$slides)), e.cleanUpRows(), e.$slider.removeClass("slick-slider"), e.$slider.removeClass("slick-initialized"), e.$slider.removeClass("slick-dotted"), e.unslicked = !0, t || e.$slider.trigger("destroy", [e])
  }, a.prototype.disableTransition = function (t) {
    var e = {};
    e[this.transitionType] = "", (!1 === this.options.fade ? this.$slideTrack : this.$slides.eq(t)).css(e)
  }, a.prototype.fadeSlide = function (t, e) {
    var i = this;
    !1 === i.cssTransitions ? (i.$slides.eq(t).css({
      zIndex: i.options.zIndex
    }), i.$slides.eq(t).animate({
      opacity: 1
    }, i.options.speed, i.options.easing, e)) : (i.applyTransition(t), i.$slides.eq(t).css({
      opacity: 1,
      zIndex: i.options.zIndex
    }), e && setTimeout(function () {
      i.disableTransition(t), e.call()
    }, i.options.speed))
  }, a.prototype.fadeSlideOut = function (t) {
    !1 === this.cssTransitions ? this.$slides.eq(t).animate({
      opacity: 0,
      zIndex: this.options.zIndex - 2
    }, this.options.speed, this.options.easing) : (this.applyTransition(t), this.$slides.eq(t).css({
      opacity: 0,
      zIndex: this.options.zIndex - 2
    }))
  }, a.prototype.filterSlides = a.prototype.slickFilter = function (t) {
    null !== t && (this.$slidesCache = this.$slides, this.unload(), this.$slideTrack.children(this.options.slide).detach(), this.$slidesCache.filter(t).appendTo(this.$slideTrack), this.reinit())
  }, a.prototype.focusHandler = function () {
    var i = this;
    i.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", function (t) {
      t.stopImmediatePropagation();
      var e = c(this);
      setTimeout(function () {
        i.options.pauseOnFocus && (i.focussed = e.is(":focus"), i.autoPlay())
      }, 0)
    })
  }, a.prototype.getCurrent = a.prototype.slickCurrentSlide = function () {
    return this.currentSlide
  }, a.prototype.getDotCount = function () {
    var t = this,
      e = 0,
      i = 0,
      s = 0;
    if (!0 === t.options.infinite)
      if (t.slideCount <= t.options.slidesToShow) ++s;
      else
        for (; e < t.slideCount;) ++s, e = i + t.options.slidesToScroll, i += t.options.slidesToScroll <= t.options.slidesToShow ? t.options.slidesToScroll : t.options.slidesToShow;
    else if (!0 === t.options.centerMode) s = t.slideCount;
    else if (t.options.asNavFor)
      for (; e < t.slideCount;) ++s, e = i + t.options.slidesToScroll, i += t.options.slidesToScroll <= t.options.slidesToShow ? t.options.slidesToScroll : t.options.slidesToShow;
    else s = 1 + Math.ceil((t.slideCount - t.options.slidesToShow) / t.options.slidesToScroll);
    return s - 1
  }, a.prototype.getLeft = function (t) {
    var e, i, s = this,
      n = 0;
    return s.slideOffset = 0, e = s.$slides.first().outerHeight(!0), !0 === s.options.infinite ? (s.slideCount > s.options.slidesToShow && (s.slideOffset = s.slideWidth * s.options.slidesToShow * -1, i = -1, !0 === s.options.vertical && !0 === s.options.centerMode && (2 === s.options.slidesToShow ? i = -1.5 : 1 === s.options.slidesToShow && (i = -2)), n = e * s.options.slidesToShow * i), s.slideCount % s.options.slidesToScroll != 0 && t + s.options.slidesToScroll > s.slideCount && s.slideCount > s.options.slidesToShow && (n = t > s.slideCount ? (s.slideOffset = (s.options.slidesToShow - (t - s.slideCount)) * s.slideWidth * -1, (s.options.slidesToShow - (t - s.slideCount)) * e * -1) : (s.slideOffset = s.slideCount % s.options.slidesToScroll * s.slideWidth * -1, s.slideCount % s.options.slidesToScroll * e * -1))) : t + s.options.slidesToShow > s.slideCount && (s.slideOffset = (t + s.options.slidesToShow - s.slideCount) * s.slideWidth, n = (t + s.options.slidesToShow - s.slideCount) * e), s.slideCount <= s.options.slidesToShow && (n = s.slideOffset = 0), !0 === s.options.centerMode && s.slideCount <= s.options.slidesToShow ? s.slideOffset = s.slideWidth * Math.floor(s.options.slidesToShow) / 2 - s.slideWidth * s.slideCount / 2 : !0 === s.options.centerMode && !0 === s.options.infinite ? s.slideOffset += s.slideWidth * Math.floor(s.options.slidesToShow / 2) - s.slideWidth : !0 === s.options.centerMode && (s.slideOffset = 0, s.slideOffset += s.slideWidth * Math.floor(s.options.slidesToShow / 2)), e = !1 === s.options.vertical ? t * s.slideWidth * -1 + s.slideOffset : t * e * -1 + n, !0 === s.options.variableWidth && (n = s.slideCount <= s.options.slidesToShow || !1 === s.options.infinite ? s.$slideTrack.children(".slick-slide").eq(t) : s.$slideTrack.children(".slick-slide").eq(t + s.options.slidesToShow), e = !0 === s.options.rtl ? n[0] ? -1 * (s.$slideTrack.width() - n[0].offsetLeft - n.width()) : 0 : n[0] ? -1 * n[0].offsetLeft : 0, !0 === s.options.centerMode && (n = s.slideCount <= s.options.slidesToShow || !1 === s.options.infinite ? s.$slideTrack.children(".slick-slide").eq(t) : s.$slideTrack.children(".slick-slide").eq(t + s.options.slidesToShow + 1), e = !0 === s.options.rtl ? n[0] ? -1 * (s.$slideTrack.width() - n[0].offsetLeft - n.width()) : 0 : n[0] ? -1 * n[0].offsetLeft : 0, e += (s.$list.width() - n.outerWidth()) / 2)), e
  }, a.prototype.getOption = a.prototype.slickGetOption = function (t) {
    return this.options[t]
  }, a.prototype.getNavigableIndexes = function () {
    for (var t = this, e = 0, i = 0, s = [], n = !1 === t.options.infinite ? t.slideCount : (e = -1 * t.options.slidesToScroll, i = -1 * t.options.slidesToScroll, 2 * t.slideCount); e < n;) s.push(e), e = i + t.options.slidesToScroll, i += t.options.slidesToScroll <= t.options.slidesToShow ? t.options.slidesToScroll : t.options.slidesToShow;
    return s
  }, a.prototype.getSlick = function () {
    return this
  }, a.prototype.getSlideCount = function () {
    var i, s = this,
      n = !0 === s.options.centerMode ? s.slideWidth * Math.floor(s.options.slidesToShow / 2) : 0;
    return !0 === s.options.swipeToSlide ? (s.$slideTrack.find(".slick-slide").each(function (t, e) {
      if (e.offsetLeft - n + c(e).outerWidth() / 2 > -1 * s.swipeLeft) return i = e, !1
    }), Math.abs(c(i).attr("data-slick-index") - s.currentSlide) || 1) : s.options.slidesToScroll
  }, a.prototype.goTo = a.prototype.slickGoTo = function (t, e) {
    this.changeSlide({
      data: {
        message: "index",
        index: parseInt(t)
      }
    }, e)
  }, a.prototype.init = function (t) {
    var e = this;
    c(e.$slider).hasClass("slick-initialized") || (c(e.$slider).addClass("slick-initialized"), e.buildRows(), e.buildOut(), e.setProps(), e.startLoad(), e.loadSlider(), e.initializeEvents(), e.updateArrows(), e.updateDots(), e.checkResponsive(!0), e.focusHandler()), t && e.$slider.trigger("init", [e]), !0 === e.options.accessibility && e.initADA(), e.options.autoplay && (e.paused = !1, e.autoPlay())
  }, a.prototype.initADA = function () {
    var i = this,
      s = Math.ceil(i.slideCount / i.options.slidesToShow),
      n = i.getNavigableIndexes().filter(function (t) {
        return 0 <= t && t < i.slideCount
      });
    i.$slides.add(i.$slideTrack.find(".slick-cloned")).attr({
      "aria-hidden": "true",
      tabindex: "-1"
    }).find("a, input, button, select").attr({
      tabindex: "-1"
    }), null !== i.$dots && (i.$slides.not(i.$slideTrack.find(".slick-cloned")).each(function (t) {
      var e = n.indexOf(t);
      c(this).attr({
        role: "tabpanel",
        id: "slick-slide" + i.instanceUid + t,
        tabindex: -1
      }), -1 !== e && (e = "slick-slide-control" + i.instanceUid + e, c("#" + e).length && c(this).attr({
        "aria-describedby": e
      }))
    }), i.$dots.attr("role", "tablist").find("li").each(function (t) {
      var e = n[t];
      c(this).attr({
        role: "presentation"
      }), c(this).find("button").first().attr({
        role: "tab",
        id: "slick-slide-control" + i.instanceUid + t,
        "aria-controls": "slick-slide" + i.instanceUid + e,
        "aria-label": t + 1 + " of " + s,
        "aria-selected": null,
        tabindex: "-1"
      })
    }).eq(i.currentSlide).find("button").attr({
      "aria-selected": "true",
      tabindex: "0"
    }).end());
    for (var t = i.currentSlide, e = t + i.options.slidesToShow; t < e; t++) i.options.focusOnChange ? i.$slides.eq(t).attr({
      tabindex: "0"
    }) : i.$slides.eq(t).removeAttr("tabindex");
    i.activateADA()
  }, a.prototype.initArrowEvents = function () {
    var t = this;
    !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && (t.$prevArrow.off("click.slick").on("click.slick", {
      message: "previous"
    }, t.changeSlide), t.$nextArrow.off("click.slick").on("click.slick", {
      message: "next"
    }, t.changeSlide), !0 === t.options.accessibility && (t.$prevArrow.on("keydown.slick", t.keyHandler), t.$nextArrow.on("keydown.slick", t.keyHandler)))
  }, a.prototype.initDotEvents = function () {
    var t = this;
    !0 === t.options.dots && t.slideCount > t.options.slidesToShow && (c("li", t.$dots).on("click.slick", {
      message: "index"
    }, t.changeSlide), !0 === t.options.accessibility && t.$dots.on("keydown.slick", t.keyHandler)), !0 === t.options.dots && !0 === t.options.pauseOnDotsHover && t.slideCount > t.options.slidesToShow && c("li", t.$dots).on("mouseenter.slick", c.proxy(t.interrupt, t, !0)).on("mouseleave.slick", c.proxy(t.interrupt, t, !1))
  }, a.prototype.initSlideEvents = function () {
    this.options.pauseOnHover && (this.$list.on("mouseenter.slick", c.proxy(this.interrupt, this, !0)), this.$list.on("mouseleave.slick", c.proxy(this.interrupt, this, !1)))
  }, a.prototype.initializeEvents = function () {
    var t = this;
    t.initArrowEvents(), t.initDotEvents(), t.initSlideEvents(), t.$list.on("touchstart.slick mousedown.slick", {
      action: "start"
    }, t.swipeHandler), t.$list.on("touchmove.slick mousemove.slick", {
      action: "move"
    }, t.swipeHandler), t.$list.on("touchend.slick mouseup.slick", {
      action: "end"
    }, t.swipeHandler), t.$list.on("touchcancel.slick mouseleave.slick", {
      action: "end"
    }, t.swipeHandler), t.$list.on("click.slick", t.clickHandler), c(document).on(t.visibilityChange, c.proxy(t.visibility, t)), !0 === t.options.accessibility && t.$list.on("keydown.slick", t.keyHandler), !0 === t.options.focusOnSelect && c(t.$slideTrack).children().on("click.slick", t.selectHandler), c(window).on("orientationchange.slick.slick-" + t.instanceUid, c.proxy(t.orientationChange, t)), c(window).on("resize.slick.slick-" + t.instanceUid, c.proxy(t.resize, t)), c("[draggable!=true]", t.$slideTrack).on("dragstart", t.preventDefault), c(window).on("load.slick.slick-" + t.instanceUid, t.setPosition), c(t.setPosition)
  }, a.prototype.initUI = function () {
    !0 === this.options.arrows && this.slideCount > this.options.slidesToShow && (this.$prevArrow.show(), this.$nextArrow.show()), !0 === this.options.dots && this.slideCount > this.options.slidesToShow && this.$dots.show()
  }, a.prototype.keyHandler = function (t) {
    t.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === t.keyCode && !0 === this.options.accessibility ? this.changeSlide({
      data: {
        message: !0 === this.options.rtl ? "next" : "previous"
      }
    }) : 39 === t.keyCode && !0 === this.options.accessibility && this.changeSlide({
      data: {
        message: !0 === this.options.rtl ? "previous" : "next"
      }
    }))
  }, a.prototype.lazyLoad = function () {
    var t, e, i, a = this;

    function s(t) {
      c("img[data-lazy]", t).each(function () {
        var t = c(this),
          e = c(this).attr("data-lazy"),
          i = c(this).attr("data-srcset"),
          s = c(this).attr("data-sizes") || a.$slider.attr("data-sizes"),
          n = document.createElement("img");
        n.onload = function () {
          t.animate({
            opacity: 0
          }, 100, function () {
            i && (t.attr("srcset", i), s && t.attr("sizes", s)), t.attr("src", e).animate({
              opacity: 1
            }, 200, function () {
              t.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading")
            }), a.$slider.trigger("lazyLoaded", [a, t, e])
          })
        }, n.onerror = function () {
          t.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), a.$slider.trigger("lazyLoadError", [a, t, e])
        }, n.src = e
      })
    }
    if (!0 === a.options.centerMode ? i = !0 === a.options.infinite ? (e = a.currentSlide + (a.options.slidesToShow / 2 + 1)) + a.options.slidesToShow + 2 : (e = Math.max(0, a.currentSlide - (a.options.slidesToShow / 2 + 1)), a.options.slidesToShow / 2 + 1 + 2 + a.currentSlide) : (e = a.options.infinite ? a.options.slidesToShow + a.currentSlide : a.currentSlide, i = Math.ceil(e + a.options.slidesToShow), !0 === a.options.fade && (0 < e && e--, i <= a.slideCount && i++)), t = a.$slider.find(".slick-slide").slice(e, i), "anticipated" === a.options.lazyLoad)
      for (var n = e - 1, o = i, r = a.$slider.find(".slick-slide"), l = 0; l < a.options.slidesToScroll; l++) n < 0 && (n = a.slideCount - 1), t = (t = t.add(r.eq(n))).add(r.eq(o)), n--, o++;
    s(t), a.slideCount <= a.options.slidesToShow ? s(a.$slider.find(".slick-slide")) : a.currentSlide >= a.slideCount - a.options.slidesToShow ? s(a.$slider.find(".slick-cloned").slice(0, a.options.slidesToShow)) : 0 === a.currentSlide && s(a.$slider.find(".slick-cloned").slice(-1 * a.options.slidesToShow))
  }, a.prototype.loadSlider = function () {
    this.setPosition(), this.$slideTrack.css({
      opacity: 1
    }), this.$slider.removeClass("slick-loading"), this.initUI(), "progressive" === this.options.lazyLoad && this.progressiveLazyLoad()
  }, a.prototype.next = a.prototype.slickNext = function () {
    this.changeSlide({
      data: {
        message: "next"
      }
    })
  }, a.prototype.orientationChange = function () {
    this.checkResponsive(), this.setPosition()
  }, a.prototype.pause = a.prototype.slickPause = function () {
    this.autoPlayClear(), this.paused = !0
  }, a.prototype.play = a.prototype.slickPlay = function () {
    this.autoPlay(), this.options.autoplay = !0, this.paused = !1, this.focussed = !1, this.interrupted = !1
  }, a.prototype.postSlide = function (t) {
    var e = this;
    e.unslicked || (e.$slider.trigger("afterChange", [e, t]), e.animating = !1, e.slideCount > e.options.slidesToShow && e.setPosition(), e.swipeLeft = null, e.options.autoplay && e.autoPlay(), !0 === e.options.accessibility && (e.initADA(), e.options.focusOnChange && c(e.$slides.get(e.currentSlide)).attr("tabindex", 0).focus()))
  }, a.prototype.prev = a.prototype.slickPrev = function () {
    this.changeSlide({
      data: {
        message: "previous"
      }
    })
  }, a.prototype.preventDefault = function (t) {
    t.preventDefault()
  }, a.prototype.progressiveLazyLoad = function (t) {
    t = t || 1;
    var e, i, s, n, a = this,
      o = c("img[data-lazy]", a.$slider);
    o.length ? (e = o.first(), i = e.attr("data-lazy"), s = e.attr("data-srcset"), n = e.attr("data-sizes") || a.$slider.attr("data-sizes"), (o = document.createElement("img")).onload = function () {
      s && (e.attr("srcset", s), n && e.attr("sizes", n)), e.attr("src", i).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"), !0 === a.options.adaptiveHeight && a.setPosition(), a.$slider.trigger("lazyLoaded", [a, e, i]), a.progressiveLazyLoad()
    }, o.onerror = function () {
      t < 3 ? setTimeout(function () {
        a.progressiveLazyLoad(t + 1)
      }, 500) : (e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), a.$slider.trigger("lazyLoadError", [a, e, i]), a.progressiveLazyLoad())
    }, o.src = i) : a.$slider.trigger("allImagesLoaded", [a])
  }, a.prototype.refresh = function (t) {
    var e = this,
      i = e.slideCount - e.options.slidesToShow;
    !e.options.infinite && e.currentSlide > i && (e.currentSlide = i), e.slideCount <= e.options.slidesToShow && (e.currentSlide = 0), i = e.currentSlide, e.destroy(!0), c.extend(e, e.initials, {
      currentSlide: i
    }), e.init(), t || e.changeSlide({
      data: {
        message: "index",
        index: i
      }
    }, !1)
  }, a.prototype.registerBreakpoints = function () {
    var t, e, i, s = this,
      n = s.options.responsive || null;
    if ("array" === c.type(n) && n.length) {
      for (t in s.respondTo = s.options.respondTo || "window", n)
        if (i = s.breakpoints.length - 1, n.hasOwnProperty(t)) {
          for (e = n[t].breakpoint; 0 <= i;) s.breakpoints[i] && s.breakpoints[i] === e && s.breakpoints.splice(i, 1), i--;
          s.breakpoints.push(e), s.breakpointSettings[e] = n[t].settings
        } s.breakpoints.sort(function (t, e) {
        return s.options.mobileFirst ? t - e : e - t
      })
    }
  }, a.prototype.reinit = function () {
    var t = this;
    t.$slides = t.$slideTrack.children(t.options.slide).addClass("slick-slide"), t.slideCount = t.$slides.length, t.currentSlide >= t.slideCount && 0 !== t.currentSlide && (t.currentSlide = t.currentSlide - t.options.slidesToScroll), t.slideCount <= t.options.slidesToShow && (t.currentSlide = 0), t.registerBreakpoints(), t.setProps(), t.setupInfinite(), t.buildArrows(), t.updateArrows(), t.initArrowEvents(), t.buildDots(), t.updateDots(), t.initDotEvents(), t.cleanUpSlideEvents(), t.initSlideEvents(), t.checkResponsive(!1, !0), !0 === t.options.focusOnSelect && c(t.$slideTrack).children().on("click.slick", t.selectHandler), t.setSlideClasses("number" == typeof t.currentSlide ? t.currentSlide : 0), t.setPosition(), t.focusHandler(), t.paused = !t.options.autoplay, t.autoPlay(), t.$slider.trigger("reInit", [t])
  }, a.prototype.resize = function () {
    var t = this;
    c(window).width() !== t.windowWidth && (clearTimeout(t.windowDelay), t.windowDelay = window.setTimeout(function () {
      t.windowWidth = c(window).width(), t.checkResponsive(), t.unslicked || t.setPosition()
    }, 50))
  }, a.prototype.removeSlide = a.prototype.slickRemove = function (t, e, i) {
    var s = this;
    if (t = "boolean" == typeof t ? !0 === (e = t) ? 0 : s.slideCount - 1 : !0 === e ? --t : t, s.slideCount < 1 || t < 0 || t > s.slideCount - 1) return !1;
    s.unload(), (!0 === i ? s.$slideTrack.children() : s.$slideTrack.children(this.options.slide).eq(t)).remove(), s.$slides = s.$slideTrack.children(this.options.slide), s.$slideTrack.children(this.options.slide).detach(), s.$slideTrack.append(s.$slides), s.$slidesCache = s.$slides, s.reinit()
  }, a.prototype.setCSS = function (t) {
    var e, i, s = this,
      n = {};
    !0 === s.options.rtl && (t = -t), e = "left" == s.positionProp ? Math.ceil(t) + "px" : "0px", i = "top" == s.positionProp ? Math.ceil(t) + "px" : "0px", n[s.positionProp] = t, !1 === s.transformsEnabled || (!(n = {}) === s.cssTransitions ? n[s.animType] = "translate(" + e + ", " + i + ")" : n[s.animType] = "translate3d(" + e + ", " + i + ", 0px)"), s.$slideTrack.css(n)
  }, a.prototype.setDimensions = function () {
    var t = this;
    !1 === t.options.vertical ? !0 === t.options.centerMode && t.$list.css({
      padding: "0px " + t.options.centerPadding
    }) : (t.$list.height(t.$slides.first().outerHeight(!0) * t.options.slidesToShow), !0 === t.options.centerMode && t.$list.css({
      padding: t.options.centerPadding + " 0px"
    })), t.listWidth = t.$list.width(), t.listHeight = t.$list.height(), !1 === t.options.vertical && !1 === t.options.variableWidth ? (t.slideWidth = Math.ceil(t.listWidth / t.options.slidesToShow), t.$slideTrack.width(Math.ceil(t.slideWidth * t.$slideTrack.children(".slick-slide").length))) : !0 === t.options.variableWidth ? t.$slideTrack.width(5e3 * t.slideCount) : (t.slideWidth = Math.ceil(t.listWidth), t.$slideTrack.height(Math.ceil(t.$slides.first().outerHeight(!0) * t.$slideTrack.children(".slick-slide").length)));
    var e = t.$slides.first().outerWidth(!0) - t.$slides.first().width();
    !1 === t.options.variableWidth && t.$slideTrack.children(".slick-slide").width(t.slideWidth - e)
  }, a.prototype.setFade = function () {
    var i, s = this;
    s.$slides.each(function (t, e) {
      i = s.slideWidth * t * -1, !0 === s.options.rtl ? c(e).css({
        position: "relative",
        right: i,
        top: 0,
        zIndex: s.options.zIndex - 2,
        opacity: 0
      }) : c(e).css({
        position: "relative",
        left: i,
        top: 0,
        zIndex: s.options.zIndex - 2,
        opacity: 0
      })
    }), s.$slides.eq(s.currentSlide).css({
      zIndex: s.options.zIndex - 1,
      opacity: 1
    })
  }, a.prototype.setHeight = function () {
    var t;
    1 === this.options.slidesToShow && !0 === this.options.adaptiveHeight && !1 === this.options.vertical && (t = this.$slides.eq(this.currentSlide).outerHeight(!0), this.$list.css("height", t))
  }, a.prototype.setOption = a.prototype.slickSetOption = function () {
    var t, e, i, s, n, a = this,
      o = !1;
    if ("object" === c.type(arguments[0]) ? (i = arguments[0], o = arguments[1], n = "multiple") : "string" === c.type(arguments[0]) && (i = arguments[0], s = arguments[1], o = arguments[2], "responsive" === arguments[0] && "array" === c.type(arguments[1]) ? n = "responsive" : void 0 !== arguments[1] && (n = "single")), "single" === n) a.options[i] = s;
    else if ("multiple" === n) c.each(i, function (t, e) {
      a.options[t] = e
    });
    else if ("responsive" === n)
      for (e in s)
        if ("array" !== c.type(a.options.responsive)) a.options.responsive = [s[e]];
        else {
          for (t = a.options.responsive.length - 1; 0 <= t;) a.options.responsive[t].breakpoint === s[e].breakpoint && a.options.responsive.splice(t, 1), t--;
          a.options.responsive.push(s[e])
        } o && (a.unload(), a.reinit())
  }, a.prototype.setPosition = function () {
    this.setDimensions(), this.setHeight(), !1 === this.options.fade ? this.setCSS(this.getLeft(this.currentSlide)) : this.setFade(), this.$slider.trigger("setPosition", [this])
  }, a.prototype.setProps = function () {
    var t = this,
      e = document.body.style;
    t.positionProp = !0 === t.options.vertical ? "top" : "left", "top" === t.positionProp ? t.$slider.addClass("slick-vertical") : t.$slider.removeClass("slick-vertical"), void 0 === e.WebkitTransition && void 0 === e.MozTransition && void 0 === e.msTransition || !0 === t.options.useCSS && (t.cssTransitions = !0), t.options.fade && ("number" == typeof t.options.zIndex ? t.options.zIndex < 3 && (t.options.zIndex = 3) : t.options.zIndex = t.defaults.zIndex), void 0 !== e.OTransform && (t.animType = "OTransform", t.transformType = "-o-transform", t.transitionType = "OTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (t.animType = !1)), void 0 !== e.MozTransform && (t.animType = "MozTransform", t.transformType = "-moz-transform", t.transitionType = "MozTransition", void 0 === e.perspectiveProperty && void 0 === e.MozPerspective && (t.animType = !1)), void 0 !== e.webkitTransform && (t.animType = "webkitTransform", t.transformType = "-webkit-transform", t.transitionType = "webkitTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (t.animType = !1)), void 0 !== e.msTransform && (t.animType = "msTransform", t.transformType = "-ms-transform", t.transitionType = "msTransition", void 0 === e.msTransform && (t.animType = !1)), void 0 !== e.transform && !1 !== t.animType && (t.animType = "transform", t.transformType = "transform", t.transitionType = "transition"), t.transformsEnabled = t.options.useTransform && null !== t.animType && !1 !== t.animType
  }, a.prototype.setSlideClasses = function (t) {
    var e, i, s, n = this,
      a = n.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true");
    n.$slides.eq(t).addClass("slick-current"), !0 === n.options.centerMode ? (i = n.options.slidesToShow % 2 == 0 ? 1 : 0, s = Math.floor(n.options.slidesToShow / 2), !0 === n.options.infinite && (s <= t && t <= n.slideCount - 1 - s ? n.$slides.slice(t - s + i, t + s + 1).addClass("slick-active").attr("aria-hidden", "false") : (e = n.options.slidesToShow + t, a.slice(e - s + 1 + i, e + s + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === t ? a.eq(a.length - 1 - n.options.slidesToShow).addClass("slick-center") : t === n.slideCount - 1 && a.eq(n.options.slidesToShow).addClass("slick-center")), n.$slides.eq(t).addClass("slick-center")) : 0 <= t && t <= n.slideCount - n.options.slidesToShow ? n.$slides.slice(t, t + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : a.length <= n.options.slidesToShow ? a.addClass("slick-active").attr("aria-hidden", "false") : (s = n.slideCount % n.options.slidesToShow, e = !0 === n.options.infinite ? n.options.slidesToShow + t : t, (n.options.slidesToShow == n.options.slidesToScroll && n.slideCount - t < n.options.slidesToShow ? a.slice(e - (n.options.slidesToShow - s), e + s) : a.slice(e, e + n.options.slidesToShow)).addClass("slick-active").attr("aria-hidden", "false")), "ondemand" !== n.options.lazyLoad && "anticipated" !== n.options.lazyLoad || n.lazyLoad()
  }, a.prototype.setupInfinite = function () {
    var t, e, i, s = this;
    if (!0 === s.options.fade && (s.options.centerMode = !1), !0 === s.options.infinite && !1 === s.options.fade && (e = null, s.slideCount > s.options.slidesToShow)) {
      for (i = !0 === s.options.centerMode ? s.options.slidesToShow + 1 : s.options.slidesToShow, t = s.slideCount; t > s.slideCount - i; --t) c(s.$slides[e = t - 1]).clone(!0).attr("id", "").attr("data-slick-index", e - s.slideCount).prependTo(s.$slideTrack).addClass("slick-cloned");
      for (t = 0; t < i + s.slideCount; t += 1) e = t, c(s.$slides[e]).clone(!0).attr("id", "").attr("data-slick-index", e + s.slideCount).appendTo(s.$slideTrack).addClass("slick-cloned");
      s.$slideTrack.find(".slick-cloned").find("[id]").each(function () {
        c(this).attr("id", "")
      })
    }
  }, a.prototype.interrupt = function (t) {
    t || this.autoPlay(), this.interrupted = t
  }, a.prototype.selectHandler = function (t) {
    t = c(t.target).is(".slick-slide") ? c(t.target) : c(t.target).parents(".slick-slide"), t = (t = parseInt(t.attr("data-slick-index"))) || 0;
    this.slideCount <= this.options.slidesToShow ? this.slideHandler(t, !1, !0) : this.slideHandler(t)
  }, a.prototype.slideHandler = function (t, e, i) {
    var s, n, a, o, r = this;
    if (e = e || !1, !(!0 === r.animating && !0 === r.options.waitForAnimate || !0 === r.options.fade && r.currentSlide === t))
      if (!1 === e && r.asNavFor(t), s = t, a = r.getLeft(s), e = r.getLeft(r.currentSlide), r.currentLeft = null === r.swipeLeft ? e : r.swipeLeft, !1 === r.options.infinite && !1 === r.options.centerMode && (t < 0 || t > r.getDotCount() * r.options.slidesToScroll)) !1 === r.options.fade && (s = r.currentSlide, !0 !== i && r.slideCount > r.options.slidesToShow ? r.animateSlide(e, function () {
        r.postSlide(s)
      }) : r.postSlide(s));
      else if (!1 === r.options.infinite && !0 === r.options.centerMode && (t < 0 || t > r.slideCount - r.options.slidesToScroll)) !1 === r.options.fade && (s = r.currentSlide, !0 !== i && r.slideCount > r.options.slidesToShow ? r.animateSlide(e, function () {
      r.postSlide(s)
    }) : r.postSlide(s));
    else {
      if (r.options.autoplay && clearInterval(r.autoPlayTimer), n = s < 0 ? r.slideCount % r.options.slidesToScroll != 0 ? r.slideCount - r.slideCount % r.options.slidesToScroll : r.slideCount + s : s >= r.slideCount ? r.slideCount % r.options.slidesToScroll != 0 ? 0 : s - r.slideCount : s, r.animating = !0, r.$slider.trigger("beforeChange", [r, r.currentSlide, n]), e = r.currentSlide, r.currentSlide = n, r.setSlideClasses(r.currentSlide), r.options.asNavFor && (o = (o = r.getNavTarget()).slick("getSlick")).slideCount <= o.options.slidesToShow && o.setSlideClasses(r.currentSlide), r.updateDots(), r.updateArrows(), !0 === r.options.fade) return !0 !== i ? (r.fadeSlideOut(e), r.fadeSlide(n, function () {
        r.postSlide(n)
      })) : r.postSlide(n), void r.animateHeight();
      !0 !== i && r.slideCount > r.options.slidesToShow ? r.animateSlide(a, function () {
        r.postSlide(n)
      }) : r.postSlide(n)
    }
  }, a.prototype.startLoad = function () {
    var t = this;
    !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && (t.$prevArrow.hide(), t.$nextArrow.hide()), !0 === t.options.dots && t.slideCount > t.options.slidesToShow && t.$dots.hide(), t.$slider.addClass("slick-loading")
  }, a.prototype.swipeDirection = function () {
    var t = this.touchObject.startX - this.touchObject.curX,
      e = this.touchObject.startY - this.touchObject.curY,
      t = Math.atan2(e, t),
      t = Math.round(180 * t / Math.PI);
    return (t = t < 0 ? 360 - Math.abs(t) : t) <= 45 && 0 <= t || t <= 360 && 315 <= t ? !1 === this.options.rtl ? "left" : "right" : 135 <= t && t <= 225 ? !1 === this.options.rtl ? "right" : "left" : !0 === this.options.verticalSwiping ? 35 <= t && t <= 135 ? "down" : "up" : "vertical"
  }, a.prototype.swipeEnd = function (t) {
    var e, i, s = this;
    if (s.dragging = !1, s.swiping = !1, s.scrolling) return s.scrolling = !1;
    if (s.interrupted = !1, s.shouldClick = !(10 < s.touchObject.swipeLength), void 0 === s.touchObject.curX) return !1;
    if (!0 === s.touchObject.edgeHit && s.$slider.trigger("edge", [s, s.swipeDirection()]), s.touchObject.swipeLength >= s.touchObject.minSwipe) {
      switch (i = s.swipeDirection()) {
        case "left":
        case "down":
          e = s.options.swipeToSlide ? s.checkNavigable(s.currentSlide + s.getSlideCount()) : s.currentSlide + s.getSlideCount(), s.currentDirection = 0;
          break;
        case "right":
        case "up":
          e = s.options.swipeToSlide ? s.checkNavigable(s.currentSlide - s.getSlideCount()) : s.currentSlide - s.getSlideCount(), s.currentDirection = 1
      }
      "vertical" != i && (s.slideHandler(e), s.touchObject = {}, s.$slider.trigger("swipe", [s, i]))
    } else s.touchObject.startX !== s.touchObject.curX && (s.slideHandler(s.currentSlide), s.touchObject = {})
  }, a.prototype.swipeHandler = function (t) {
    var e = this;
    if (!(!1 === e.options.swipe || "ontouchend" in document && !1 === e.options.swipe || !1 === e.options.draggable && -1 !== t.type.indexOf("mouse"))) switch (e.touchObject.fingerCount = t.originalEvent && void 0 !== t.originalEvent.touches ? t.originalEvent.touches.length : 1, e.touchObject.minSwipe = e.listWidth / e.options.touchThreshold, !0 === e.options.verticalSwiping && (e.touchObject.minSwipe = e.listHeight / e.options.touchThreshold), t.data.action) {
      case "start":
        e.swipeStart(t);
        break;
      case "move":
        e.swipeMove(t);
        break;
      case "end":
        e.swipeEnd(t)
    }
  }, a.prototype.swipeMove = function (t) {
    var e, i, s = this,
      n = void 0 !== t.originalEvent ? t.originalEvent.touches : null;
    return !(!s.dragging || s.scrolling || n && 1 !== n.length) && (e = s.getLeft(s.currentSlide), s.touchObject.curX = void 0 !== n ? n[0].pageX : t.clientX, s.touchObject.curY = void 0 !== n ? n[0].pageY : t.clientY, s.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(s.touchObject.curX - s.touchObject.startX, 2))), i = Math.round(Math.sqrt(Math.pow(s.touchObject.curY - s.touchObject.startY, 2))), !s.options.verticalSwiping && !s.swiping && 4 < i ? !(s.scrolling = !0) : (!0 === s.options.verticalSwiping && (s.touchObject.swipeLength = i), n = s.swipeDirection(), void 0 !== t.originalEvent && 4 < s.touchObject.swipeLength && (s.swiping = !0, t.preventDefault()), i = (!1 === s.options.rtl ? 1 : -1) * (s.touchObject.curX > s.touchObject.startX ? 1 : -1), !0 === s.options.verticalSwiping && (i = s.touchObject.curY > s.touchObject.startY ? 1 : -1), t = s.touchObject.swipeLength, (s.touchObject.edgeHit = !1) === s.options.infinite && (0 === s.currentSlide && "right" === n || s.currentSlide >= s.getDotCount() && "left" === n) && (t = s.touchObject.swipeLength * s.options.edgeFriction, s.touchObject.edgeHit = !0), !1 === s.options.vertical ? s.swipeLeft = e + t * i : s.swipeLeft = e + t * (s.$list.height() / s.listWidth) * i, !0 === s.options.verticalSwiping && (s.swipeLeft = e + t * i), !0 !== s.options.fade && !1 !== s.options.touchMove && (!0 === s.animating ? (s.swipeLeft = null, !1) : void s.setCSS(s.swipeLeft))))
  }, a.prototype.swipeStart = function (t) {
    var e, i = this;
    if (i.interrupted = !0, 1 !== i.touchObject.fingerCount || i.slideCount <= i.options.slidesToShow) return !(i.touchObject = {});
    void 0 !== t.originalEvent && void 0 !== t.originalEvent.touches && (e = t.originalEvent.touches[0]), i.touchObject.startX = i.touchObject.curX = void 0 !== e ? e.pageX : t.clientX, i.touchObject.startY = i.touchObject.curY = void 0 !== e ? e.pageY : t.clientY, i.dragging = !0
  }, a.prototype.unfilterSlides = a.prototype.slickUnfilter = function () {
    null !== this.$slidesCache && (this.unload(), this.$slideTrack.children(this.options.slide).detach(), this.$slidesCache.appendTo(this.$slideTrack), this.reinit())
  }, a.prototype.unload = function () {
    var t = this;
    c(".slick-cloned", t.$slider).remove(), t.$dots && t.$dots.remove(), t.$prevArrow && t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.remove(), t.$nextArrow && t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.remove(), t.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "")
  }, a.prototype.unslick = function (t) {
    this.$slider.trigger("unslick", [this, t]), this.destroy()
  }, a.prototype.updateArrows = function () {
    var t = this;
    Math.floor(t.options.slidesToShow / 2);
    !0 === t.options.arrows && t.slideCount > t.options.slidesToShow && !t.options.infinite && (t.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), t.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === t.currentSlide ? (t.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), t.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : (t.currentSlide >= t.slideCount - t.options.slidesToShow && !1 === t.options.centerMode || t.currentSlide >= t.slideCount - 1 && !0 === t.options.centerMode) && (t.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), t.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")))
  }, a.prototype.updateDots = function () {
    null !== this.$dots && (this.$dots.find("li").removeClass("slick-active").end(), this.$dots.find("li").eq(Math.floor(this.currentSlide / this.options.slidesToScroll)).addClass("slick-active"))
  }, a.prototype.visibility = function () {
    this.options.autoplay && (document[this.hidden] ? this.interrupted = !0 : this.interrupted = !1)
  }, c.fn.slick = function () {
    for (var t, e = arguments[0], i = Array.prototype.slice.call(arguments, 1), s = this.length, n = 0; n < s; n++)
      if ("object" == typeof e || void 0 === e ? this[n].slick = new a(this[n], e) : t = this[n].slick[e].apply(this[n].slick, i), void 0 !== t) return t;
    return this
  }
});
let video = document.querySelector("#video-webcam");

function startWebcam() {
  navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, navigator.getUserMedia && navigator.getUserMedia({
    video: !0
  }, function (t) {
    video.srcObject = t
  }, function (t) {
    alert("Izinkan menggunakan webcam untuk mengambil foto!")
  })
}

function takeSnapshot(t) {
  let e = document.createElement("img"),
    i;
  var s = video.offsetWidth,
    n = video.offsetHeight;
  canvas = document.createElement("canvas"), canvas.width = s, canvas.height = n, i = canvas.getContext("2d"), i.drawImage(video, 0, 0, s, n), e.src = canvas.toDataURL("image/png"), "identity" == t ? snapPreview(e.src, ".custom-file-upload__box-preview") : "profil" == t ? $("#profile-img-view").attr("src", e.src) : "jaminan" == t && $($.parseHTML(`<div class="drop-zoon">
            <img src="${e.src}" class="drop-zoon__image" />
            <img src="./assets/images/close-round-dark.svg"
                alt=""
                class="drop-zoon__icon"
                onclick="splicePreview(this)"
              />
                  </div>`)).appendTo(".box-upload-multiple-image__preview")
}

function datePick() {
  $.datepicker.regional.id = {
    monthNames: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"],
    monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agu", "Sep", "Okt", "Nov", "Des"],
    dayNames: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"],
    dayNamesMin: ["Mi", "Se", "Se", "Ra", "Ka", "Ju", "Sa"],
    showOtherMonths: !0,
    selectOtherMonths: !1,
    minDate: new Date,
    firstDay: 0
  }, $.datepicker.setDefaults($.datepicker.regional.id)
}

function checkSearch(t, e) {
  "" != $(t).val() ? $("#" + e).css("display", "flex") : $("#" + e).hide()
}

function openSearchModal() {
  $(".search-modal").toggle()
}

function openGuide(t) {
  1 == $("#guide" + t).hasClass("show-guide") ? ($("#guide" + t).removeClass(" show-guide"), $("#btn-open" + t).html("Baca Selengkapnya")) : ($("#guide" + t).addClass("show-guide"), $("#btn-open" + t).html("Sembunyikan"))
}

function copyPromo(t) {
  var e = $("<input>");
  $("body").append(e), e.val($(t).html()).select(), document.execCommand("copy"), e.remove()
}

function showToast(t) {
  $("#" + t).css({
    display: "flex",
    opacity: "1"
  }), setTimeout(() => {
    $("#" + t).css({
      opacity: "0",
      display: "none"
    }), $("#" + t).hide()
  }, 1800)
}

function closeThisElement(t) {
  $("#" + t).fadeOut()
}

function selectedTextOnly(t, e, i, s, n, a, o) {
  $("#" + i).hide(), $("#" + s).show(), $("#" + t).val(a), $("#" + n).text(a), $("#" + i).parent().click(), $("#" + t).change(), $("." + o).find("img").remove(), $(e).append('<img src="./assets/images/icon-checklist.svg" alt="">')
}

function selectedTextOnlyMobile(t, e, i, s, n) {
  $("." + n).find("img").remove(), $(e).append('<img src="./assets/images/icon-checklist.svg" alt="">'), $("#" + s).html(t), $("#" + s).addClass("active"), $("#" + i).val(t), $("#" + i).change()
}

function selectedIconTextSmall(t, e, i, s, n, a, o, r, l, c, d, h) {
  $("#" + t).hide(), $("#" + e).css("display", "flex"), $("#" + i).val(c), $("#" + s).text(l), $("#" + n).text(c), $("#" + a).attr("src", r), $("#" + h).click(), $("." + o).find("img").remove(), $(d).find("." + o).append('<img src="./assets/images/icon-checklist.svg" alt="checklist-ico">')
}

function selectedIconTextSmallMobile(t, e, i, s, n, a, o, r) {
  $("." + a).find(".checklist-ico").remove(), $(i).append('<img src="./assets/images/icon-checklist.svg" alt="" class="checklist-ico">'), $("#" + n).html(t), $("#" + o).html(e), $("#" + n).addClass("active"), $("#" + s).val(t), $("#" + s).change(), $("#" + r).show()
}

function selectedIconTextLarge(t, e, i, s, n, a, o, r, l, c, d, h, u, p) {
  $("#" + t).hide(), $("#" + e).css("display", "flex"), $("#" + i).val(d), $("#" + i).change(), $("#" + s).text(d), $("#" + n).text(u), $("#" + a).text(p), $("#" + o).attr("src", h), $("#" + l).click(), $("." + r).find("img").remove(), $(c).find("." + r).append('<img src="./assets/images/icon-checklist.svg" alt="checklist-ico">')
}

function selectedIconTextLargeMobile(t, e, i, s, n, a, o, r, l, c, d) {
  $("." + r).find(".ico-check").hide(), $(i).find(".ico-check").show(), $("#" + o).html(t), $("#" + l).html(e), $("#" + c).html(s), $("#" + o).addClass("active"), $("#" + a).val(t), $("#" + a).change(), $("#" + d).find("img").attr("src", n), $("#" + d).show()
}

function clickRadioForm(t, e) {
  $("." + t).removeClass("active"), $("#" + e).is(":checked") && $("#" + e).parent().addClass("active")
}

function imagesPreview1(t, s) {
  if (t.files && t.files.length < 5) {
    var e = t.files.length;
    for (i = 0; i < e; i++) {
      var n = new FileReader;
      n.onload = function (t, e) {
        $($.parseHTML(`<div class="drop-zoon">
                <img src="${t.target.result}" class="drop-zoon__image" />
                <img src="./assets/images/close-round-dark.svg"
                    alt=""
                    class="drop-zoon__icon"
                    onclick="splicePreview(this)"
                  />
                      </div>`)).appendTo(s)
      }, n.readAsDataURL(t.files[i])
    }
    $(".custom-file-upload__box-input-icon").hide(), $("#box-preview-image").css("display", "grid")
  } else alert("Upload maksimal 4 foto")
}

function imagesPreview2(t, s) {
  if (t.files && t.files.length < 6) {
    var e = t.files.length;
    for (i = 0; i < e; i++) {
      var n = new FileReader;
      n.onload = function (t, e) {
        $($.parseHTML(`<div class="drop-zoon">
                <img src="${t.target.result}" class="drop-zoon__image" />
                <img src="./assets/images/close-round-dark.svg"
                    alt=""
                    class="drop-zoon__icon"
                    onclick="splicePreview(this)"
                  />
                      </div>`)).appendTo(s)
      }, n.readAsDataURL(t.files[i]), 4 == i ? $(".box-upload-multiple-image__input").hide() : $(".box-upload-multiple-image__input").css("display", "flex")
    }
  } else alert("Upload maksimal 5 foto")
}

function splicePreview(t) {
  $(t).parent().remove(), 0 == $(".drop-zoon").length ? ($("#box-preview-image").hide(), $(".custom-file-upload__box-input-icon").show(), $("#gallery-photo-add").val("")) : $(t).parent().remove(), $(".box-upload-multiple-image__input").css("display", "flex")
}

function closeThisElement(t) {
  $(t).fadeOut()
}

function closeThis(t) {
  $(t).parent().fadeOut(), $(t).parent().removeClass("display-flex")
}

function closeModalThis2(t) {
  $("#" + t).trigger("click")
}

function verifyFormatRp3(t, e) {
  let i = t.replace(/[^,\d]/g, "").toString(),
    s = i.split(","),
    n = s[0].length % 3,
    a = s[0].substr(0, n),
    o = s[0].substr(n).match(/\d{1,3}/gi);
  return o && (separator = n ? "." : "", a += separator + o.join(".")), a = null != s[1] ? a + "," + s[1] : a, null == e ? a : a || ""
}! function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Swiper = e()
}(this, function () {
  "use strict";

  function s(t) {
    return null !== t && "object" == typeof t && "constructor" in t && t.constructor === Object
  }

  function n(e = {}, i = {}) {
    Object.keys(i).forEach(t => {
      void 0 === e[t] ? e[t] = i[t] : s(i[t]) && s(e[t]) && 0 < Object.keys(i[t]).length && n(e[t], i[t])
    })
  }
  const e = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
      blur() {},
      nodeName: ""
    },
    querySelector: () => null,
    querySelectorAll: () => [],
    getElementById: () => null,
    createEvent: () => ({
      initEvent() {}
    }),
    createElement: () => ({
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName: () => []
    }),
    createElementNS: () => ({}),
    importNode: () => null,
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };

  function x() {
    var t = "undefined" != typeof document ? document : {};
    return n(t, e), t
  }
  const i = {
    document: e,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {},
      pushState() {},
      go() {},
      back() {}
    },
    CustomEvent: function () {
      return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle: () => ({
      getPropertyValue: () => ""
    }),
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia: () => ({}),
    requestAnimationFrame: t => "undefined" == typeof setTimeout ? (t(), null) : setTimeout(t, 0),
    cancelAnimationFrame(t) {
      "undefined" != typeof setTimeout && clearTimeout(t)
    }
  };

  function A() {
    var t = "undefined" != typeof window ? window : {};
    return n(t, i), t
  }
  class o extends Array {
    constructor(t) {
      super(...t || []),
        function (t) {
          const e = t.__proto__;
          Object.defineProperty(t, "__proto__", {
            get: () => e,
            set(t) {
              e.__proto__ = t
            }
          })
        }(this)
    }
  }

  function a(t = []) {
    const e = [];
    return t.forEach(t => {
      Array.isArray(t) ? e.push(...a(t)) : e.push(t)
    }), e
  }

  function r(t, e) {
    return Array.prototype.filter.call(t, e)
  }

  function P(t, e) {
    const i = A(),
      s = x();
    let n = [];
    if (!e && t instanceof o) return t;
    if (!t) return new o(n);
    if ("string" == typeof t) {
      const i = t.trim();
      if (0 <= i.indexOf("<") && 0 <= i.indexOf(">")) {
        let t = "div";
        0 === i.indexOf("<li") && (t = "ul"), 0 === i.indexOf("<tr") && (t = "tbody"), 0 !== i.indexOf("<td") && 0 !== i.indexOf("<th") || (t = "tr"), 0 === i.indexOf("<tbody") && (t = "table"), 0 === i.indexOf("<option") && (t = "select");
        const e = s.createElement(t);
        e.innerHTML = i;
        for (let t = 0; t < e.childNodes.length; t += 1) n.push(e.childNodes[t])
      } else n = function (t, e) {
        if ("string" != typeof t) return [t];
        const i = [],
          s = e.querySelectorAll(t);
        for (let t = 0; t < s.length; t += 1) i.push(s[t]);
        return i
      }(t.trim(), e || s)
    } else if (t.nodeType || t === i || t === s) n.push(t);
    else if (Array.isArray(t)) {
      if (t instanceof o) return t;
      n = t
    }
    return new o(function (e) {
      const i = [];
      for (let t = 0; t < e.length; t += 1) - 1 === i.indexOf(e[t]) && i.push(e[t]);
      return i
    }(n))
  }
  P.fn = o.prototype;
  const l = {
    addClass: function (...t) {
      const e = a(t.map(t => t.split(" ")));
      return this.forEach(t => {
        t.classList.add(...e)
      }), this
    },
    removeClass: function (...t) {
      const e = a(t.map(t => t.split(" ")));
      return this.forEach(t => {
        t.classList.remove(...e)
      }), this
    },
    hasClass: function (...t) {
      const i = a(t.map(t => t.split(" ")));
      return 0 < r(this, e => 0 < i.filter(t => e.classList.contains(t)).length).length
    },
    toggleClass: function (...t) {
      const i = a(t.map(t => t.split(" ")));
      this.forEach(e => {
        i.forEach(t => {
          e.classList.toggle(t)
        })
      })
    },
    attr: function (e, i) {
      if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;
      for (let t = 0; t < this.length; t += 1)
        if (2 === arguments.length) this[t].setAttribute(e, i);
        else
          for (const i in e) this[t][i] = e[i], this[t].setAttribute(i, e[i]);
      return this
    },
    removeAttr: function (e) {
      for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
      return this
    },
    transform: function (e) {
      for (let t = 0; t < this.length; t += 1) this[t].style.transform = e;
      return this
    },
    transition: function (e) {
      for (let t = 0; t < this.length; t += 1) this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e;
      return this
    },
    on: function (...e) {
      let [i, s, n, a] = e;

      function o(e) {
        var t = e.target;
        if (t) {
          const i = e.target.dom7EventData || [];
          if (i.indexOf(e) < 0 && i.unshift(e), P(t).is(s)) n.apply(t, i);
          else {
            const e = P(t).parents();
            for (let t = 0; t < e.length; t += 1) P(e[t]).is(s) && n.apply(e[t], i)
          }
        }
      }

      function r(t) {
        const e = t && t.target && t.target.dom7EventData || [];
        e.indexOf(t) < 0 && e.unshift(t), n.apply(this, e)
      }
      "function" == typeof e[1] && ([i, n, a] = e, s = void 0), a = a || !1;
      var l = i.split(" ");
      let c;
      for (let t = 0; t < this.length; t += 1) {
        const i = this[t];
        if (s)
          for (c = 0; c < l.length; c += 1) {
            const e = l[c];
            i.dom7LiveListeners || (i.dom7LiveListeners = {}), i.dom7LiveListeners[e] || (i.dom7LiveListeners[e] = []), i.dom7LiveListeners[e].push({
              listener: n,
              proxyListener: o
            }), i.addEventListener(e, o, a)
          } else
            for (c = 0; c < l.length; c += 1) {
              const e = l[c];
              i.dom7Listeners || (i.dom7Listeners = {}), i.dom7Listeners[e] || (i.dom7Listeners[e] = []), i.dom7Listeners[e].push({
                listener: n,
                proxyListener: r
              }), i.addEventListener(e, r, a)
            }
      }
      return this
    },
    off: function (...t) {
      let [i, s, n, a] = t;
      "function" == typeof t[1] && ([i, n, a] = t, s = void 0), a = a || !1;
      const o = i.split(" ");
      for (let t = 0; t < o.length; t += 1) {
        const i = o[t];
        for (let t = 0; t < this.length; t += 1) {
          const o = this[t];
          let e;
          if (!s && o.dom7Listeners ? e = o.dom7Listeners[i] : s && o.dom7LiveListeners && (e = o.dom7LiveListeners[i]), e && e.length)
            for (let t = e.length - 1; 0 <= t; --t) {
              const s = e[t];
              !(n && s.listener === n || n && s.listener && s.listener.dom7proxy && s.listener.dom7proxy === n) && n || (o.removeEventListener(i, s.proxyListener, a), e.splice(t, 1))
            }
        }
      }
      return this
    },
    trigger: function (...e) {
      const i = A(),
        s = e[0].split(" "),
        n = e[1];
      for (let t = 0; t < s.length; t += 1) {
        const A = s[t];
        for (let t = 0; t < this.length; t += 1) {
          const a = this[t];
          if (i.CustomEvent) {
            const s = new i.CustomEvent(A, {
              detail: n,
              bubbles: !0,
              cancelable: !0
            });
            a.dom7EventData = e.filter((t, e) => 0 < e), a.dispatchEvent(s), a.dom7EventData = [], delete a.dom7EventData
          }
        }
      }
      return this
    },
    transitionEnd: function (i) {
      const s = this;
      return i && s.on("transitionend", function t(e) {
        e.target === this && (i.call(this, e), s.off("transitionend", t))
      }), this
    },
    outerWidth: function (t) {
      if (0 < this.length) {
        if (t) {
          const t = this.styles();
          return this[0].offsetWidth + parseFloat(t.getPropertyValue("margin-right")) + parseFloat(t.getPropertyValue("margin-left"))
        }
        return this[0].offsetWidth
      }
      return null
    },
    outerHeight: function (t) {
      if (0 < this.length) {
        if (t) {
          const t = this.styles();
          return this[0].offsetHeight + parseFloat(t.getPropertyValue("margin-top")) + parseFloat(t.getPropertyValue("margin-bottom"))
        }
        return this[0].offsetHeight
      }
      return null
    },
    styles: function () {
      const t = A();
      return this[0] ? t.getComputedStyle(this[0], null) : {}
    },
    offset: function () {
      if (0 < this.length) {
        const t = A(),
          e = x(),
          i = this[0],
          s = i.getBoundingClientRect(),
          n = e.body,
          a = i.clientTop || n.clientTop || 0,
          o = i.clientLeft || n.clientLeft || 0,
          r = i === t ? t.scrollY : i.scrollTop,
          l = i === t ? t.scrollX : i.scrollLeft;
        return {
          top: s.top + r - a,
          left: s.left + l - o
        }
      }
      return null
    },
    css: function (t, e) {
      const i = A();
      let s;
      if (1 === arguments.length) {
        if ("string" != typeof t) {
          for (s = 0; s < this.length; s += 1)
            for (const e in t) this[s].style[e] = t[e];
          return this
        }
        if (this[0]) return i.getComputedStyle(this[0], null).getPropertyValue(t)
      }
      if (2 !== arguments.length || "string" != typeof t) return this;
      for (s = 0; s < this.length; s += 1) this[s].style[t] = e;
      return this
    },
    each: function (i) {
      return i && this.forEach((t, e) => {
        i.apply(t, [t, e])
      }), this
    },
    html: function (e) {
      if (void 0 === e) return this[0] ? this[0].innerHTML : null;
      for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;
      return this
    },
    text: function (e) {
      if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
      for (let t = 0; t < this.length; t += 1) this[t].textContent = e;
      return this
    },
    is: function (t) {
      const e = A(),
        i = x(),
        s = this[0];
      let n, a;
      if (!s || void 0 === t) return !1;
      if ("string" == typeof t) {
        if (s.matches) return s.matches(t);
        if (s.webkitMatchesSelector) return s.webkitMatchesSelector(t);
        if (s.msMatchesSelector) return s.msMatchesSelector(t);
        for (n = P(t), a = 0; a < n.length; a += 1)
          if (n[a] === s) return !0;
        return !1
      }
      if (t === i) return s === i;
      if (t === e) return s === e;
      if (t.nodeType || t instanceof o) {
        for (n = t.nodeType ? [t] : t, a = 0; a < n.length; a += 1)
          if (n[a] === s) return !0;
        return !1
      }
      return !1
    },
    index: function () {
      let t, e = this[0];
      if (e) {
        for (t = 0; null !== (e = e.previousSibling);) 1 === e.nodeType && (t += 1);
        return t
      }
    },
    eq: function (t) {
      if (void 0 === t) return this;
      var e = this.length;
      if (e - 1 < t) return P([]);
      if (t < 0) {
        e = e + t;
        return P(e < 0 ? [] : [this[e]])
      }
      return P([this[t]])
    },
    append: function (...e) {
      var i;
      const s = x();
      for (let t = 0; t < e.length; t += 1) {
        i = e[t];
        for (let e = 0; e < this.length; e += 1)
          if ("string" == typeof i) {
            const x = s.createElement("div");
            for (x.innerHTML = i; x.firstChild;) this[e].appendChild(x.firstChild)
          } else if (i instanceof o)
          for (let t = 0; t < i.length; t += 1) this[e].appendChild(i[t]);
        else this[e].appendChild(i)
      }
      return this
    },
    prepend: function (t) {
      const e = x();
      let i, s;
      for (i = 0; i < this.length; i += 1)
        if ("string" == typeof t) {
          const x = e.createElement("div");
          for (x.innerHTML = t, s = x.childNodes.length - 1; 0 <= s; --s) this[i].insertBefore(x.childNodes[s], this[i].childNodes[0])
        } else if (t instanceof o)
        for (s = 0; s < t.length; s += 1) this[i].insertBefore(t[s], this[i].childNodes[0]);
      else this[i].insertBefore(t, this[i].childNodes[0]);
      return this
    },
    next: function (t) {
      return 0 < this.length ? t ? this[0].nextElementSibling && P(this[0].nextElementSibling).is(t) ? P([this[0].nextElementSibling]) : P([]) : this[0].nextElementSibling ? P([this[0].nextElementSibling]) : P([]) : P([])
    },
    nextAll: function (t) {
      const e = [];
      let i = this[0];
      if (!i) return P([]);
      for (; i.nextElementSibling;) {
        var s = i.nextElementSibling;
        t && !P(s).is(t) || e.push(s), i = s
      }
      return P(e)
    },
    prev: function (t) {
      if (0 < this.length) {
        var e = this[0];
        return t ? e.previousElementSibling && P(e.previousElementSibling).is(t) ? P([e.previousElementSibling]) : P([]) : e.previousElementSibling ? P([e.previousElementSibling]) : P([])
      }
      return P([])
    },
    prevAll: function (t) {
      const e = [];
      let i = this[0];
      if (!i) return P([]);
      for (; i.previousElementSibling;) {
        var s = i.previousElementSibling;
        t && !P(s).is(t) || e.push(s), i = s
      }
      return P(e)
    },
    parent: function (e) {
      const i = [];
      for (let t = 0; t < this.length; t += 1) null === this[t].parentNode || e && !P(this[t].parentNode).is(e) || i.push(this[t].parentNode);
      return P(i)
    },
    parents: function (i) {
      const s = [];
      for (let e = 0; e < this.length; e += 1) {
        let t = this[e].parentNode;
        for (; t;) i && !P(t).is(i) || s.push(t), t = t.parentNode
      }
      return P(s)
    },
    closest: function (t) {
      let e = this;
      return void 0 === t ? P([]) : (e.is(t) || (e = e.parents(t).eq(0)), e)
    },
    find: function (e) {
      const i = [];
      for (let t = 0; t < this.length; t += 1) {
        var s = this[t].querySelectorAll(e);
        for (let t = 0; t < s.length; t += 1) i.push(s[t])
      }
      return P(i)
    },
    children: function (e) {
      const i = [];
      for (let t = 0; t < this.length; t += 1) {
        var s = this[t].children;
        for (let t = 0; t < s.length; t += 1) e && !P(s[t]).is(e) || i.push(s[t])
      }
      return P(i)
    },
    filter: function (t) {
      return P(r(this, t))
    },
    remove: function () {
      for (let t = 0; t < this.length; t += 1) this[t].parentNode && this[t].parentNode.removeChild(this[t]);
      return this
    }
  };

  function C(t, e = 0) {
    return setTimeout(t, e)
  }

  function g() {
    return Date.now()
  }

  function I(t, e = "x") {
    const i = A();
    let s, n, a;
    const o = function (t) {
      const e = A();
      let i;
      return e.getComputedStyle && (i = e.getComputedStyle(t, null)), !i && t.currentStyle && (i = t.currentStyle), i = i || t.style, i
    }(t);
    return i.WebKitCSSMatrix ? (n = o.transform || o.webkitTransform, 6 < n.split(",").length && (n = n.split(", ").map(t => t.replace(",", ".")).join(", ")), a = new i.WebKitCSSMatrix("none" === n ? "" : n)) : (a = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), s = a.toString().split(",")), "x" === e && (n = i.WebKitCSSMatrix ? a.m41 : 16 === s.length ? parseFloat(s[12]) : parseFloat(s[4])), "y" === e && (n = i.WebKitCSSMatrix ? a.m42 : 16 === s.length ? parseFloat(s[13]) : parseFloat(s[5])), n || 0
  }

  function c(t) {
    return "object" == typeof t && null !== t && t.constructor && "Object" === Object.prototype.toString.call(t).slice(8, -1)
  }

  function u(...i) {
    const s = Object(i[0]),
      e = ["__proto__", "constructor", "prototype"];
    for (let t = 1; t < i.length; t += 1) {
      var n = i[t];
      if (null != n && !("undefined" != typeof window && void 0 !== window.HTMLElement ? n instanceof HTMLElement : n && (1 === n.nodeType || 11 === n.nodeType))) {
        const i = Object.keys(Object(n)).filter(t => e.indexOf(t) < 0);
        for (let t = 0, e = i.length; t < e; t += 1) {
          const a = i[t],
            o = Object.getOwnPropertyDescriptor(n, a);
          void 0 !== o && o.enumerable && (c(s[a]) && c(n[a]) ? n[a].__swiper__ ? s[a] = n[a] : u(s[a], n[a]) : !c(s[a]) && c(n[a]) ? (s[a] = {}, n[a].__swiper__ ? s[a] = n[a] : u(s[a], n[a])) : s[a] = n[a])
        }
      }
    }
    var a;
    return s
  }

  function D(t, e, i) {
    t.style.setProperty(e, i)
  }

  function b({
    swiper: i,
    targetPosition: s,
    side: n
  }) {
    const a = A(),
      o = -i.translate;
    let r, l = null;
    const c = i.params.speed;
    i.wrapperEl.style.scrollSnapType = "none", a.cancelAnimationFrame(i.cssModeFrameID);
    const d = s > o ? "next" : "prev",
      h = (t, e) => "next" == d && e <= t || "prev" == d && t <= e,
      u = () => {
        r = (new Date).getTime(), null === l && (l = r);
        var t = Math.max(Math.min((r - l) / c, 1), 0),
          t = .5 - Math.cos(t * Math.PI) / 2;
        let e = o + t * (s - o);
        if (h(e, s) && (e = s), i.wrapperEl.scrollTo({
            [n]: e
          }), h(e, s)) return i.wrapperEl.style.overflow = "hidden", i.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
          i.wrapperEl.style.overflow = "", i.wrapperEl.scrollTo({
            [n]: e
          })
        }), void a.cancelAnimationFrame(i.cssModeFrameID);
        i.cssModeFrameID = a.requestAnimationFrame(u)
      };
    u()
  }
  let t, d, h;

  function p() {
    return t = t || function () {
      const i = A(),
        t = x();
      return {
        smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style,
        touch: !!("ontouchstart" in i || i.DocumentTouch && t instanceof i.DocumentTouch),
        passiveListener: function () {
          let t = !1;
          try {
            var e = Object.defineProperty({}, "passive", {
              get() {
                t = !0
              }
            });
            i.addEventListener("testPassiveListener", null, e)
          } catch (t) {}
          return t
        }(),
        gestures: "ongesturestart" in i
      }
    }(), t
  }

  function f({
    swiper: t,
    runCallbacks: e,
    direction: i,
    step: s
  }) {
    var {
      activeIndex: n,
      previousIndex: a
    } = t;
    let o = i;
    if (o = o || (a < n ? "next" : n < a ? "prev" : "reset"), t.emit(`transition${s}`), e && n !== a) {
      if ("reset" === o) return t.emit(`slideResetTransition${s}`), 0;
      t.emit(`slideChangeTransition${s}`), "next" === o ? t.emit(`slideNextTransition${s}`) : t.emit(`slidePrevTransition${s}`)
    }
  }

  function m() {
    var t, e, i = this,
      {
        params: s,
        el: n
      } = i;
    n && 0 === n.offsetWidth || (s.breakpoints && i.setBreakpoint(), {
      allowSlideNext: t,
      allowSlidePrev: e,
      snapGrid: n
    } = i, i.allowSlideNext = !0, i.allowSlidePrev = !0, i.updateSize(), i.updateSlides(), i.updateSlidesClasses(), ("auto" === s.slidesPerView || 1 < s.slidesPerView) && i.isEnd && !i.isBeginning && !i.params.centeredSlides ? i.slideTo(i.slides.length - 1, 0, !1, !0) : i.slideTo(i.activeIndex, 0, !1, !0), i.autoplay && i.autoplay.running && i.autoplay.paused && i.autoplay.run(), i.allowSlidePrev = e, i.allowSlideNext = t, i.params.watchOverflow && n !== i.snapGrid && i.checkOverflow())
  }
  Object.keys(l).forEach(t => {
    Object.defineProperty(P.fn, t, {
      value: l[t],
      writable: !0
    })
  });
  let v = !1;

  function _() {}
  const y = (t, e) => {
      const i = x(),
        {
          params: s,
          touchEvents: n,
          el: a,
          wrapperEl: o,
          device: r,
          support: l
        } = t,
        c = !!s.nested,
        d = "on" === e ? "addEventListener" : "removeEventListener",
        h = e;
      if (l.touch) {
        const e = !("touchstart" !== n.start || !l.passiveListener || !s.passiveListeners) && {
          passive: !0,
          capture: !1
        };
        a[d](n.start, t.onTouchStart, e), a[d](n.move, t.onTouchMove, l.passiveListener ? {
          passive: !1,
          capture: c
        } : c), a[d](n.end, t.onTouchEnd, e), n.cancel && a[d](n.cancel, t.onTouchEnd, e)
      } else a[d](n.start, t.onTouchStart, !1), i[d](n.move, t.onTouchMove, c), i[d](n.end, t.onTouchEnd, !1);
      (s.preventClicks || s.preventClicksPropagation) && a[d]("click", t.onClick, !0), s.cssMode && o[d]("scroll", t.onScroll), s.updateOnWindowResize ? t[h](r.ios || r.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", m, !0) : t[h]("observerUpdate", m, !0)
    },
    w = (t, e) => t.grid && e.grid && 1 < e.grid.rows;
  var k = {
    init: !0,
    direction: "horizontal",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 0,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    preloadImages: !0,
    updateOnImagesReady: !0,
    loop: !1,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: !1,
    loopPreventsSlide: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-invisible-blank",
    slideActiveClass: "swiper-slide-active",
    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
    slideVisibleClass: "swiper-slide-visible",
    slideDuplicateClass: "swiper-slide-duplicate",
    slideNextClass: "swiper-slide-next",
    slideDuplicateNextClass: "swiper-slide-duplicate-next",
    slidePrevClass: "swiper-slide-prev",
    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
    wrapperClass: "swiper-wrapper",
    runCallbacksOnInit: !0,
    _emitClasses: !1
  };
  const T = {
      eventsEmitter: {
        on(t, e, i) {
          const s = this;
          if ("function" != typeof e) return s;
          const n = i ? "unshift" : "push";
          return t.split(" ").forEach(t => {
            s.eventsListeners[t] || (s.eventsListeners[t] = []), s.eventsListeners[t][n](e)
          }), s
        },
        once(e, i, t) {
          const s = this;
          return "function" != typeof i ? s : (n.__emitterProxy = i, s.on(e, n, t));

          function n(...t) {
            s.off(e, n), n.__emitterProxy && delete n.__emitterProxy, i.apply(s, t)
          }
        },
        onAny(t, e) {
          if ("function" != typeof t) return this;
          e = e ? "unshift" : "push";
          return this.eventsAnyListeners.indexOf(t) < 0 && this.eventsAnyListeners[e](t), this
        },
        offAny(t) {
          if (!this.eventsAnyListeners) return this;
          t = this.eventsAnyListeners.indexOf(t);
          return 0 <= t && this.eventsAnyListeners.splice(t, 1), this
        },
        off(t, s) {
          const n = this;
          return n.eventsListeners && t.split(" ").forEach(i => {
            void 0 === s ? n.eventsListeners[i] = [] : n.eventsListeners[i] && n.eventsListeners[i].forEach((t, e) => {
              (t === s || t.__emitterProxy && t.__emitterProxy === s) && n.eventsListeners[i].splice(e, 1)
            })
          }), n
        },
        emit(...t) {
          const i = this;
          if (!i.eventsListeners) return i;
          let e, s, n;
          return n = "string" == typeof t[0] || Array.isArray(t[0]) ? (e = t[0], s = t.slice(1, t.length), i) : (e = t[0].events, s = t[0].data, t[0].context || i), s.unshift(n), (Array.isArray(e) ? e : e.split(" ")).forEach(e => {
            i.eventsAnyListeners && i.eventsAnyListeners.length && i.eventsAnyListeners.forEach(t => {
              t.apply(n, [e, ...s])
            }), i.eventsListeners && i.eventsListeners[e] && i.eventsListeners[e].forEach(t => {
              t.apply(n, s)
            })
          }), i
        }
      },
      update: {
        updateSize: function () {
          var t = this;
          let e, i;
          const s = t.$el;
          e = void 0 !== t.params.width && null !== t.params.width ? t.params.width : s[0].clientWidth, i = void 0 !== t.params.height && null !== t.params.height ? t.params.height : s[0].clientHeight, 0 === e && t.isHorizontal() || 0 === i && t.isVertical() || (e = e - parseInt(s.css("padding-left") || 0, 10) - parseInt(s.css("padding-right") || 0, 10), i = i - parseInt(s.css("padding-top") || 0, 10) - parseInt(s.css("padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(i) && (i = 0), Object.assign(t, {
            width: e,
            height: i,
            size: t.isHorizontal() ? e : i
          }))
        },
        updateSlides: function () {
          const i = this;

          function s(t) {
            return i.isHorizontal() ? t : {
              width: "height",
              "margin-top": "margin-left",
              "margin-bottom ": "margin-right",
              "margin-left": "margin-top",
              "margin-right": "margin-bottom",
              "padding-left": "padding-top",
              "padding-right": "padding-bottom",
              marginRight: "marginBottom"
            } [t]
          }

          function n(t, e) {
            return parseFloat(t.getPropertyValue(s(e)) || 0)
          }
          const a = i.params,
            {
              $wrapperEl: o,
              size: r,
              rtlTranslate: l,
              wrongRTL: c
            } = i,
            d = i.virtual && a.virtual.enabled,
            t = (d ? i.virtual : i).slides.length,
            h = o.children(`.${i.params.slideClass}`),
            u = (d ? i.virtual.slides : h).length;
          let p = [];
          const f = [],
            m = [];
          let g = a.slidesOffsetBefore;
          "function" == typeof g && (g = a.slidesOffsetBefore.call(i));
          let v = a.slidesOffsetAfter;
          "function" == typeof v && (v = a.slidesOffsetAfter.call(i));
          var b = i.snapGrid.length,
            _ = i.slidesGrid.length;
          let y = a.spaceBetween,
            w = -g,
            x = 0,
            C = 0;
          if (void 0 !== r) {
            "string" == typeof y && 0 <= y.indexOf("%") && (y = parseFloat(y.replace("%", "")) / 100 * r), i.virtualSize = -y, l ? h.css({
              marginLeft: "",
              marginBottom: "",
              marginTop: ""
            }) : h.css({
              marginRight: "",
              marginBottom: "",
              marginTop: ""
            }), a.centeredSlides && a.cssMode && (D(i.wrapperEl, "--swiper-centered-offset-before", ""), D(i.wrapperEl, "--swiper-centered-offset-after", ""));
            var k = a.grid && 1 < a.grid.rows && i.grid;
            let e;
            k && i.grid.initSlides(u);
            var T = "auto" === a.slidesPerView && a.breakpoints && 0 < Object.keys(a.breakpoints).filter(t => void 0 !== a.breakpoints[t].slidesPerView).length;
            for (let t = 0; t < u; t += 1) {
              e = 0;
              const l = h.eq(t);
              if (k && i.grid.updateSlide(t, l, u, s), "none" !== l.css("display")) {
                if ("auto" === a.slidesPerView) {
                  T && (h[t].style[s("width")] = "");
                  const r = getComputedStyle(l[0]),
                    c = l[0].style.transform,
                    d = l[0].style.webkitTransform;
                  if (c && (l[0].style.transform = "none"), d && (l[0].style.webkitTransform = "none"), a.roundLengths) e = i.isHorizontal() ? l.outerWidth(!0) : l.outerHeight(!0);
                  else {
                    const i = n(r, "width"),
                      s = n(r, "padding-left"),
                      a = n(r, "padding-right"),
                      o = n(r, "margin-left"),
                      c = n(r, "margin-right"),
                      d = r.getPropertyValue("box-sizing");
                    if (d && "border-box" === d) e = i + o + c;
                    else {
                      const {
                        clientWidth: n,
                        offsetWidth: r
                      } = l[0];
                      e = i + s + a + o + c + (r - n)
                    }
                  }
                  c && (l[0].style.transform = c), d && (l[0].style.webkitTransform = d), a.roundLengths && (e = Math.floor(e))
                } else e = (r - (a.slidesPerView - 1) * y) / a.slidesPerView, a.roundLengths && (e = Math.floor(e)), h[t] && (h[t].style[s("width")] = `${e}px`);
                h[t] && (h[t].swiperSlideSize = e), m.push(e), a.centeredSlides ? (w = w + e / 2 + x / 2 + y, 0 === x && 0 !== t && (w = w - r / 2 - y), 0 === t && (w = w - r / 2 - y), Math.abs(w) < .001 && (w = 0), a.roundLengths && (w = Math.floor(w)), C % a.slidesPerGroup == 0 && p.push(w), f.push(w)) : (a.roundLengths && (w = Math.floor(w)), (C - Math.min(i.params.slidesPerGroupSkip, C)) % i.params.slidesPerGroup == 0 && p.push(w), f.push(w), w = w + e + y), i.virtualSize += e + y, x = e, C += 1
              }
            }
            if (i.virtualSize = Math.max(i.virtualSize, r) + v, l && c && ("slide" === a.effect || "coverflow" === a.effect) && o.css({
                width: `${i.virtualSize+a.spaceBetween}px`
              }), a.setWrapperSize && o.css({
                [s("width")]: `${i.virtualSize+a.spaceBetween}px`
              }), k && i.grid.updateWrapperSize(e, p, s), !a.centeredSlides) {
              const s = [];
              for (let e = 0; e < p.length; e += 1) {
                let t = p[e];
                a.roundLengths && (t = Math.floor(t)), p[e] <= i.virtualSize - r && s.push(t)
              }
              p = s, 1 < Math.floor(i.virtualSize - r) - Math.floor(p[p.length - 1]) && p.push(i.virtualSize - r)
            }
            if (0 === p.length && (p = [0]), 0 !== a.spaceBetween) {
              const n = i.isHorizontal() && l ? "marginLeft" : s("marginRight");
              h.filter((t, e) => !a.cssMode || e !== h.length - 1).css({
                [n]: `${y}px`
              })
            }
            if (a.centeredSlides && a.centeredSlidesBounds) {
              let e = 0;
              m.forEach(t => {
                e += t + (a.spaceBetween || 0)
              }), e -= a.spaceBetween;
              const s = e - r;
              p = p.map(t => t < 0 ? -g : t > s ? s + v : t)
            }
            if (a.centerInsufficientSlides) {
              let e = 0;
              if (m.forEach(t => {
                  e += t + (a.spaceBetween || 0)
                }), e -= a.spaceBetween, e < r) {
                const s = (r - e) / 2;
                p.forEach((t, e) => {
                  p[e] = t - s
                }), f.forEach((t, e) => {
                  f[e] = t + s
                })
              }
            }
            if (Object.assign(i, {
                slides: h,
                snapGrid: p,
                slidesGrid: f,
                slidesSizesGrid: m
              }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
              D(i.wrapperEl, "--swiper-centered-offset-before", -p[0] + "px"), D(i.wrapperEl, "--swiper-centered-offset-after", i.size / 2 - m[m.length - 1] / 2 + "px");
              const s = -i.snapGrid[0],
                n = -i.slidesGrid[0];
              i.snapGrid = i.snapGrid.map(t => t + s), i.slidesGrid = i.slidesGrid.map(t => t + n)
            }
            u !== t && i.emit("slidesLengthChange"), p.length !== b && (i.params.watchOverflow && i.checkOverflow(), i.emit("snapGridLengthChange")), f.length !== _ && i.emit("slidesGridLengthChange"), a.watchSlidesProgress && i.updateSlidesOffset()
          }
        },
        updateAutoHeight: function (t) {
          const i = this,
            e = [],
            s = i.virtual && i.params.virtual.enabled;
          let n, a = 0;
          "number" == typeof t ? i.setTransition(t) : !0 === t && i.setTransition(i.params.speed);
          var o = e => (s ? i.slides.filter(t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e) : i.slides.eq(e))[0];
          if ("auto" !== i.params.slidesPerView && 1 < i.params.slidesPerView)
            if (i.params.centeredSlides) i.visibleSlides.each(t => {
              e.push(t)
            });
            else
              for (n = 0; n < Math.ceil(i.params.slidesPerView); n += 1) {
                const t = i.activeIndex + n;
                if (t > i.slides.length && !s) break;
                e.push(o(t))
              } else e.push(o(i.activeIndex));
          for (n = 0; n < e.length; n += 1)
            if (void 0 !== e[n]) {
              const t = e[n].offsetHeight;
              a = t > a ? t : a
            }! a && 0 !== a || i.$wrapperEl.css("height", `${a}px`)
        },
        updateSlidesOffset: function () {
          const e = this.slides;
          for (let t = 0; t < e.length; t += 1) e[t].swiperSlideOffset = this.isHorizontal() ? e[t].offsetLeft : e[t].offsetTop
        },
        updateSlidesProgress: function (t = this && this.translate || 0) {
          const s = this,
            n = s.params,
            {
              slides: a,
              rtlTranslate: o,
              snapGrid: r
            } = s;
          if (0 !== a.length) {
            void 0 === a[0].swiperSlideOffset && s.updateSlidesOffset();
            let i = o ? t : -t;
            a.removeClass(n.slideVisibleClass), s.visibleSlidesIndexes = [], s.visibleSlides = [];
            for (let e = 0; e < a.length; e += 1) {
              const l = a[e];
              let t = l.swiperSlideOffset;
              n.cssMode && n.centeredSlides && (t -= a[0].swiperSlideOffset);
              const P = (i + (n.centeredSlides ? s.minTranslate() : 0) - t) / (l.swiperSlideSize + n.spaceBetween),
                c = (i - r[0] + (n.centeredSlides ? s.minTranslate() : 0) - t) / (l.swiperSlideSize + n.spaceBetween),
                d = -(i - t),
                h = d + s.slidesSizesGrid[e];
              (0 <= d && d < s.size - 1 || 1 < h && h <= s.size || d <= 0 && h >= s.size) && (s.visibleSlides.push(l), s.visibleSlidesIndexes.push(e), a.eq(e).addClass(n.slideVisibleClass)), l.progress = o ? -P : P, l.originalProgress = o ? -c : c
            }
            s.visibleSlides = P(s.visibleSlides)
          }
        },
        updateProgress: function (t) {
          var e = this;
          if (void 0 === t) {
            const i = e.rtlTranslate ? -1 : 1;
            t = e && e.translate && e.translate * i || 0
          }
          const i = e.params,
            s = e.maxTranslate() - e.minTranslate();
          let {
            progress: n,
            isBeginning: a,
            isEnd: o
          } = e;
          var r = a,
            l = o;
          o = 0 == s ? (n = 0, a = !0) : (n = (t - e.minTranslate()) / s, a = n <= 0, 1 <= n), Object.assign(e, {
            progress: n,
            isBeginning: a,
            isEnd: o
          }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && e.updateSlidesProgress(t), a && !r && e.emit("reachBeginning toEdge"), o && !l && e.emit("reachEnd toEdge"), (r && !a || l && !o) && e.emit("fromEdge"), e.emit("progress", n)
        },
        updateSlidesClasses: function () {
          const {
            slides: t,
            params: e,
            $wrapperEl: i,
            activeIndex: s,
            realIndex: n
          } = this, a = this.virtual && e.virtual.enabled;
          let o;
          t.removeClass(`${e.slideActiveClass} ${e.slideNextClass} ${e.slidePrevClass} ${e.slideDuplicateActiveClass} ${e.slideDuplicateNextClass} ${e.slideDuplicatePrevClass}`), o = a ? this.$wrapperEl.find(`.${e.slideClass}[data-swiper-slide-index="${s}"]`) : t.eq(s), o.addClass(e.slideActiveClass), e.loop && (o.hasClass(e.slideDuplicateClass) ? i.children(`.${e.slideClass}:not(.${e.slideDuplicateClass})[data-swiper-slide-index="${n}"]`) : i.children(`.${e.slideClass}.${e.slideDuplicateClass}[data-swiper-slide-index="${n}"]`)).addClass(e.slideDuplicateActiveClass);
          let r = o.nextAll(`.${e.slideClass}`).eq(0).addClass(e.slideNextClass);
          e.loop && 0 === r.length && (r = t.eq(0), r.addClass(e.slideNextClass));
          let l = o.prevAll(`.${e.slideClass}`).eq(0).addClass(e.slidePrevClass);
          e.loop && 0 === l.length && (l = t.eq(-1), l.addClass(e.slidePrevClass)), e.loop && ((r.hasClass(e.slideDuplicateClass) ? i.children(`.${e.slideClass}:not(.${e.slideDuplicateClass})[data-swiper-slide-index="${r.attr("data-swiper-slide-index")}"]`) : i.children(`.${e.slideClass}.${e.slideDuplicateClass}[data-swiper-slide-index="${r.attr("data-swiper-slide-index")}"]`)).addClass(e.slideDuplicateNextClass), (l.hasClass(e.slideDuplicateClass) ? i.children(`.${e.slideClass}:not(.${e.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`) : i.children(`.${e.slideClass}.${e.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`)).addClass(e.slideDuplicatePrevClass)), this.emitSlidesClasses()
        },
        updateActiveIndex: function (t) {
          const e = this,
            i = e.rtlTranslate ? e.translate : -e.translate,
            {
              slidesGrid: s,
              snapGrid: n,
              params: a,
              activeIndex: o,
              realIndex: r,
              snapIndex: l
            } = e;
          let c, d = t;
          if (void 0 === d) {
            for (let t = 0; t < s.length; t += 1) void 0 !== s[t + 1] ? i >= s[t] && i < s[t + 1] - (s[t + 1] - s[t]) / 2 ? d = t : i >= s[t] && i < s[t + 1] && (d = t + 1) : i >= s[t] && (d = t);
            a.normalizeSlideIndex && (d < 0 || void 0 === d) && (d = 0)
          }
          if (0 <= n.indexOf(i)) c = n.indexOf(i);
          else {
            const h = Math.min(a.slidesPerGroupSkip, d);
            c = h + Math.floor((d - h) / a.slidesPerGroup)
          }
          c >= n.length && (c = n.length - 1), d !== o ? (t = parseInt(e.slides.eq(d).attr("data-swiper-slide-index") || d, 10), Object.assign(e, {
            snapIndex: c,
            realIndex: t,
            previousIndex: o,
            activeIndex: d
          }), e.emit("activeIndexChange"), e.emit("snapIndexChange"), r !== t && e.emit("realIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange")) : c !== l && (e.snapIndex = c, e.emit("snapIndexChange"))
        },
        updateClickedSlide: function (t) {
          var e = this,
            i = e.params,
            s = P(t).closest(`.${i.slideClass}`)[0];
          let n, a = !1;
          if (s)
            for (let t = 0; t < e.slides.length; t += 1)
              if (e.slides[t] === s) {
                a = !0, n = t;
                break
              } if (!s || !a) return e.clickedSlide = void 0, void(e.clickedIndex = void 0);
          e.clickedSlide = s, e.virtual && e.params.virtual.enabled ? e.clickedIndex = parseInt(P(s).attr("data-swiper-slide-index"), 10) : e.clickedIndex = n, i.slideToClickedSlide && void 0 !== e.clickedIndex && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide()
        }
      },
      translate: {
        getTranslate: function (t = this.isHorizontal() ? "x" : "y") {
          var {
            params: e,
            rtlTranslate: i,
            translate: s,
            $wrapperEl: n
          } = this;
          if (e.virtualTranslate) return i ? -s : s;
          if (e.cssMode) return s;
          let a = I(n[0], t);
          return i && (a = -a), a || 0
        },
        setTranslate: function (t, e) {
          const i = this,
            {
              rtlTranslate: s,
              params: n,
              $wrapperEl: a,
              wrapperEl: o,
              progress: r
            } = i;
          let l = 0,
            c = 0;
          i.isHorizontal() ? l = s ? -t : t : c = t, n.roundLengths && (l = Math.floor(l), c = Math.floor(c)), n.cssMode ? o[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -l : -c : n.virtualTranslate || a.transform(`translate3d(${l}px, ${c}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? l : c;
          var d = i.maxTranslate() - i.minTranslate();
          (0 == d ? 0 : (t - i.minTranslate()) / d) !== r && i.updateProgress(t), i.emit("setTranslate", i.translate, e)
        },
        minTranslate: function () {
          return -this.snapGrid[0]
        },
        maxTranslate: function () {
          return -this.snapGrid[this.snapGrid.length - 1]
        },
        translateTo: function (t = 0, e = this.params.speed, i = !0, s = !0, n) {
          const a = this,
            {
              params: o,
              wrapperEl: r
            } = a;
          if (a.animating && o.preventInteractionOnTransition) return !1;
          var l = a.minTranslate(),
            c = a.maxTranslate(),
            t = s && l < t ? l : s && t < c ? c : t;
          if (a.updateProgress(t), o.cssMode) {
            const d = a.isHorizontal();
            if (0 === e) r[d ? "scrollLeft" : "scrollTop"] = -t;
            else {
              if (!a.support.smoothScroll) return b({
                swiper: a,
                targetPosition: -t,
                side: d ? "left" : "top"
              }), !0;
              r.scrollTo({
                [d ? "left" : "top"]: -t,
                behavior: "smooth"
              })
            }
            return !0
          }
          return 0 === e ? (a.setTransition(0), a.setTranslate(t), i && (a.emit("beforeTransitionStart", e, n), a.emit("transitionEnd"))) : (a.setTransition(e), a.setTranslate(t), i && (a.emit("beforeTransitionStart", e, n), a.emit("transitionStart")), a.animating || (a.animating = !0, a.onTranslateToWrapperTransitionEnd || (a.onTranslateToWrapperTransitionEnd = function (t) {
            a && !a.destroyed && t.target === this && (a.$wrapperEl[0].removeEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.$wrapperEl[0].removeEventListener("webkitTransitionEnd", a.onTranslateToWrapperTransitionEnd), a.onTranslateToWrapperTransitionEnd = null, delete a.onTranslateToWrapperTransitionEnd, i && a.emit("transitionEnd"))
          }), a.$wrapperEl[0].addEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.$wrapperEl[0].addEventListener("webkitTransitionEnd", a.onTranslateToWrapperTransitionEnd))), !0
        }
      },
      transition: {
        setTransition: function (t, e) {
          this.params.cssMode || this.$wrapperEl.transition(t), this.emit("setTransition", t, e)
        },
        transitionStart: function (t = !0, e) {
          var {
            params: i
          } = this;
          i.cssMode || (i.autoHeight && this.updateAutoHeight(), f({
            swiper: this,
            runCallbacks: t,
            direction: e,
            step: "Start"
          }))
        },
        transitionEnd: function (t = !0, e) {
          var {
            params: i
          } = this;
          this.animating = !1, i.cssMode || (this.setTransition(0), f({
            swiper: this,
            runCallbacks: t,
            direction: e,
            step: "End"
          }))
        }
      },
      slide: {
        slideTo: function (t = 0, e = this.params.speed, i = !0, s, n) {
          if ("number" != typeof t && "string" != typeof t) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof t}] given.`);
          if ("string" == typeof t) {
            const e = parseInt(t, 10);
            if (!isFinite(e)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
            t = e
          }
          const a = this;
          let o = t;
          o < 0 && (o = 0);
          const {
            params: r,
            snapGrid: l,
            slidesGrid: c,
            previousIndex: d,
            activeIndex: h,
            rtlTranslate: u,
            wrapperEl: p,
            enabled: f
          } = a;
          if (a.animating && r.preventInteractionOnTransition || !f && !s && !n) return !1;
          n = Math.min(a.params.slidesPerGroupSkip, o);
          let m = n + Math.floor((o - n) / a.params.slidesPerGroup);
          m >= l.length && (m = l.length - 1), (h || r.initialSlide || 0) === (d || 0) && i && a.emit("beforeSlideChangeStart");
          var g = -l[m];
          if (a.updateProgress(g), r.normalizeSlideIndex)
            for (let t = 0; t < c.length; t += 1) {
              const e = -Math.floor(100 * g),
                i = Math.floor(100 * c[t]),
                s = Math.floor(100 * c[t + 1]);
              void 0 !== c[t + 1] ? e >= i && e < s - (s - i) / 2 ? o = t : e >= i && e < s && (o = t + 1) : e >= i && (o = t)
            }
          if (a.initialized && o !== h) {
            if (!a.allowSlideNext && g < a.translate && g < a.minTranslate()) return !1;
            if (!a.allowSlidePrev && g > a.translate && g > a.maxTranslate() && (h || 0) !== o) return !1
          }
          let v;
          if (v = o > h ? "next" : o < h ? "prev" : "reset", u && -g === a.translate || !u && g === a.translate) return a.updateActiveIndex(o), r.autoHeight && a.updateAutoHeight(), a.updateSlidesClasses(), "slide" !== r.effect && a.setTranslate(g), "reset" != v && (a.transitionStart(i, v), a.transitionEnd(i, v)), !1;
          if (r.cssMode) {
            const t = a.isHorizontal(),
              i = u ? g : -g;
            if (0 === e) {
              const e = a.virtual && a.params.virtual.enabled;
              e && (a.wrapperEl.style.scrollSnapType = "none", a._immediateVirtual = !0), p[t ? "scrollLeft" : "scrollTop"] = i, e && requestAnimationFrame(() => {
                a.wrapperEl.style.scrollSnapType = "", a._swiperImmediateVirtual = !1
              })
            } else {
              if (!a.support.smoothScroll) return b({
                swiper: a,
                targetPosition: i,
                side: t ? "left" : "top"
              }), !0;
              p.scrollTo({
                [t ? "left" : "top"]: i,
                behavior: "smooth"
              })
            }
            return !0
          }
          return a.setTransition(e), a.setTranslate(g), a.updateActiveIndex(o), a.updateSlidesClasses(), a.emit("beforeTransitionStart", e, s), a.transitionStart(i, v), 0 === e ? a.transitionEnd(i, v) : a.animating || (a.animating = !0, a.onSlideToWrapperTransitionEnd || (a.onSlideToWrapperTransitionEnd = function (t) {
            a && !a.destroyed && t.target === this && (a.$wrapperEl[0].removeEventListener("transitionend", a.onSlideToWrapperTransitionEnd), a.$wrapperEl[0].removeEventListener("webkitTransitionEnd", a.onSlideToWrapperTransitionEnd), a.onSlideToWrapperTransitionEnd = null, delete a.onSlideToWrapperTransitionEnd, a.transitionEnd(i, v))
          }), a.$wrapperEl[0].addEventListener("transitionend", a.onSlideToWrapperTransitionEnd), a.$wrapperEl[0].addEventListener("webkitTransitionEnd", a.onSlideToWrapperTransitionEnd)), !0
        },
        slideToLoop: function (t = 0, e = this.params.speed, i = !0, s) {
          let n = t;
          return this.params.loop && (n += this.loopedSlides), this.slideTo(n, e, i, s)
        },
        slideNext: function (t = this.params.speed, e = !0, i) {
          var s = this,
            {
              animating: n,
              enabled: a,
              params: o
            } = s;
          if (!a) return s;
          let r = o.slidesPerGroup;
          "auto" === o.slidesPerView && 1 === o.slidesPerGroup && o.slidesPerGroupAuto && (r = Math.max(s.slidesPerViewDynamic("current", !0), 1));
          a = s.activeIndex < o.slidesPerGroupSkip ? 1 : r;
          if (o.loop) {
            if (n && o.loopPreventsSlide) return !1;
            s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft
          }
          return o.rewind && s.isEnd ? s.slideTo(0, t, e, i) : s.slideTo(s.activeIndex + a, t, e, i)
        },
        slidePrev: function (t = this.params.speed, e = !0, i) {
          const s = this,
            {
              params: n,
              animating: a,
              snapGrid: o,
              slidesGrid: r,
              rtlTranslate: l,
              enabled: c
            } = s;
          if (!c) return s;
          if (n.loop) {
            if (a && n.loopPreventsSlide) return !1;
            s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft
          }

          function d(t) {
            return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t)
          }
          const h = d(l ? s.translate : -s.translate),
            u = o.map(t => d(t));
          let p = o[u.indexOf(h) - 1];
          if (void 0 === p && n.cssMode) {
            let i;
            o.forEach((t, e) => {
              h >= t && (i = e)
            }), void 0 !== i && (p = o[0 < i ? i - 1 : i])
          }
          let f = 0;
          return void 0 !== p && (f = r.indexOf(p), f < 0 && (f = s.activeIndex - 1), "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (f = f - s.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), n.rewind && s.isBeginning ? s.slideTo(s.slides.length - 1, t, e, i) : s.slideTo(f, t, e, i)
        },
        slideReset: function (t = this.params.speed, e = !0, i) {
          return this.slideTo(this.activeIndex, t, e, i)
        },
        slideToClosest: function (t = this.params.speed, e = !0, i, s = .5) {
          var n = this;
          let a = n.activeIndex;
          var o = Math.min(n.params.slidesPerGroupSkip, a),
            r = o + Math.floor((a - o) / n.params.slidesPerGroup),
            o = n.rtlTranslate ? n.translate : -n.translate;
          if (o >= n.snapGrid[r]) {
            const t = n.snapGrid[r];
            o - t > (n.snapGrid[r + 1] - t) * s && (a += n.params.slidesPerGroup)
          } else {
            const t = n.snapGrid[r - 1];
            o - t <= (n.snapGrid[r] - t) * s && (a -= n.params.slidesPerGroup)
          }
          return a = Math.max(a, 0), a = Math.min(a, n.slidesGrid.length - 1), n.slideTo(a, t, e, i)
        },
        slideToClickedSlide: function () {
          const t = this,
            {
              params: e,
              $wrapperEl: i
            } = t,
            s = "auto" === e.slidesPerView ? t.slidesPerViewDynamic() : e.slidesPerView;
          let n, a = t.clickedIndex;
          e.loop ? t.animating || (n = parseInt(P(t.clickedSlide).attr("data-swiper-slide-index"), 10), e.centeredSlides ? a < t.loopedSlides - s / 2 || a > t.slides.length - t.loopedSlides + s / 2 ? (t.loopFix(), a = i.children(`.${e.slideClass}[data-swiper-slide-index="${n}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), C(() => {
            t.slideTo(a)
          })) : t.slideTo(a) : a > t.slides.length - s ? (t.loopFix(), a = i.children(`.${e.slideClass}[data-swiper-slide-index="${n}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), C(() => {
            t.slideTo(a)
          })) : t.slideTo(a)) : t.slideTo(a)
        }
      },
      loop: {
        loopCreate: function () {
          const s = this,
            e = x(),
            {
              params: i,
              $wrapperEl: t
            } = s,
            n = 0 < t.children().length ? P(t.children()[0].parentNode) : t;
          n.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove();
          let a = n.children(`.${i.slideClass}`);
          if (i.loopFillGroupWithBlank) {
            const s = i.slidesPerGroup - a.length % i.slidesPerGroup;
            if (s !== i.slidesPerGroup) {
              for (let t = 0; t < s; t += 1) {
                const s = P(e.createElement("div")).addClass(`${i.slideClass} ${i.slideBlankClass}`);
                n.append(s)
              }
              a = n.children(`.${i.slideClass}`)
            }
          }
          "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = a.length), s.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10)), s.loopedSlides += i.loopAdditionalSlides, s.loopedSlides > a.length && (s.loopedSlides = a.length);
          const o = [],
            r = [];
          a.each((t, e) => {
            const i = P(t);
            e < s.loopedSlides && r.push(t), e < a.length && e >= a.length - s.loopedSlides && o.push(t), i.attr("data-swiper-slide-index", e)
          });
          for (let t = 0; t < r.length; t += 1) n.append(P(r[t].cloneNode(!0)).addClass(i.slideDuplicateClass));
          for (let t = o.length - 1; 0 <= t; --t) n.prepend(P(o[t].cloneNode(!0)).addClass(i.slideDuplicateClass))
        },
        loopFix: function () {
          var t = this;
          t.emit("beforeLoopFix");
          var {
            activeIndex: e,
            slides: i,
            loopedSlides: s,
            allowSlidePrev: n,
            allowSlideNext: a,
            snapGrid: o,
            rtlTranslate: r
          } = t;
          let l;
          t.allowSlidePrev = !0, t.allowSlideNext = !0;
          o = -o[e] - t.getTranslate();
          e < s ? (l = i.length - 3 * s + e, l += s, t.slideTo(l, 0, !1, !0) && 0 != o && t.setTranslate((r ? -t.translate : t.translate) - o)) : e >= i.length - s && (l = -i.length + e + s, l += s, t.slideTo(l, 0, !1, !0) && 0 != o && t.setTranslate((r ? -t.translate : t.translate) - o)), t.allowSlidePrev = n, t.allowSlideNext = a, t.emit("loopFix")
        },
        loopDestroy: function () {
          const {
            $wrapperEl: t,
            params: e,
            slides: i
          } = this;
          t.children(`.${e.slideClass}.${e.slideDuplicateClass},.${e.slideClass}.${e.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index")
        }
      },
      grabCursor: {
        setGrabCursor: function (t) {
          if (!(this.support.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode)) {
            const e = "container" === this.params.touchEventsTarget ? this.el : this.wrapperEl;
            e.style.cursor = "move", e.style.cursor = t ? "-webkit-grabbing" : "-webkit-grab", e.style.cursor = t ? "-moz-grabbin" : "-moz-grab", e.style.cursor = t ? "grabbing" : "grab"
          }
        },
        unsetGrabCursor: function () {
          this.support.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this["container" === this.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
        }
      },
      events: {
        attachEvents: function () {
          const t = this,
            e = x(),
            {
              params: i,
              support: s
            } = t;
          t.onTouchStart = function (t) {
            const s = this,
              n = x(),
              a = A(),
              o = s.touchEventsData,
              {
                params: r,
                touches: l,
                enabled: e
              } = s;
            if (e && (!s.animating || !r.preventInteractionOnTransition)) {
              !s.animating && r.cssMode && r.loop && s.loopFix();
              let e = t;
              e.originalEvent && (e = e.originalEvent);
              let i = P(e.target);
              if (("wrapper" !== r.touchEventsTarget || i.closest(s.wrapperEl).length) && (o.isTouchEvent = "touchstart" === e.type, (o.isTouchEvent || !("which" in e) || 3 !== e.which) && !(!o.isTouchEvent && "button" in e && 0 < e.button || o.isTouched && o.isMoved))) {
                r.noSwipingClass && "" !== r.noSwipingClass && e.target && e.target.shadowRoot && t.path && t.path[0] && (i = P(t.path[0]));
                var c = r.noSwipingSelector || `.${r.noSwipingClass}`,
                  d = !(!e.target || !e.target.shadowRoot);
                if (r.noSwiping && (d ? function (i, t = this) {
                    return function t(e) {
                      return e && e !== x() && e !== A() ? (e = e.assignedSlot ? e.assignedSlot : e).closest(i) || t(e.getRootNode().host) : null
                    }(t)
                  }(c, e.target) : i.closest(c)[0])) s.allowClick = !0;
                else if (!r.swipeHandler || i.closest(r.swipeHandler)[0]) {
                  l.currentX = ("touchstart" === e.type ? e.targetTouches[0] : e).pageX, l.currentY = ("touchstart" === e.type ? e.targetTouches[0] : e).pageY;
                  var h = l.currentX,
                    u = l.currentY,
                    d = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection,
                    c = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold;
                  if (d && (h <= c || h >= a.innerWidth - c)) {
                    if ("prevent" !== d) return;
                    t.preventDefault()
                  }
                  if (Object.assign(o, {
                      isTouched: !0,
                      isMoved: !1,
                      allowTouchCallbacks: !0,
                      isScrolling: void 0,
                      startMoving: void 0
                    }), l.startX = h, l.startY = u, o.touchStartTime = g(), s.allowClick = !0, s.updateSize(), s.swipeDirection = void 0, 0 < r.threshold && (o.allowThresholdMove = !1), "touchstart" !== e.type) {
                    let t = !0;
                    i.is(o.focusableElements) && (t = !1), n.activeElement && P(n.activeElement).is(o.focusableElements) && n.activeElement !== i[0] && n.activeElement.blur();
                    const x = t && s.allowTouchMove && r.touchStartPreventDefault;
                    !r.touchStartForcePreventDefault && !x || i[0].isContentEditable || e.preventDefault()
                  }
                  s.emit("touchStart", e)
                }
              }
            }
          }.bind(t), t.onTouchMove = function (t) {
            const e = x(),
              n = this,
              a = n.touchEventsData,
              {
                params: o,
                touches: r,
                rtlTranslate: l,
                enabled: i
              } = n;
            if (i) {
              let s = t;
              if (s.originalEvent && (s = s.originalEvent), a.isTouched) {
                if (!a.isTouchEvent || "touchmove" === s.type) {
                  var c = "touchmove" === s.type && s.targetTouches && (s.targetTouches[0] || s.changedTouches[0]),
                    d = ("touchmove" === s.type ? c : s).pageX,
                    t = ("touchmove" === s.type ? c : s).pageY;
                  if (s.preventedByNestedSwiper) return r.startX = d, void(r.startY = t);
                  if (!n.allowTouchMove) return n.allowClick = !1, void(a.isTouched && (Object.assign(r, {
                    startX: d,
                    startY: t,
                    currentX: d,
                    currentY: t
                  }), a.touchStartTime = g()));
                  if (a.isTouchEvent && o.touchReleaseOnEdges && !o.loop)
                    if (n.isVertical()) {
                      if (t < r.startY && n.translate <= n.maxTranslate() || t > r.startY && n.translate >= n.minTranslate()) return a.isTouched = !1, void(a.isMoved = !1)
                    } else if (d < r.startX && n.translate <= n.maxTranslate() || d > r.startX && n.translate >= n.minTranslate()) return;
                  if (a.isTouchEvent && e.activeElement && s.target === e.activeElement && P(s.target).is(a.focusableElements)) return a.isMoved = !0, void(n.allowClick = !1);
                  if (a.allowTouchCallbacks && n.emit("touchMove", s), !(s.targetTouches && 1 < s.targetTouches.length)) {
                    r.currentX = d, r.currentY = t;
                    c = r.currentX - r.startX, d = r.currentY - r.startY;
                    if (!(n.params.threshold && Math.sqrt(c ** 2 + d ** 2) < n.params.threshold))
                      if (void 0 === a.isScrolling && (n.isHorizontal() && r.currentY === r.startY || n.isVertical() && r.currentX === r.startX ? a.isScrolling = !1 : 25 <= c * c + d * d && (t = 180 * Math.atan2(Math.abs(d), Math.abs(c)) / Math.PI, a.isScrolling = n.isHorizontal() ? t > o.touchAngle : 90 - t > o.touchAngle)), a.isScrolling && n.emit("touchMoveOpposite", s), void 0 === a.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (a.startMoving = !0)), a.isScrolling) a.isTouched = !1;
                      else if (a.startMoving) {
                      n.allowClick = !1, !o.cssMode && s.cancelable && s.preventDefault(), o.touchMoveStopPropagation && !o.nested && s.stopPropagation(), a.isMoved || (o.loop && !o.cssMode && n.loopFix(), a.startTranslate = n.getTranslate(), n.setTransition(0), n.animating && n.$wrapperEl.trigger("webkitTransitionEnd transitionend"), a.allowMomentumBounce = !1, !o.grabCursor || !0 !== n.allowSlideNext && !0 !== n.allowSlidePrev || n.setGrabCursor(!0), n.emit("sliderFirstMove", s)), n.emit("sliderMove", s), a.isMoved = !0;
                      let t = n.isHorizontal() ? c : d;
                      r.diff = t, t *= o.touchRatio, l && (t = -t), n.swipeDirection = 0 < t ? "prev" : "next", a.currentTranslate = t + a.startTranslate;
                      let e = !0,
                        i = o.resistanceRatio;
                      if (o.touchReleaseOnEdges && (i = 0), 0 < t && a.currentTranslate > n.minTranslate() ? (e = !1, o.resistance && (a.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + a.startTranslate + t) ** i)) : t < 0 && a.currentTranslate < n.maxTranslate() && (e = !1, o.resistance && (a.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - a.startTranslate - t) ** i)), e && (s.preventedByNestedSwiper = !0), !n.allowSlideNext && "next" === n.swipeDirection && a.currentTranslate < a.startTranslate && (a.currentTranslate = a.startTranslate), !n.allowSlidePrev && "prev" === n.swipeDirection && a.currentTranslate > a.startTranslate && (a.currentTranslate = a.startTranslate), n.allowSlidePrev || n.allowSlideNext || (a.currentTranslate = a.startTranslate), 0 < o.threshold) {
                        if (!(Math.abs(t) > o.threshold || a.allowThresholdMove)) return void(a.currentTranslate = a.startTranslate);
                        if (!a.allowThresholdMove) return a.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, a.currentTranslate = a.startTranslate, void(r.diff = n.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY)
                      }
                      o.followFinger && !o.cssMode && ((o.freeMode && o.freeMode.enabled && n.freeMode || o.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), n.params.freeMode && o.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(a.currentTranslate), n.setTranslate(a.currentTranslate))
                    }
                  }
                }
              } else a.startMoving && a.isScrolling && n.emit("touchMoveOpposite", s)
            }
          }.bind(t), t.onTouchEnd = function (s) {
            const n = this,
              e = n.touchEventsData,
              {
                params: a,
                touches: i,
                rtlTranslate: o,
                slidesGrid: r,
                enabled: t
              } = n;
            if (t) {
              let t = s;
              if (t.originalEvent && (t = t.originalEvent), e.allowTouchCallbacks && n.emit("touchEnd", t), e.allowTouchCallbacks = !1, !e.isTouched) return e.isMoved && a.grabCursor && n.setGrabCursor(!1), e.isMoved = !1, void(e.startMoving = !1);
              a.grabCursor && e.isMoved && e.isTouched && (!0 === n.allowSlideNext || !0 === n.allowSlidePrev) && n.setGrabCursor(!1);
              var l, c = g(),
                d = c - e.touchStartTime;
              if (n.allowClick) {
                const h = t.path || t.composedPath && t.composedPath();
                n.updateClickedSlide(h && h[0] || t.target), n.emit("tap click", t), d < 300 && c - e.lastClickTime < 300 && n.emit("doubleTap doubleClick", t)
              }
              if (e.lastClickTime = g(), C(() => {
                  n.destroyed || (n.allowClick = !0)
                }), !e.isTouched || !e.isMoved || !n.swipeDirection || 0 === i.diff || e.currentTranslate === e.startTranslate) return e.isTouched = !1, e.isMoved = !1, void(e.startMoving = !1);
              if (e.isTouched = !1, e.isMoved = !1, e.startMoving = !1, l = a.followFinger ? o ? n.translate : -n.translate : -e.currentTranslate, !a.cssMode)
                if (n.params.freeMode && a.freeMode.enabled) n.freeMode.onTouchEnd({
                  currentPos: l
                });
                else {
                  let e = 0,
                    i = n.slidesSizesGrid[0];
                  for (let t = 0; t < r.length; t += t < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
                    const n = t < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
                    void 0 !== r[t + n] ? l >= r[t] && l < r[t + n] && (e = t, i = r[t + n] - r[t]) : l >= r[t] && (e = t, i = r[r.length - 1] - r[r.length - 2])
                  }
                  s = (l - r[e]) / i, c = e < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
                  d > a.longSwipesMs ? a.longSwipes ? ("next" === n.swipeDirection && (s >= a.longSwipesRatio ? n.slideTo(e + c) : n.slideTo(e)), "prev" === n.swipeDirection && (s > 1 - a.longSwipesRatio ? n.slideTo(e + c) : n.slideTo(e))) : n.slideTo(n.activeIndex) : a.shortSwipes ? !n.navigation || t.target !== n.navigation.nextEl && t.target !== n.navigation.prevEl ? ("next" === n.swipeDirection && n.slideTo(e + c), "prev" === n.swipeDirection && n.slideTo(e)) : t.target === n.navigation.nextEl ? n.slideTo(e + c) : n.slideTo(e) : n.slideTo(n.activeIndex)
                }
            }
          }.bind(t), i.cssMode && (t.onScroll = function () {
            var t = this,
              {
                wrapperEl: e,
                rtlTranslate: i,
                enabled: s
              } = t;
            s && (t.previousTranslate = t.translate, t.isHorizontal() ? t.translate = -e.scrollLeft : t.translate = -e.scrollTop, -0 === t.translate && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses(), (0 == (e = t.maxTranslate() - t.minTranslate()) ? 0 : (t.translate - t.minTranslate()) / e) !== t.progress && t.updateProgress(i ? -t.translate : t.translate), t.emit("setTranslate", t.translate, !1))
          }.bind(t)), t.onClick = function (t) {
            this.enabled && (this.allowClick || (this.params.preventClicks && t.preventDefault(), this.params.preventClicksPropagation && this.animating && (t.stopPropagation(), t.stopImmediatePropagation())))
          }.bind(t), s.touch && !v && (e.addEventListener("touchstart", _), v = !0), y(t, "on")
        },
        detachEvents: function () {
          y(this, "off")
        }
      },
      breakpoints: {
        setBreakpoint: function () {
          const t = this,
            {
              activeIndex: e,
              initialized: i,
              loopedSlides: s = 0,
              params: n,
              $el: a
            } = t,
            o = n.breakpoints;
          var r, l, c, d, h;
          !o || o && 0 === Object.keys(o).length || (r = t.getBreakpoint(o, t.params.breakpointsBase, t.el)) && t.currentBreakpoint !== r && (l = (r in o ? o[r] : void 0) || t.originalParams, h = w(t, n), d = w(t, l), c = n.enabled, h && !d ? (a.removeClass(`${n.containerModifierClass}grid ${n.containerModifierClass}grid-column`), t.emitContainerClasses()) : !h && d && (a.addClass(`${n.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === n.grid.fill) && a.addClass(`${n.containerModifierClass}grid-column`), t.emitContainerClasses()), h = l.direction && l.direction !== n.direction, d = n.loop && (l.slidesPerView !== n.slidesPerView || h), h && i && t.changeDirection(), u(t.params, l), h = t.params.enabled, Object.assign(t, {
            allowTouchMove: t.params.allowTouchMove,
            allowSlideNext: t.params.allowSlideNext,
            allowSlidePrev: t.params.allowSlidePrev
          }), c && !h ? t.disable() : !c && h && t.enable(), t.currentBreakpoint = r, t.emit("_beforeBreakpoint", l), d && i && (t.loopDestroy(), t.loopCreate(), t.updateSlides(), t.slideTo(e - s + t.loopedSlides, 0, !1)), t.emit("breakpoint", l))
        },
        getBreakpoint: function (t, i = "window", s) {
          if (t && ("container" !== i || s)) {
            let e = !1;
            const n = A(),
              a = "window" === i ? n.innerHeight : s.clientHeight,
              o = Object.keys(t).map(t => {
                if ("string" != typeof t || 0 !== t.indexOf("@")) return {
                  value: t,
                  point: t
                };
                var e = parseFloat(t.substr(1));
                return {
                  value: a * e,
                  point: t
                }
              });
            o.sort((t, e) => parseInt(t.value, 10) - parseInt(e.value, 10));
            for (let t = 0; t < o.length; t += 1) {
              const {
                point: A,
                value: a
              } = o[t];
              "window" === i ? n.matchMedia(`(min-width: ${a}px)`).matches && (e = A) : a <= s.clientWidth && (e = A)
            }
            return e || "max"
          }
        }
      },
      checkOverflow: {
        checkOverflow: function () {
          const t = this,
            {
              isLocked: e,
              params: i
            } = t,
            {
              slidesOffsetBefore: s
            } = i;
          if (s) {
            const e = t.slides.length - 1,
              i = t.slidesGrid[e] + t.slidesSizesGrid[e] + 2 * s;
            t.isLocked = t.size > i
          } else t.isLocked = 1 === t.snapGrid.length;
          !0 === i.allowSlideNext && (t.allowSlideNext = !t.isLocked), !0 === i.allowSlidePrev && (t.allowSlidePrev = !t.isLocked), e && e !== t.isLocked && (t.isEnd = !1), e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock")
        }
      },
      classes: {
        addClasses: function () {
          const {
            classNames: t,
            params: e,
            rtl: i,
            $el: s,
            device: n,
            support: a
          } = this, o = function (t, i) {
            const s = [];
            return t.forEach(e => {
              "object" == typeof e ? Object.keys(e).forEach(t => {
                e[t] && s.push(i + t)
              }) : "string" == typeof e && s.push(i + e)
            }), s
          }(["initialized", e.direction, {
            "pointer-events": !a.touch
          }, {
            "free-mode": this.params.freeMode && e.freeMode.enabled
          }, {
            autoheight: e.autoHeight
          }, {
            rtl: i
          }, {
            grid: e.grid && 1 < e.grid.rows
          }, {
            "grid-column": e.grid && 1 < e.grid.rows && "column" === e.grid.fill
          }, {
            android: n.android
          }, {
            ios: n.ios
          }, {
            "css-mode": e.cssMode
          }, {
            centered: e.cssMode && e.centeredSlides
          }], e.containerModifierClass);
          t.push(...o), s.addClass([...t].join(" ")), this.emitContainerClasses()
        },
        removeClasses: function () {
          const {
            $el: t,
            classNames: e
          } = this;
          t.removeClass(e.join(" ")), this.emitContainerClasses()
        }
      },
      images: {
        loadImage: function (t, e, i, s, n, a) {
          const o = A();
          let r;

          function l() {
            a && a()
          }!(P(t).parent("picture")[0] || t.complete && n) && e ? (r = new o.Image, r.onload = l, r.onerror = l, s && (r.sizes = s), i && (r.srcset = i), e && (r.src = e)) : l()
        },
        preloadImages: function () {
          const e = this;

          function i() {
            null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
          }
          e.imagesToLoad = e.$el.find("img");
          for (let t = 0; t < e.imagesToLoad.length; t += 1) {
            const s = e.imagesToLoad[t];
            e.loadImage(s, s.currentSrc || s.getAttribute("src"), s.srcset || s.getAttribute("srcset"), s.sizes || s.getAttribute("sizes"), !0, i)
          }
        }
      }
    },
    S = {};
  class M {
    constructor(...t) {
      let e, i;
      if (1 === t.length && t[0].constructor && "Object" === Object.prototype.toString.call(t[0]).slice(8, -1) ? i = t[0] : [e, i] = t, i = i || {}, i = u({}, i), e && !i.el && (i.el = e), i.el && 1 < P(i.el).length) {
        const n = [];
        return P(i.el).each(t => {
          t = u({}, i, {
            el: t
          });
          n.push(new M(t))
        }), n
      }
      const a = this;
      a.__swiper__ = !0, a.support = p(), a.device = (s = {
        userAgent: i.userAgent
      }, d = d || function ({
        userAgent: t
      } = {}) {
        const e = p(),
          i = A(),
          s = i.navigator.platform,
          n = t || i.navigator.userAgent,
          a = {
            ios: !1,
            android: !1
          },
          o = i.screen.width,
          r = i.screen.height,
          l = n.match(/(Android);?[\s\/]+([\d.]+)?/);
        let c = n.match(/(iPad).*OS\s([\d_]+)/);
        var d = n.match(/(iPod)(.*OS\s([\d_]+))?/),
          h = !c && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
          t = "Win32" === s;
        let u = "MacIntel" === s;
        return !c && u && e.touch && 0 <= ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${r}`) && (c = n.match(/(Version)\/([\d.]+)/), c = c || [0, 1, "13_0_0"], u = !1), l && !t && (a.os = "android", a.android = !0), (c || h || d) && (a.os = "ios", a.ios = !0), a
      }(s), d), a.browser = (h = h || function () {
        const e = A();
        return {
          isSafari: function () {
            const t = e.navigator.userAgent.toLowerCase();
            return 0 <= t.indexOf("safari") && t.indexOf("chrome") < 0 && t.indexOf("android") < 0
          }(),
          isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)
        }
      }(), h), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], i.modules && Array.isArray(i.modules) && a.modules.push(...i.modules);
      const o = {};
      a.modules.forEach(t => {
        var s, n;
        t({
          swiper: a,
          extendParams: (s = i, n = o, function (t = {}) {
            var e = Object.keys(t)[0],
              i = t[e];
            "object" == typeof i && null !== i && (0 <= ["navigation", "pagination", "scrollbar"].indexOf(e) && !0 === s[e] && (s[e] = {
              auto: !0
            }), e in s && "enabled" in i && (!0 === s[e] && (s[e] = {
              enabled: !0
            }), "object" != typeof s[e] || "enabled" in s[e] || (s[e].enabled = !0), s[e] || (s[e] = {
              enabled: !1
            }))), u(n, t)
          }),
          on: a.on.bind(a),
          once: a.once.bind(a),
          off: a.off.bind(a),
          emit: a.emit.bind(a)
        })
      });
      var s, t = u({}, k, o);
      return a.params = u({}, t, S, i), a.originalParams = u({}, a.params), a.passedParams = u({}, i), a.params && a.params.on && Object.keys(a.params.on).forEach(t => {
        a.on(t, a.params.on[t])
      }), a.params && a.params.onAny && a.onAny(a.params.onAny), a.$ = P, Object.assign(a, {
        enabled: a.params.enabled,
        el: e,
        classNames: [],
        slides: P(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        isHorizontal: () => "horizontal" === a.params.direction,
        isVertical: () => "vertical" === a.params.direction,
        activeIndex: 0,
        realIndex: 0,
        isBeginning: !0,
        isEnd: !1,
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        allowSlideNext: a.params.allowSlideNext,
        allowSlidePrev: a.params.allowSlidePrev,
        touchEvents: (s = ["touchstart", "touchmove", "touchend", "touchcancel"], t = ["pointerdown", "pointermove", "pointerup"], a.touchEventsTouch = {
          start: s[0],
          move: s[1],
          end: s[2],
          cancel: s[3]
        }, a.touchEventsDesktop = {
          start: t[0],
          move: t[1],
          end: t[2]
        }, a.support.touch || !a.params.simulateTouch ? a.touchEventsTouch : a.touchEventsDesktop),
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          focusableElements: a.params.focusableElements,
          lastClickTime: g(),
          clickTimeout: void 0,
          velocities: [],
          allowMomentumBounce: void 0,
          isTouchEvent: void 0,
          startMoving: void 0
        },
        allowClick: !0,
        allowTouchMove: a.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        imagesToLoad: [],
        imagesLoaded: 0
      }), a.emit("_swiper"), a.params.init && a.init(), a
    }
    enable() {
      this.enabled || (this.enabled = !0, this.params.grabCursor && this.setGrabCursor(), this.emit("enable"))
    }
    disable() {
      this.enabled && (this.enabled = !1, this.params.grabCursor && this.unsetGrabCursor(), this.emit("disable"))
    }
    setProgress(t, e) {
      t = Math.min(Math.max(t, 0), 1);
      var i = this.minTranslate(),
        i = (this.maxTranslate() - i) * t + i;
      this.translateTo(i, void 0 === e ? 0 : e), this.updateActiveIndex(), this.updateSlidesClasses()
    }
    emitContainerClasses() {
      const e = this;
      if (e.params._emitClasses && e.el) {
        const t = e.el.className.split(" ").filter(t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass));
        e.emit("_containerClasses", t.join(" "))
      }
    }
    getSlideClasses(t) {
      const e = this;
      return t.className.split(" ").filter(t => 0 === t.indexOf("swiper-slide") || 0 === t.indexOf(e.params.slideClass)).join(" ")
    }
    emitSlidesClasses() {
      const i = this;
      if (i.params._emitClasses && i.el) {
        const s = [];
        i.slides.each(t => {
          var e = i.getSlideClasses(t);
          s.push({
            slideEl: t,
            classNames: e
          }), i.emit("_slideClass", t, e)
        }), i.emit("_slideClasses", s)
      }
    }
    slidesPerViewDynamic(t = "current", e = !1) {
      var {
        params: i,
        slides: s,
        slidesGrid: n,
        slidesSizesGrid: a,
        size: o,
        activeIndex: r
      } = this;
      let l = 1;
      if (i.centeredSlides) {
        let e, i = s[r].swiperSlideSize;
        for (let t = r + 1; t < s.length; t += 1) s[t] && !e && (i += s[t].swiperSlideSize, l += 1, i > o && (e = !0));
        for (let t = r - 1; 0 <= t; --t) s[t] && !e && (i += s[t].swiperSlideSize, l += 1, i > o && (e = !0))
      } else if ("current" === t)
        for (let t = r + 1; t < s.length; t += 1)(e ? n[t] + a[t] - n[r] < o : n[t] - n[r] < o) && (l += 1);
      else
        for (let t = r - 1; 0 <= t; --t) n[r] - n[t] < o && (l += 1);
      return l
    }
    update() {
      const e = this;
      var t, i;

      function s() {
        var t = e.rtlTranslate ? -1 * e.translate : e.translate,
          t = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
        e.setTranslate(t), e.updateActiveIndex(), e.updateSlidesClasses()
      }
      e && !e.destroyed && ({
        snapGrid: t,
        params: i
      } = e, i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (s(), e.params.autoHeight && e.updateAutoHeight()) : (("auto" === e.params.slidesPerView || 1 < e.params.slidesPerView) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0)) || s(), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update"))
    }
    changeDirection(e, t = !0) {
      var i = this,
        s = i.params.direction;
      return (e = e || ("horizontal" === s ? "vertical" : "horizontal")) === s || "horizontal" !== e && "vertical" !== e || (i.$el.removeClass(`${i.params.containerModifierClass}${s}`).addClass(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.each(t => {
        "vertical" === e ? t.style.width = "" : t.style.height = ""
      }), i.emit("changeDirection"), t && i.update()), i
    }
    mount(e) {
      const t = this;
      if (t.mounted) return !0;
      const i = P(e || t.params.el);
      if (!(e = i[0])) return !1;
      e.swiper = t;
      const s = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
      let n = (() => {
        if (e && e.shadowRoot && e.shadowRoot.querySelector) {
          const t = P(e.shadowRoot.querySelector(s()));
          return t.children = t => i.children(t), t
        }
        return i.children(s())
      })();
      if (0 === n.length && t.params.createElements) {
        const e = x().createElement("div");
        n = P(e), e.className = t.params.wrapperClass, i.append(e), i.children(`.${t.params.slideClass}`).each(t => {
          n.append(t)
        })
      }
      return Object.assign(t, {
        $el: i,
        el: e,
        $wrapperEl: n,
        wrapperEl: n[0],
        mounted: !0,
        rtl: "rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction"),
        rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction")),
        wrongRTL: "-webkit-box" === n.css("display")
      }), !0
    }
    init(t) {
      var e = this;
      return e.initialized || !1 === e.mount(t) || (e.emit("beforeInit"), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.enabled && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit, !1, !0) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit, !1, !0), e.attachEvents(), e.initialized = !0, e.emit("init"), e.emit("afterInit")), e
    }
    destroy(t = !0, e = !0) {
      const i = this,
        {
          params: s,
          $el: n,
          $wrapperEl: a,
          slides: o
        } = i;
      return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), e && (i.removeClasses(), n.removeAttr("style"), a.removeAttr("style"), o && o.length && o.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(t => {
        i.off(t)
      }), !1 !== t && (i.$el[0].swiper = null, function () {
        const e = i;
        Object.keys(e).forEach(t => {
          try {
            e[t] = null
          } catch (t) {}
          try {
            delete e[t]
          } catch (t) {}
        })
      }()), i.destroyed = !0), null
    }
    static extendDefaults(t) {
      u(S, t)
    }
    static get extendedDefaults() {
      return S
    }
    static get defaults() {
      return k
    }
    static installModule(t) {
      M.prototype.__modules__ || (M.prototype.__modules__ = []);
      const e = M.prototype.__modules__;
      "function" == typeof t && e.indexOf(t) < 0 && e.push(t)
    }
    static use(t) {
      return Array.isArray(t) ? t.forEach(t => M.installModule(t)) : M.installModule(t), M
    }
  }

  function E(i, s, n, a) {
    const o = x();
    return i.params.createElements && Object.keys(a).forEach(e => {
      if (!n[e] && !0 === n.auto) {
        let t = i.$el.children(`.${a[e]}`)[0];
        t || (t = o.createElement("div"), t.className = a[e], i.$el.append(t)), n[e] = t, s[e] = t
      }
    }), n
  }

  function O(t = "") {
    return `.${t.trim().replace(/([\.:!\/])/g,"\\$1").replace(/ /g,".")}`
  }

  function $(t) {
    const {
      effect: i,
      swiper: s,
      on: e,
      setTranslate: n,
      setTransition: a,
      overwriteParams: o,
      perspective: r
    } = t;
    e("beforeInit", () => {
      var t;
      s.params.effect === i && (s.classNames.push(`${s.params.containerModifierClass}${i}`), r && r() && s.classNames.push(`${s.params.containerModifierClass}3d`), t = o ? o() : {}, Object.assign(s.params, t), Object.assign(s.originalParams, t))
    }), e("setTranslate", () => {
      s.params.effect === i && n()
    }), e("setTransition", (t, e) => {
      s.params.effect === i && a(e)
    })
  }

  function L(t, e) {
    return t.transformEl ? e.find(t.transformEl).css({
      "backface-visibility": "hidden",
      "-webkit-backface-visibility": "hidden"
    }) : e
  }

  function N({
    swiper: s,
    duration: t,
    transformEl: e,
    allSlides: n
  }) {
    const {
      slides: a,
      activeIndex: o,
      $wrapperEl: r
    } = s;
    if (s.params.virtualTranslate && 0 !== t) {
      let t, i = !1;
      t = n ? e ? a.find(e) : a : e ? a.eq(o).find(e) : a.eq(o), t.transitionEnd(() => {
        if (!i && s && !s.destroyed) {
          i = !0, s.animating = !1;
          var e = ["webkitTransitionEnd", "transitionend"];
          for (let t = 0; t < e.length; t += 1) r.trigger(e[t])
        }
      })
    }
  }

  function H(t, e, i) {
    const s = "swiper-slide-shadow" + (i ? `-${i}` : ""),
      n = t.transformEl ? e.find(t.transformEl) : e;
    let a = n.children(`.${s}`);
    return a.length || (a = P(`<div class="swiper-slide-shadow${i?`-${i}`:""}"></div>`), n.append(a)), a
  }
  Object.keys(T).forEach(e => {
    Object.keys(T[e]).forEach(t => {
      M.prototype[t] = T[e][t]
    })
  }), M.use([function ({
    swiper: a,
    on: t,
    emit: e
  }) {
    const i = A();
    let s = null;
    const o = () => {
        a && !a.destroyed && a.initialized && (e("beforeResize"), e("resize"))
      },
      n = () => {
        a && !a.destroyed && a.initialized && e("orientationchange")
      };
    t("init", () => {
      a.params.resizeObserver && void 0 !== i.ResizeObserver ? a && !a.destroyed && a.initialized && (s = new ResizeObserver(t => {
        var {
          width: e,
          height: i
        } = a;
        let s = e,
          n = i;
        t.forEach(({
          contentBoxSize: t,
          contentRect: e,
          target: i
        }) => {
          i && i !== a.el || (s = e ? e.width : (t[0] || t).inlineSize, n = e ? e.height : (t[0] || t).blockSize)
        }), s === e && n === i || o()
      }), s.observe(a.el)) : (i.addEventListener("resize", o), i.addEventListener("orientationchange", n))
    }), t("destroy", () => {
      s && s.unobserve && a.el && (s.unobserve(a.el), s = null), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", n)
    })
  }, function ({
    swiper: t,
    extendParams: e,
    on: i,
    emit: s
  }) {
    const n = [],
      a = A(),
      o = (t, e = {}) => {
        const i = new(a.MutationObserver || a.WebkitMutationObserver)(t => {
          var e;
          1 !== t.length ? (e = function () {
            s("observerUpdate", t[0])
          }, a.requestAnimationFrame ? a.requestAnimationFrame(e) : a.setTimeout(e, 0)) : s("observerUpdate", t[0])
        });
        i.observe(t, {
          attributes: void 0 === e.attributes || e.attributes,
          childList: void 0 === e.childList || e.childList,
          characterData: void 0 === e.characterData || e.characterData
        }), n.push(i)
      };
    e({
      observer: !1,
      observeParents: !1,
      observeSlideChildren: !1
    }), i("init", () => {
      if (t.params.observer) {
        if (t.params.observeParents) {
          var e = t.$el.parents();
          for (let t = 0; t < e.length; t += 1) o(e[t])
        }
        o(t.$el[0], {
          childList: t.params.observeSlideChildren
        }), o(t.$wrapperEl[0], {
          attributes: !1
        })
      }
    }), i("destroy", () => {
      n.forEach(t => {
        t.disconnect()
      }), n.splice(0, n.length)
    })
  }]);
  var F = [function ({
    swiper: w,
    extendParams: t,
    on: e
  }) {
    let i;

    function x(t, e) {
      const i = w.params.virtual;
      if (i.cache && w.virtual.cache[e]) return w.virtual.cache[e];
      const s = i.renderSlide ? P(i.renderSlide.call(w, t, e)) : P(`<div class="${w.params.slideClass}" data-swiper-slide-index="${e}">${t}</div>`);
      return s.attr("data-swiper-slide-index") || s.attr("data-swiper-slide-index", e), i.cache && (w.virtual.cache[e] = s), s
    }

    function o(e) {
      const {
        slidesPerView: t,
        slidesPerGroup: i,
        centeredSlides: s
      } = w.params, {
        addSlidesBefore: n,
        addSlidesAfter: a
      } = w.params.virtual, {
        from: o,
        to: r,
        slides: l,
        slidesGrid: c,
        offset: d
      } = w.virtual;
      w.params.cssMode || w.updateActiveIndex();
      var h = w.activeIndex || 0;
      let u, p, f;
      u = w.rtlTranslate ? "right" : w.isHorizontal() ? "left" : "top", f = s ? (p = Math.floor(t / 2) + i + a, Math.floor(t / 2) + i + n) : (p = t + (i - 1) + a, i + n);
      const m = Math.max((h || 0) - f, 0),
        g = Math.min((h || 0) + p, l.length - 1),
        v = (w.slidesGrid[m] || 0) - (w.slidesGrid[0] || 0);

      function b() {
        w.updateSlides(), w.updateProgress(), w.updateSlidesClasses(), w.lazy && w.params.lazy.enabled && w.lazy.load()
      }
      if (Object.assign(w.virtual, {
          from: m,
          to: g,
          offset: v,
          slidesGrid: w.slidesGrid
        }), o === m && r === g && !e) return w.slidesGrid !== c && v !== d && w.slides.css(u, `${v}px`), void w.updateProgress();
      if (w.params.virtual.renderExternal) return w.params.virtual.renderExternal.call(w, {
        offset: v,
        from: m,
        to: g,
        slides: function () {
          const e = [];
          for (let t = m; t <= g; t += 1) e.push(l[t]);
          return e
        }()
      }), void(w.params.virtual.renderExternalUpdate && b());
      const _ = [],
        y = [];
      if (e) w.$wrapperEl.find(`.${w.params.slideClass}`).remove();
      else
        for (let t = o; t <= r; t += 1)(t < m || t > g) && w.$wrapperEl.find(`.${w.params.slideClass}[data-swiper-slide-index="${t}"]`).remove();
      for (let t = 0; t < l.length; t += 1) t >= m && t <= g && (void 0 === r || e ? y.push(t) : (t > r && y.push(t), t < o && _.push(t)));
      y.forEach(t => {
        w.$wrapperEl.append(x(l[t], t))
      }), _.sort((t, e) => e - t).forEach(t => {
        w.$wrapperEl.prepend(x(l[t], t))
      }), w.$wrapperEl.children(".swiper-slide").css(u, `${v}px`), b()
    }
    t({
      virtual: {
        enabled: !1,
        slides: [],
        cache: !0,
        renderSlide: null,
        renderExternal: null,
        renderExternalUpdate: !0,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    }), w.virtual = {
      cache: {},
      from: void 0,
      to: void 0,
      slides: [],
      offset: 0,
      slidesGrid: []
    }, e("beforeInit", () => {
      w.params.virtual.enabled && (w.virtual.slides = w.params.virtual.slides, w.classNames.push(`${w.params.containerModifierClass}virtual`), w.params.watchSlidesProgress = !0, w.originalParams.watchSlidesProgress = !0, w.params.initialSlide || o())
    }), e("setTranslate", () => {
      w.params.virtual.enabled && (w.params.cssMode && !w._immediateVirtual ? (clearTimeout(i), i = setTimeout(() => {
        o()
      }, 100)) : o())
    }), e("init update resize", () => {
      w.params.virtual.enabled && w.params.cssMode && D(w.wrapperEl, "--swiper-virtual-size", `${w.virtualSize}px`)
    }), Object.assign(w.virtual, {
      appendSlide: function (e) {
        if ("object" == typeof e && "length" in e)
          for (let t = 0; t < e.length; t += 1) e[t] && w.virtual.slides.push(e[t]);
        else w.virtual.slides.push(e);
        o(!0)
      },
      prependSlide: function (s) {
        const n = w.activeIndex;
        let t = n + 1,
          a = 1;
        if (Array.isArray(s)) {
          for (let t = 0; t < s.length; t += 1) s[t] && w.virtual.slides.unshift(s[t]);
          t = n + s.length, a = s.length
        } else w.virtual.slides.unshift(s);
        if (w.params.virtual.cache) {
          const s = w.virtual.cache,
            n = {};
          Object.keys(s).forEach(t => {
            const e = s[t],
              i = e.attr("data-swiper-slide-index");
            i && e.attr("data-swiper-slide-index", parseInt(i, 10) + a), n[parseInt(t, 10) + a] = e
          }), w.virtual.cache = n
        }
        o(!0), w.slideTo(t, 0)
      },
      removeSlide: function (i) {
        if (null != i) {
          let e = w.activeIndex;
          if (Array.isArray(i))
            for (let t = i.length - 1; 0 <= t; --t) w.virtual.slides.splice(i[t], 1), w.params.virtual.cache && delete w.virtual.cache[i[t]], i[t] < e && --e, e = Math.max(e, 0);
          else w.virtual.slides.splice(i, 1), w.params.virtual.cache && delete w.virtual.cache[i], i < e && --e, e = Math.max(e, 0);
          o(!0), w.slideTo(e, 0)
        }
      },
      removeAllSlides: function () {
        w.virtual.slides = [], w.params.virtual.cache && (w.virtual.cache = {}), o(!0), w.slideTo(0, 0)
      },
      update: o
    })
  }, function ({
    swiper: h,
    extendParams: t,
    on: e,
    emit: u
  }) {
    const p = x(),
      f = A();

    function i(e) {
      if (h.enabled) {
        const {
          rtlTranslate: i
        } = h;
        let t = e;
        t.originalEvent && (t = t.originalEvent);
        const s = t.keyCode || t.charCode,
          n = h.params.keyboard.pageUpDown,
          a = n && 33 === s,
          o = n && 34 === s,
          r = 37 === s,
          l = 39 === s,
          c = 38 === s,
          d = 40 === s;
        if (!h.allowSlideNext && (h.isHorizontal() && l || h.isVertical() && d || o)) return !1;
        if (!h.allowSlidePrev && (h.isHorizontal() && r || h.isVertical() && c || a)) return !1;
        if (!(t.shiftKey || t.altKey || t.ctrlKey || t.metaKey || p.activeElement && p.activeElement.nodeName && ("input" === p.activeElement.nodeName.toLowerCase() || "textarea" === p.activeElement.nodeName.toLowerCase()))) {
          if (h.params.keyboard.onlyInViewport && (a || o || r || l || c || d)) {
            let e = !1;
            if (0 < h.$el.parents(`.${h.params.slideClass}`).length && 0 === h.$el.parents(`.${h.params.slideActiveClass}`).length) return;
            const t = h.$el,
              u = t[0].clientWidth,
              s = t[0].clientHeight,
              p = f.innerWidth,
              n = f.innerHeight,
              a = h.$el.offset();
            i && (a.left -= h.$el[0].scrollLeft);
            const o = [
              [a.left, a.top],
              [a.left + u, a.top],
              [a.left, a.top + s],
              [a.left + u, a.top + s]
            ];
            for (let t = 0; t < o.length; t += 1) {
              const i = o[t];
              0 <= i[0] && i[0] <= p && 0 <= i[1] && i[1] <= n && (0 === i[0] && 0 === i[1] || (e = !0))
            }
            if (!e) return
          }
          h.isHorizontal() ? ((a || o || r || l) && (t.preventDefault ? t.preventDefault() : t.returnValue = !1), ((o || l) && !i || (a || r) && i) && h.slideNext(), ((a || r) && !i || (o || l) && i) && h.slidePrev()) : ((a || o || c || d) && (t.preventDefault ? t.preventDefault() : t.returnValue = !1), (o || d) && h.slideNext(), (a || c) && h.slidePrev()), u("keyPress", s)
        }
      }
    }

    function s() {
      h.keyboard.enabled || (P(p).on("keydown", i), h.keyboard.enabled = !0)
    }

    function n() {
      h.keyboard.enabled && (P(p).off("keydown", i), h.keyboard.enabled = !1)
    }
    t({
      keyboard: {
        enabled: !(h.keyboard = {
          enabled: !1
        }),
        onlyInViewport: !0,
        pageUpDown: !0
      }
    }), e("init", () => {
      h.params.keyboard.enabled && s()
    }), e("destroy", () => {
      h.keyboard.enabled && n()
    }), Object.assign(h.keyboard, {
      enable: s,
      disable: n
    })
  }, function ({
    swiper: c,
    extendParams: t,
    on: e,
    emit: d
  }) {
    const i = A();
    let h;
    t({
      mousewheel: {
        enabled: !1,
        releaseOnEdges: !1,
        invert: !1,
        forceToAxis: !1,
        sensitivity: 1,
        eventsTarget: "container",
        thresholdDelta: null,
        thresholdTime: null
      }
    }), c.mousewheel = {
      enabled: !1
    };
    let u, s = g();
    const p = [];

    function n() {
      c.enabled && (c.mouseEntered = !0)
    }

    function a() {
      c.enabled && (c.mouseEntered = !1)
    }

    function f(t) {
      return !(c.params.mousewheel.thresholdDelta && t.delta < c.params.mousewheel.thresholdDelta) && !(c.params.mousewheel.thresholdTime && g() - s < c.params.mousewheel.thresholdTime) && (6 <= t.delta && g() - s < 60 || (t.direction < 0 ? c.isEnd && !c.params.loop || c.animating || (c.slideNext(), d("scroll", t.raw)) : c.isBeginning && !c.params.loop || c.animating || (c.slidePrev(), d("scroll", t.raw)), s = (new i.Date).getTime(), 0))
    }

    function o(s) {
      let n = s,
        a = !0;
      if (c.enabled) {
        var o = c.params.mousewheel;
        c.params.cssMode && n.preventDefault();
        let t = c.$el;
        if ("container" !== c.params.mousewheel.eventsTarget && (t = P(c.params.mousewheel.eventsTarget)), !c.mouseEntered && !t[0].contains(n.target) && !o.releaseOnEdges) return !0;
        n.originalEvent && (n = n.originalEvent);
        let e = 0;
        var r = c.rtlTranslate ? -1 : 1,
          l = function (t) {
            let e = 0,
              i = 0,
              s = 0,
              n = 0;
            return "detail" in t && (i = t.detail), "wheelDelta" in t && (i = -t.wheelDelta / 120), "wheelDeltaY" in t && (i = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = i, i = 0), s = 10 * e, n = 10 * i, "deltaY" in t && (n = t.deltaY), "deltaX" in t && (s = t.deltaX), t.shiftKey && !s && (s = n, n = 0), (s || n) && t.deltaMode && (1 === t.deltaMode ? (s *= 40, n *= 40) : (s *= 800, n *= 800)), s && !e && (e = s < 1 ? -1 : 1), n && !i && (i = n < 1 ? -1 : 1), {
              spinX: e,
              spinY: i,
              pixelX: s,
              pixelY: n
            }
          }(n);
        if (o.forceToAxis)
          if (c.isHorizontal()) {
            if (!(Math.abs(l.pixelX) > Math.abs(l.pixelY))) return !0;
            e = -l.pixelX * r
          } else {
            if (!(Math.abs(l.pixelY) > Math.abs(l.pixelX))) return !0;
            e = -l.pixelY
          }
        else e = Math.abs(l.pixelX) > Math.abs(l.pixelY) ? -l.pixelX * r : -l.pixelY;
        if (0 === e) return !0;
        o.invert && (e = -e);
        let i = c.getTranslate() + e * o.sensitivity;
        if (i >= c.minTranslate() && (i = c.minTranslate()), i <= c.maxTranslate() && (i = c.maxTranslate()), a = !!c.params.loop || !(i === c.minTranslate() || i === c.maxTranslate()), a && c.params.nested && n.stopPropagation(), c.params.freeMode && c.params.freeMode.enabled) {
          const s = {
              time: g(),
              delta: Math.abs(e),
              direction: Math.sign(e)
            },
            a = u && s.time < u.time + 500 && s.delta <= u.delta && s.direction === u.direction;
          if (!a) {
            u = void 0, c.params.loop && c.loopFix();
            let t = c.getTranslate() + e * o.sensitivity;
            const P = c.isBeginning,
              g = c.isEnd;
            if (t >= c.minTranslate() && (t = c.minTranslate()), t <= c.maxTranslate() && (t = c.maxTranslate()), c.setTransition(0), c.setTranslate(t), c.updateProgress(), c.updateActiveIndex(), c.updateSlidesClasses(), (!P && c.isBeginning || !g && c.isEnd) && c.updateSlidesClasses(), c.params.freeMode.sticky) {
              clearTimeout(h), h = void 0, 15 <= p.length && p.shift();
              const n = p.length ? p[p.length - 1] : void 0,
                d = p[0];
              if (p.push(s), n && (s.delta > n.delta || s.direction !== n.direction)) p.splice(0);
              else if (15 <= p.length && s.time - d.time < 500 && 1 <= d.delta - s.delta && s.delta <= 6) {
                const n = 0 < e ? .8 : .2;
                u = s, p.splice(0), h = C(() => {
                  c.slideToClosest(c.params.speed, !0, void 0, n)
                }, 0)
              }
              h = h || C(() => {
                u = s, p.splice(0), c.slideToClosest(c.params.speed, !0, void 0, .5)
              }, 500)
            }
            if (a || d("scroll", n), c.params.autoplay && c.params.autoplayDisableOnInteraction && c.autoplay.stop(), t === c.minTranslate() || t === c.maxTranslate()) return !0
          }
        } else {
          const n = {
            time: g(),
            delta: Math.abs(e),
            direction: Math.sign(e),
            raw: s
          };
          2 <= p.length && p.shift();
          const d = p.length ? p[p.length - 1] : void 0;
          if (p.push(n), (!d || n.direction !== d.direction || n.delta > d.delta || n.time > d.time + 150) && f(n), function (t) {
              var e = c.params.mousewheel;
              if (t.direction < 0) {
                if (c.isEnd && !c.params.loop && e.releaseOnEdges) return 1
              } else if (c.isBeginning && !c.params.loop && e.releaseOnEdges) return 1
            }(n)) return !0
        }
        return n.preventDefault ? n.preventDefault() : n.returnValue = !1, !1
      }
    }

    function r(t) {
      let e = c.$el;
      "container" !== c.params.mousewheel.eventsTarget && (e = P(c.params.mousewheel.eventsTarget)), e[t]("mouseenter", n), e[t]("mouseleave", a), e[t]("wheel", o)
    }

    function l() {
      return c.params.cssMode ? (c.wrapperEl.removeEventListener("wheel", o), !0) : !c.mousewheel.enabled && (r("on"), c.mousewheel.enabled = !0)
    }

    function m() {
      return c.params.cssMode ? (c.wrapperEl.addEventListener(event, o), !0) : !!c.mousewheel.enabled && (r("off"), !(c.mousewheel.enabled = !1))
    }
    e("init", () => {
      !c.params.mousewheel.enabled && c.params.cssMode && m(), c.params.mousewheel.enabled && l()
    }), e("destroy", () => {
      c.params.cssMode && l(), c.mousewheel.enabled && m()
    }), Object.assign(c.mousewheel, {
      enable: l,
      disable: m
    })
  }, function ({
    swiper: a,
    extendParams: t,
    on: e,
    emit: o
  }) {
    function s(t) {
      let e;
      return t && (e = P(t), a.params.uniqueNavElements && "string" == typeof t && 1 < e.length && 1 === a.$el.find(t).length && (e = a.$el.find(t))), e
    }

    function i(t, e) {
      var i = a.params.navigation;
      t && 0 < t.length && (t[e ? "addClass" : "removeClass"](i.disabledClass), t[0] && "BUTTON" === t[0].tagName && (t[0].disabled = e), a.params.watchOverflow && a.enabled && t[a.isLocked ? "addClass" : "removeClass"](i.lockClass))
    }

    function n() {
      var t, e;
      a.params.loop || ({
        $nextEl: t,
        $prevEl: e
      } = a.navigation, i(e, a.isBeginning && !a.params.rewind), i(t, a.isEnd && !a.params.rewind))
    }

    function r(t) {
      t.preventDefault(), a.isBeginning && !a.params.loop && !a.params.rewind || a.slidePrev()
    }

    function l(t) {
      t.preventDefault(), a.isEnd && !a.params.loop && !a.params.rewind || a.slideNext()
    }

    function c() {
      var t = a.params.navigation;
      if (a.params.navigation = E(a, a.originalParams.navigation, a.params.navigation, {
          nextEl: "swiper-button-next",
          prevEl: "swiper-button-prev"
        }), t.nextEl || t.prevEl) {
        const e = s(t.nextEl),
          i = s(t.prevEl);
        e && 0 < e.length && e.on("click", l), i && 0 < i.length && i.on("click", r), Object.assign(a.navigation, {
          $nextEl: e,
          nextEl: e && e[0],
          $prevEl: i,
          prevEl: i && i[0]
        }), a.enabled || (e && e.addClass(t.lockClass), i && i.addClass(t.lockClass))
      }
    }

    function d() {
      const {
        $nextEl: t,
        $prevEl: e
      } = a.navigation;
      t && t.length && (t.off("click", l), t.removeClass(a.params.navigation.disabledClass)), e && e.length && (e.off("click", r), e.removeClass(a.params.navigation.disabledClass))
    }
    t({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: !1,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock"
      }
    }), a.navigation = {
      nextEl: null,
      $nextEl: null,
      prevEl: null,
      $prevEl: null
    }, e("init", () => {
      c(), n()
    }), e("toEdge fromEdge lock unlock", () => {
      n()
    }), e("destroy", () => {
      d()
    }), e("enable disable", () => {
      const {
        $nextEl: t,
        $prevEl: e
      } = a.navigation;
      t && t[a.enabled ? "removeClass" : "addClass"](a.params.navigation.lockClass), e && e[a.enabled ? "removeClass" : "addClass"](a.params.navigation.lockClass)
    }), e("click", (t, e) => {
      const {
        $nextEl: i,
        $prevEl: s
      } = a.navigation, n = e.target;
      if (a.params.navigation.hideOnClick && !P(n).is(s) && !P(n).is(i) && (!(a.pagination && a.params.pagination && a.params.pagination.clickable) || a.pagination.el !== n && !a.pagination.el.contains(n))) {
        let t;
        i ? t = i.hasClass(a.params.navigation.hiddenClass) : s && (t = s.hasClass(a.params.navigation.hiddenClass)), o(!0 === t ? "navigationShow" : "navigationHide"), i && i.toggleClass(a.params.navigation.hiddenClass), s && s.toggleClass(a.params.navigation.hiddenClass)
      }
    }), Object.assign(a.navigation, {
      update: n,
      init: c,
      destroy: d
    })
  }, function ({
    swiper: c,
    extendParams: t,
    on: e,
    emit: d
  }) {
    var i = "swiper-pagination";
    let h;
    t({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: !1,
        hideOnClick: !1,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: !1,
        type: "bullets",
        dynamicBullets: !1,
        dynamicMainBullets: 1,
        formatFractionCurrent: t => t,
        formatFractionTotal: t => t,
        bulletClass: `${i}-bullet`,
        bulletActiveClass: `${i}-bullet-active`,
        modifierClass: `${i}-`,
        currentClass: `${i}-current`,
        totalClass: `${i}-total`,
        hiddenClass: `${i}-hidden`,
        progressbarFillClass: `${i}-progressbar-fill`,
        progressbarOppositeClass: `${i}-progressbar-opposite`,
        clickableClass: `${i}-clickable`,
        lockClass: `${i}-lock`,
        horizontalClass: `${i}-horizontal`,
        verticalClass: `${i}-vertical`
      }
    }), c.pagination = {
      el: null,
      $el: null,
      bullets: []
    };
    let u = 0;

    function p() {
      return !c.params.pagination.el || !c.pagination.el || !c.pagination.$el || 0 === c.pagination.$el.length
    }

    function f(t, e) {
      var {
        bulletActiveClass: i
      } = c.params.pagination;
      t[e]().addClass(`${i}-${e}`)[e]().addClass(`${i}-${e}-${e}`)
    }

    function s() {
      const e = c.rtl,
        o = c.params.pagination;
      if (!p()) {
        const r = (c.virtual && c.params.virtual.enabled ? c.virtual : c).slides.length,
          l = c.pagination.$el;
        let a;
        var i = c.params.loop ? Math.ceil((r - 2 * c.loopedSlides) / c.params.slidesPerGroup) : c.snapGrid.length;
        if (c.params.loop ? (a = Math.ceil((c.activeIndex - c.loopedSlides) / c.params.slidesPerGroup), a > r - 1 - 2 * c.loopedSlides && (a -= r - 2 * c.loopedSlides), a > i - 1 && (a -= i), a < 0 && "bullets" !== c.params.paginationType && (a = i + a)) : a = void 0 !== c.snapIndex ? c.snapIndex : c.activeIndex || 0, "bullets" === o.type && c.pagination.bullets && 0 < c.pagination.bullets.length) {
          const d = c.pagination.bullets;
          let s, n, t;
          if (o.dynamicBullets && (h = d.eq(0)[c.isHorizontal() ? "outerWidth" : "outerHeight"](!0), l.css(c.isHorizontal() ? "width" : "height", h * (o.dynamicMainBullets + 4) + "px"), 1 < o.dynamicMainBullets && void 0 !== c.previousIndex && (u += a - (c.previousIndex - c.loopedSlides || 0), u > o.dynamicMainBullets - 1 ? u = o.dynamicMainBullets - 1 : u < 0 && (u = 0)), s = Math.max(a - u, 0), n = s + (Math.min(d.length, o.dynamicMainBullets) - 1), t = (n + s) / 2), d.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(t => `${o.bulletActiveClass}${t}`).join(" ")), 1 < l.length) d.each(t => {
            const e = P(t),
              i = e.index();
            i === a && e.addClass(o.bulletActiveClass), o.dynamicBullets && (i >= s && i <= n && e.addClass(`${o.bulletActiveClass}-main`), i === s && f(e, "prev"), i === n && f(e, "next"))
          });
          else {
            const e = d.eq(a),
              h = e.index();
            if (e.addClass(o.bulletActiveClass), o.dynamicBullets) {
              const e = d.eq(s),
                u = d.eq(n);
              for (let t = s; t <= n; t += 1) d.eq(t).addClass(`${o.bulletActiveClass}-main`);
              if (c.params.loop)
                if (h >= d.length) {
                  for (let t = o.dynamicMainBullets; 0 <= t; --t) d.eq(d.length - t).addClass(`${o.bulletActiveClass}-main`);
                  d.eq(d.length - o.dynamicMainBullets - 1).addClass(`${o.bulletActiveClass}-prev`)
                } else f(e, "prev"), f(u, "next");
              else f(e, "prev"), f(u, "next")
            }
          }
          if (o.dynamicBullets) {
            const r = Math.min(d.length, o.dynamicMainBullets + 4),
              u = (h * r - h) / 2 - t * h,
              p = e ? "right" : "left";
            d.css(c.isHorizontal() ? p : "top", `${u}px`)
          }
        }
        if ("fraction" === o.type && (l.find(O(o.currentClass)).text(o.formatFractionCurrent(a + 1)), l.find(O(o.totalClass)).text(o.formatFractionTotal(i))), "progressbar" === o.type) {
          var s = o.progressbarOpposite ? c.isHorizontal() ? "vertical" : "horizontal" : c.isHorizontal() ? "horizontal" : "vertical";
          const d = (a + 1) / i;
          let t = 1,
            e = 1;
          "horizontal" == s ? t = d : e = d, l.find(O(o.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${t}) scaleY(${e})`).transition(c.params.speed)
        }
        "custom" === o.type && o.renderCustom ? (l.html(o.renderCustom(c, a + 1, i)), d("paginationRender", l[0])) : d("paginationUpdate", l[0]), c.params.watchOverflow && c.enabled && l[c.isLocked ? "addClass" : "removeClass"](o.lockClass)
      }
    }

    function n() {
      const s = c.params.pagination;
      if (!p()) {
        const t = (c.virtual && c.params.virtual.enabled ? c.virtual : c).slides.length,
          n = c.pagination.$el;
        let i = "";
        if ("bullets" === s.type) {
          let e = c.params.loop ? Math.ceil((t - 2 * c.loopedSlides) / c.params.slidesPerGroup) : c.snapGrid.length;
          c.params.freeMode && c.params.freeMode.enabled && !c.params.loop && e > t && (e = t);
          for (let t = 0; t < e; t += 1) s.renderBullet ? i += s.renderBullet.call(c, t, s.bulletClass) : i += `<${s.bulletElement} class="${s.bulletClass}"></${s.bulletElement}>`;
          n.html(i), c.pagination.bullets = n.find(O(s.bulletClass))
        }
        "fraction" === s.type && (i = s.renderFraction ? s.renderFraction.call(c, s.currentClass, s.totalClass) : `<span class="${s.currentClass}"></span> / <span class="${s.totalClass}"></span>`, n.html(i)), "progressbar" === s.type && (i = s.renderProgressbar ? s.renderProgressbar.call(c, s.progressbarFillClass) : `<span class="${s.progressbarFillClass}"></span>`, n.html(i)), "custom" !== s.type && d("paginationRender", c.pagination.$el[0])
      }
    }

    function a() {
      c.params.pagination = E(c, c.originalParams.pagination, c.params.pagination, {
        el: "swiper-pagination"
      });
      const e = c.params.pagination;
      if (e.el) {
        let t = P(e.el);
        0 !== t.length && (c.params.uniqueNavElements && "string" == typeof e.el && 1 < t.length && (t = c.$el.find(e.el), 1 < t.length && (t = t.filter(t => P(t).parents(".swiper")[0] === c.el))), "bullets" === e.type && e.clickable && t.addClass(e.clickableClass), t.addClass(e.modifierClass + e.type), t.addClass(e.modifierClass + c.params.direction), "bullets" === e.type && e.dynamicBullets && (t.addClass(`${e.modifierClass}${e.type}-dynamic`), u = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && t.addClass(e.progressbarOppositeClass), e.clickable && t.on("click", O(e.bulletClass), function (t) {
          t.preventDefault();
          let e = P(this).index() * c.params.slidesPerGroup;
          c.params.loop && (e += c.loopedSlides), c.slideTo(e)
        }), Object.assign(c.pagination, {
          $el: t,
          el: t[0]
        }), c.enabled || t.addClass(e.lockClass))
      }
    }

    function o() {
      var t = c.params.pagination;
      if (!p()) {
        const e = c.pagination.$el;
        e.removeClass(t.hiddenClass), e.removeClass(t.modifierClass + t.type), e.removeClass(t.modifierClass + c.params.direction), c.pagination.bullets && c.pagination.bullets.removeClass && c.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && e.off("click", O(t.bulletClass))
      }
    }
    e("init", () => {
      a(), n(), s()
    }), e("activeIndexChange", () => {
      !c.params.loop && void 0 !== c.snapIndex || s()
    }), e("snapIndexChange", () => {
      c.params.loop || s()
    }), e("slidesLengthChange", () => {
      c.params.loop && (n(), s())
    }), e("snapGridLengthChange", () => {
      c.params.loop || (n(), s())
    }), e("destroy", () => {
      o()
    }), e("enable disable", () => {
      const {
        $el: t
      } = c.pagination;
      t && t[c.enabled ? "removeClass" : "addClass"](c.params.pagination.lockClass)
    }), e("lock unlock", () => {
      s()
    }), e("click", (t, e) => {
      const i = e.target,
        {
          $el: s
        } = c.pagination;
      if (c.params.pagination.el && c.params.pagination.hideOnClick && 0 < s.length && !P(i).hasClass(c.params.pagination.bulletClass) && (!c.navigation || !(c.navigation.nextEl && i === c.navigation.nextEl || c.navigation.prevEl && i === c.navigation.prevEl))) {
        const t = s.hasClass(c.params.pagination.hiddenClass);
        d(!0 === t ? "paginationShow" : "paginationHide"), s.toggleClass(c.params.pagination.hiddenClass)
      }
    }), Object.assign(c.pagination, {
      render: n,
      update: s,
      init: a,
      destroy: o
    })
  }, function ({
    swiper: c,
    extendParams: t,
    on: e,
    emit: o
  }) {
    const d = x();
    let r, l, h, s, u = !1,
      p = null,
      f = null;

    function i() {
      if (c.params.scrollbar.el && c.scrollbar.el) {
        const {
          scrollbar: i,
          rtlTranslate: s,
          progress: n
        } = c, {
          $dragEl: a,
          $el: o
        } = i, r = c.params.scrollbar;
        let t = l,
          e = (h - l) * n;
        s ? (e = -e, 0 < e ? (t = l - e, e = 0) : -e + l > h && (t = h + e)) : e < 0 ? (t = l + e, e = 0) : e + l > h && (t = h - e), c.isHorizontal() ? (a.transform(`translate3d(${e}px, 0, 0)`), a[0].style.width = `${t}px`) : (a.transform(`translate3d(0px, ${e}px, 0)`), a[0].style.height = `${t}px`), r.hide && (clearTimeout(p), o[0].style.opacity = 1, p = setTimeout(() => {
          o[0].style.opacity = 0, o.transition(400)
        }, 1e3))
      }
    }

    function n() {
      if (c.params.scrollbar.el && c.scrollbar.el) {
        const {
          scrollbar: t
        } = c, {
          $dragEl: e,
          $el: i
        } = t;
        e[0].style.width = "", e[0].style.height = "", h = c.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight, s = c.size / (c.virtualSize + c.params.slidesOffsetBefore - (c.params.centeredSlides ? c.snapGrid[0] : 0)), l = "auto" === c.params.scrollbar.dragSize ? h * s : parseInt(c.params.scrollbar.dragSize, 10), c.isHorizontal() ? e[0].style.width = `${l}px` : e[0].style.height = `${l}px`, i[0].style.display = 1 <= s ? "none" : "", c.params.scrollbar.hide && (i[0].style.opacity = 0), c.params.watchOverflow && c.enabled && t.$el[c.isLocked ? "addClass" : "removeClass"](c.params.scrollbar.lockClass)
      }
    }

    function m(t) {
      return c.isHorizontal() ? ("touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0] : t).clientX : ("touchstart" === t.type || "touchmove" === t.type ? t.targetTouches[0] : t).clientY
    }

    function g(t) {
      const {
        scrollbar: e,
        rtlTranslate: i
      } = c, {
        $el: s
      } = e;
      let n;
      n = (m(t) - s.offset()[c.isHorizontal() ? "left" : "top"] - (null !== r ? r : l / 2)) / (h - l), n = Math.max(Math.min(n, 1), 0), i && (n = 1 - n);
      t = c.minTranslate() + (c.maxTranslate() - c.minTranslate()) * n;
      c.updateProgress(t), c.setTranslate(t), c.updateActiveIndex(), c.updateSlidesClasses()
    }

    function v(t) {
      const e = c.params.scrollbar,
        {
          scrollbar: i,
          $wrapperEl: s
        } = c,
        {
          $el: n,
          $dragEl: a
        } = i;
      u = !0, r = t.target === a[0] || t.target === a ? m(t) - t.target.getBoundingClientRect()[c.isHorizontal() ? "left" : "top"] : null, t.preventDefault(), t.stopPropagation(), s.transition(100), a.transition(100), g(t), clearTimeout(f), n.transition(0), e.hide && n.css("opacity", 1), c.params.cssMode && c.$wrapperEl.css("scroll-snap-type", "none"), o("scrollbarDragStart", t)
    }

    function b(t) {
      const {
        scrollbar: e,
        $wrapperEl: i
      } = c, {
        $el: s,
        $dragEl: n
      } = e;
      u && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, g(t), i.transition(0), s.transition(0), n.transition(0), o("scrollbarDragMove", t))
    }

    function _(t) {
      const e = c.params.scrollbar,
        {
          scrollbar: i,
          $wrapperEl: s
        } = c,
        {
          $el: n
        } = i;
      u && (u = !1, c.params.cssMode && (c.$wrapperEl.css("scroll-snap-type", ""), s.transition("")), e.hide && (clearTimeout(f), f = C(() => {
        n.css("opacity", 0), n.transition(400)
      }, 1e3)), o("scrollbarDragEnd", t), e.snapOnRelease && c.slideToClosest())
    }

    function a(t) {
      const {
        scrollbar: e,
        touchEventsTouch: i,
        touchEventsDesktop: s,
        params: n,
        support: a
      } = c, o = e.$el[0], r = !(!a.passiveListener || !n.passiveListeners) && {
        passive: !1,
        capture: !1
      }, l = !(!a.passiveListener || !n.passiveListeners) && {
        passive: !0,
        capture: !1
      };
      o && (t = "on" === t ? "addEventListener" : "removeEventListener", a.touch ? (o[t](i.start, v, r), o[t](i.move, b, r), o[t](i.end, _, l)) : (o[t](s.start, v, r), d[t](s.move, b, r), d[t](s.end, _, l)))
    }

    function y() {
      const {
        scrollbar: i,
        $el: s
      } = c;
      c.params.scrollbar = E(c, c.originalParams.scrollbar, c.params.scrollbar, {
        el: "swiper-scrollbar"
      });
      var n = c.params.scrollbar;
      if (n.el) {
        let t = P(n.el);
        c.params.uniqueNavElements && "string" == typeof n.el && 1 < t.length && 1 === s.find(n.el).length && (t = s.find(n.el));
        let e = t.find(`.${c.params.scrollbar.dragClass}`);
        0 === e.length && (e = P(`<div class="${c.params.scrollbar.dragClass}"></div>`), t.append(e)), Object.assign(i, {
          $el: t,
          el: t[0],
          $dragEl: e,
          dragEl: e[0]
        }), n.draggable && c.params.scrollbar.el && a("on"), t && t[c.enabled ? "removeClass" : "addClass"](c.params.scrollbar.lockClass)
      }
    }

    function w() {
      c.params.scrollbar.el && a("off")
    }
    t({
      scrollbar: {
        el: null,
        dragSize: "auto",
        hide: !1,
        draggable: !1,
        snapOnRelease: !0,
        lockClass: "swiper-scrollbar-lock",
        dragClass: "swiper-scrollbar-drag"
      }
    }), c.scrollbar = {
      el: null,
      dragEl: null,
      $el: null,
      $dragEl: null
    }, e("init", () => {
      y(), n(), i()
    }), e("update resize observerUpdate lock unlock", () => {
      n()
    }), e("setTranslate", () => {
      i()
    }), e("setTransition", (t, e) => {
      c.params.scrollbar.el && c.scrollbar.el && c.scrollbar.$dragEl.transition(e)
    }), e("enable disable", () => {
      const {
        $el: t
      } = c.scrollbar;
      t && t[c.enabled ? "removeClass" : "addClass"](c.params.scrollbar.lockClass)
    }), e("destroy", () => {
      w()
    }), Object.assign(c.scrollbar, {
      updateSize: n,
      setTranslate: i,
      init: y,
      destroy: w
    })
  }, function ({
    swiper: c,
    extendParams: t,
    on: e
  }) {
    t({
      parallax: {
        enabled: !1
      }
    });
    const a = (t, e) => {
        const {
          rtl: i
        } = c, s = P(t), n = i ? -1 : 1, a = s.attr("data-swiper-parallax") || "0";
        let o = s.attr("data-swiper-parallax-x"),
          r = s.attr("data-swiper-parallax-y");
        var l = s.attr("data-swiper-parallax-scale"),
          t = s.attr("data-swiper-parallax-opacity");
        if (o || r ? (o = o || "0", r = r || "0") : c.isHorizontal() ? (o = a, r = "0") : (r = a, o = "0"), o = 0 <= o.indexOf("%") ? parseInt(o, 10) * e * n + "%" : o * e * n + "px", r = 0 <= r.indexOf("%") ? parseInt(r, 10) * e + "%" : r * e + "px", null != t) {
          const c = t - (t - 1) * (1 - Math.abs(e));
          s[0].style.opacity = c
        }
        if (null == l) s.transform(`translate3d(${o}, ${r}, 0px)`);
        else {
          const c = l - (l - 1) * (1 - Math.abs(e));
          s.transform(`translate3d(${o}, ${r}, 0px) scale(${c})`)
        }
      },
      i = () => {
        const {
          $el: t,
          slides: e,
          progress: s,
          snapGrid: n
        } = c;
        t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(t => {
          a(t, s)
        }), e.each((t, e) => {
          let i = t.progress;
          1 < c.params.slidesPerGroup && "auto" !== c.params.slidesPerView && (i += Math.ceil(e / 2) - s * (n.length - 1)), i = Math.min(Math.max(i, -1), 1), P(t).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(t => {
            a(t, i)
          })
        })
      };
    e("beforeInit", () => {
      c.params.parallax.enabled && (c.params.watchSlidesProgress = !0, c.originalParams.watchSlidesProgress = !0)
    }), e("init", () => {
      c.params.parallax.enabled && i()
    }), e("setTranslate", () => {
      c.params.parallax.enabled && i()
    }), e("setTransition", (t, e) => {
      c.params.parallax.enabled && ((s = c.params.speed) => {
        const {
          $el: t
        } = c;
        t.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each(t => {
          const e = P(t);
          let i = parseInt(e.attr("data-swiper-parallax-duration"), 10) || s;
          0 === s && (i = 0), e.transition(i)
        })
      })(e)
    })
  }, function ({
    swiper: w,
    extendParams: t,
    on: e,
    emit: s
  }) {
    const x = A();
    t({
      zoom: {
        enabled: !1,
        maxRatio: 3,
        minRatio: 1,
        toggle: !0,
        containerClass: "swiper-zoom-container",
        zoomedSlideClass: "swiper-slide-zoomed"
      }
    }), w.zoom = {
      enabled: !1
    };
    let i, a, o, C = 1,
      r = !1;
    const k = {
        $slideEl: void 0,
        slideWidth: void 0,
        slideHeight: void 0,
        $imageEl: void 0,
        $imageWrapEl: void 0,
        maxRatio: 3
      },
      T = {
        isTouched: void 0,
        isMoved: void 0,
        currentX: void 0,
        currentY: void 0,
        minX: void 0,
        minY: void 0,
        maxX: void 0,
        maxY: void 0,
        width: void 0,
        height: void 0,
        startX: void 0,
        startY: void 0,
        touchesStart: {},
        touchesCurrent: {}
      },
      l = {
        x: void 0,
        y: void 0,
        prevPositionX: void 0,
        prevPositionY: void 0,
        prevTime: void 0
      };
    let n = 1;

    function c(t) {
      if (t.targetTouches.length < 2) return 1;
      var e = t.targetTouches[0].pageX,
        i = t.targetTouches[0].pageY,
        s = t.targetTouches[1].pageX,
        t = t.targetTouches[1].pageY;
      return Math.sqrt((s - e) ** 2 + (t - i) ** 2)
    }

    function d(t) {
      var e = w.support,
        i = w.params.zoom;
      if (a = !1, o = !1, !e.gestures) {
        if ("touchstart" !== t.type || "touchstart" === t.type && t.targetTouches.length < 2) return;
        a = !0, k.scaleStart = c(t)
      }
      k.$slideEl && k.$slideEl.length || (k.$slideEl = P(t.target).closest(`.${w.params.slideClass}`), 0 === k.$slideEl.length && (k.$slideEl = w.slides.eq(w.activeIndex)), k.$imageEl = k.$slideEl.find(`.${i.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), k.$imageWrapEl = k.$imageEl.parent(`.${i.containerClass}`), k.maxRatio = k.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio, 0 !== k.$imageWrapEl.length) ? (k.$imageEl && k.$imageEl.transition(0), r = !0) : k.$imageEl = void 0
    }

    function h(t) {
      const e = w.support,
        i = w.params.zoom,
        s = w.zoom;
      if (!e.gestures) {
        if ("touchmove" !== t.type || "touchmove" === t.type && t.targetTouches.length < 2) return;
        o = !0, k.scaleMove = c(t)
      }
      k.$imageEl && 0 !== k.$imageEl.length ? (e.gestures ? s.scale = t.scale * C : s.scale = k.scaleMove / k.scaleStart * C, s.scale > k.maxRatio && (s.scale = k.maxRatio - 1 + (s.scale - k.maxRatio + 1) ** .5), s.scale < i.minRatio && (s.scale = i.minRatio + 1 - (i.minRatio - s.scale + 1) ** .5), k.$imageEl.transform(`translate3d(0,0,0) scale(${s.scale})`)) : "gesturechange" === t.type && d(t)
    }

    function u(t) {
      const e = w.device,
        i = w.support,
        s = w.params.zoom,
        n = w.zoom;
      if (!i.gestures) {
        if (!a || !o) return;
        if ("touchend" !== t.type || "touchend" === t.type && t.changedTouches.length < 2 && !e.android) return;
        a = !1, o = !1
      }
      k.$imageEl && 0 !== k.$imageEl.length && (n.scale = Math.max(Math.min(n.scale, k.maxRatio), s.minRatio), k.$imageEl.transition(w.params.speed).transform(`translate3d(0,0,0) scale(${n.scale})`), C = n.scale, r = !1, 1 === n.scale && (k.$slideEl = void 0))
    }

    function p(t) {
      var e = w.zoom;
      if (k.$imageEl && 0 !== k.$imageEl.length && (w.allowClick = !1, T.isTouched && k.$slideEl)) {
        T.isMoved || (T.width = k.$imageEl[0].offsetWidth, T.height = k.$imageEl[0].offsetHeight, T.startX = I(k.$imageWrapEl[0], "x") || 0, T.startY = I(k.$imageWrapEl[0], "y") || 0, k.slideWidth = k.$slideEl[0].offsetWidth, k.slideHeight = k.$slideEl[0].offsetHeight, k.$imageWrapEl.transition(0));
        var i = T.width * e.scale,
          e = T.height * e.scale;
        if (!(i < k.slideWidth && e < k.slideHeight)) {
          if (T.minX = Math.min(k.slideWidth / 2 - i / 2, 0), T.maxX = -T.minX, T.minY = Math.min(k.slideHeight / 2 - e / 2, 0), T.maxY = -T.minY, T.touchesCurrent.x = ("touchmove" === t.type ? t.targetTouches[0] : t).pageX, T.touchesCurrent.y = ("touchmove" === t.type ? t.targetTouches[0] : t).pageY, !T.isMoved && !r) {
            if (w.isHorizontal() && (Math.floor(T.minX) === Math.floor(T.startX) && T.touchesCurrent.x < T.touchesStart.x || Math.floor(T.maxX) === Math.floor(T.startX) && T.touchesCurrent.x > T.touchesStart.x)) return void(T.isTouched = !1);
            if (!w.isHorizontal() && (Math.floor(T.minY) === Math.floor(T.startY) && T.touchesCurrent.y < T.touchesStart.y || Math.floor(T.maxY) === Math.floor(T.startY) && T.touchesCurrent.y > T.touchesStart.y)) return void(T.isTouched = !1)
          }
          t.cancelable && t.preventDefault(), t.stopPropagation(), T.isMoved = !0, T.currentX = T.touchesCurrent.x - T.touchesStart.x + T.startX, T.currentY = T.touchesCurrent.y - T.touchesStart.y + T.startY, T.currentX < T.minX && (T.currentX = T.minX + 1 - (T.minX - T.currentX + 1) ** .8), T.currentX > T.maxX && (T.currentX = T.maxX - 1 + (T.currentX - T.maxX + 1) ** .8), T.currentY < T.minY && (T.currentY = T.minY + 1 - (T.minY - T.currentY + 1) ** .8), T.currentY > T.maxY && (T.currentY = T.maxY - 1 + (T.currentY - T.maxY + 1) ** .8), l.prevPositionX || (l.prevPositionX = T.touchesCurrent.x), l.prevPositionY || (l.prevPositionY = T.touchesCurrent.y), l.prevTime || (l.prevTime = Date.now()), l.x = (T.touchesCurrent.x - l.prevPositionX) / (Date.now() - l.prevTime) / 2, l.y = (T.touchesCurrent.y - l.prevPositionY) / (Date.now() - l.prevTime) / 2, Math.abs(T.touchesCurrent.x - l.prevPositionX) < 2 && (l.x = 0), Math.abs(T.touchesCurrent.y - l.prevPositionY) < 2 && (l.y = 0), l.prevPositionX = T.touchesCurrent.x, l.prevPositionY = T.touchesCurrent.y, l.prevTime = Date.now(), k.$imageWrapEl.transform(`translate3d(${T.currentX}px, ${T.currentY}px,0)`)
        }
      }
    }

    function f() {
      const t = w.zoom;
      k.$slideEl && w.previousIndex !== w.activeIndex && (k.$imageEl && k.$imageEl.transform("translate3d(0,0,0) scale(1)"), k.$imageWrapEl && k.$imageWrapEl.transform("translate3d(0,0,0)"), t.scale = 1, C = 1, k.$slideEl = void 0, k.$imageEl = void 0, k.$imageWrapEl = void 0)
    }

    function m(b) {
      const _ = w.zoom,
        y = w.params.zoom;
      if (k.$slideEl || (b && b.target && (k.$slideEl = P(b.target).closest(`.${w.params.slideClass}`)), k.$slideEl || (w.params.virtual && w.params.virtual.enabled && w.virtual ? k.$slideEl = w.$wrapperEl.children(`.${w.params.slideActiveClass}`) : k.$slideEl = w.slides.eq(w.activeIndex)), k.$imageEl = k.$slideEl.find(`.${y.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), k.$imageWrapEl = k.$imageEl.parent(`.${y.containerClass}`)), k.$imageEl && 0 !== k.$imageEl.length && k.$imageWrapEl && 0 !== k.$imageWrapEl.length) {
        let t, e, i, s, n, a, o, r, l, c, d, h, u, p, f, m, g, v;
        w.params.cssMode && (w.wrapperEl.style.overflow = "hidden", w.wrapperEl.style.touchAction = "none"), k.$slideEl.addClass(`${y.zoomedSlideClass}`), e = void 0 === T.touchesStart.x && b ? (t = ("touchend" === b.type ? b.changedTouches[0] : b).pageX, ("touchend" === b.type ? b.changedTouches[0] : b).pageY) : (t = T.touchesStart.x, T.touchesStart.y), _.scale = k.$imageWrapEl.attr("data-swiper-zoom") || y.maxRatio, C = k.$imageWrapEl.attr("data-swiper-zoom") || y.maxRatio, b ? (g = k.$slideEl[0].offsetWidth, v = k.$slideEl[0].offsetHeight, i = k.$slideEl.offset().left + x.scrollX, s = k.$slideEl.offset().top + x.scrollY, n = i + g / 2 - t, a = s + v / 2 - e, l = k.$imageEl[0].offsetWidth, c = k.$imageEl[0].offsetHeight, d = l * _.scale, h = c * _.scale, f = -(u = Math.min(g / 2 - d / 2, 0)), m = -(p = Math.min(v / 2 - h / 2, 0)), o = n * _.scale, r = a * _.scale, o < u && (o = u), o > f && (o = f), r < p && (r = p), r > m && (r = m)) : (o = 0, r = 0), k.$imageWrapEl.transition(300).transform(`translate3d(${o}px, ${r}px,0)`), k.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${_.scale})`)
      }
    }

    function g() {
      const t = w.zoom,
        e = w.params.zoom;
      k.$slideEl || (w.params.virtual && w.params.virtual.enabled && w.virtual ? k.$slideEl = w.$wrapperEl.children(`.${w.params.slideActiveClass}`) : k.$slideEl = w.slides.eq(w.activeIndex), k.$imageEl = k.$slideEl.find(`.${e.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), k.$imageWrapEl = k.$imageEl.parent(`.${e.containerClass}`)), k.$imageEl && 0 !== k.$imageEl.length && k.$imageWrapEl && 0 !== k.$imageWrapEl.length && (w.params.cssMode && (w.wrapperEl.style.overflow = "", w.wrapperEl.style.touchAction = ""), t.scale = 1, C = 1, k.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), k.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), k.$slideEl.removeClass(`${e.zoomedSlideClass}`), k.$slideEl = void 0)
    }

    function v(t) {
      var e = w.zoom;
      e.scale && 1 !== e.scale ? g() : m(t)
    }

    function b() {
      var t = w.support;
      return {
        passiveListener: !("touchstart" !== w.touchEvents.start || !t.passiveListener || !w.params.passiveListeners) && {
          passive: !0,
          capture: !1
        },
        activeListenerWithCapture: !t.passiveListener || {
          passive: !1,
          capture: !0
        }
      }
    }

    function _() {
      return `.${w.params.slideClass}`
    }

    function y(t) {
      var {
        passiveListener: e
      } = b(), i = _();
      w.$wrapperEl[t]("gesturestart", i, d, e), w.$wrapperEl[t]("gesturechange", i, h, e), w.$wrapperEl[t]("gestureend", i, u, e)
    }

    function D() {
      i || (i = !0, y("on"))
    }

    function S() {
      i && (i = !1, y("off"))
    }

    function M() {
      const t = w.zoom;
      var e, i, s, n;
      t.enabled || (t.enabled = !0, e = w.support, {
        passiveListener: i,
        activeListenerWithCapture: s
      } = b(), n = _(), e.gestures ? (w.$wrapperEl.on(w.touchEvents.start, D, i), w.$wrapperEl.on(w.touchEvents.end, S, i)) : "touchstart" === w.touchEvents.start && (w.$wrapperEl.on(w.touchEvents.start, n, d, i), w.$wrapperEl.on(w.touchEvents.move, n, h, s), w.$wrapperEl.on(w.touchEvents.end, n, u, i), w.touchEvents.cancel && w.$wrapperEl.on(w.touchEvents.cancel, n, u, i)), w.$wrapperEl.on(w.touchEvents.move, `.${w.params.zoom.containerClass}`, p, s))
    }

    function E() {
      const t = w.zoom;
      var e, i, s, n;
      t.enabled && (e = w.support, t.enabled = !1, {
        passiveListener: i,
        activeListenerWithCapture: s
      } = b(), n = _(), e.gestures ? (w.$wrapperEl.off(w.touchEvents.start, D, i), w.$wrapperEl.off(w.touchEvents.end, S, i)) : "touchstart" === w.touchEvents.start && (w.$wrapperEl.off(w.touchEvents.start, n, d, i), w.$wrapperEl.off(w.touchEvents.move, n, h, s), w.$wrapperEl.off(w.touchEvents.end, n, u, i), w.touchEvents.cancel && w.$wrapperEl.off(w.touchEvents.cancel, n, u, i)), w.$wrapperEl.off(w.touchEvents.move, `.${w.params.zoom.containerClass}`, p, s))
    }
    Object.defineProperty(w.zoom, "scale", {
      get: () => n,
      set(t) {
        var e, i;
        n !== t && (e = k.$imageEl ? k.$imageEl[0] : void 0, i = k.$slideEl ? k.$slideEl[0] : void 0, s("zoomChange", t, e, i)), n = t
      }
    }), e("init", () => {
      w.params.zoom.enabled && M()
    }), e("destroy", () => {
      E()
    }), e("touchStart", (t, e) => {
      var i;
      w.zoom.enabled && (i = e, e = w.device, k.$imageEl && 0 !== k.$imageEl.length && (T.isTouched || (e.android && i.cancelable && i.preventDefault(), T.isTouched = !0, T.touchesStart.x = ("touchstart" === i.type ? i.targetTouches[0] : i).pageX, T.touchesStart.y = ("touchstart" === i.type ? i.targetTouches[0] : i).pageY)))
    }), e("touchEnd", (t, e) => {
      w.zoom.enabled && function () {
        var i = w.zoom;
        if (k.$imageEl && 0 !== k.$imageEl.length) {
          if (!T.isTouched || !T.isMoved) return T.isTouched = !1, T.isMoved = !1;
          T.isTouched = !1, T.isMoved = !1;
          let t = 300,
            e = 300;
          var s = l.x * t,
            n = T.currentX + s,
            a = l.y * e,
            s = T.currentY + a;
          0 !== l.x && (t = Math.abs((n - T.currentX) / l.x)), 0 !== l.y && (e = Math.abs((s - T.currentY) / l.y));
          a = Math.max(t, e);
          T.currentX = n, T.currentY = s;
          s = T.width * i.scale, i = T.height * i.scale;
          T.minX = Math.min(k.slideWidth / 2 - s / 2, 0), T.maxX = -T.minX, T.minY = Math.min(k.slideHeight / 2 - i / 2, 0), T.maxY = -T.minY, T.currentX = Math.max(Math.min(T.currentX, T.maxX), T.minX), T.currentY = Math.max(Math.min(T.currentY, T.maxY), T.minY), k.$imageWrapEl.transition(a).transform(`translate3d(${T.currentX}px, ${T.currentY}px,0)`)
        }
      }()
    }), e("doubleTap", (t, e) => {
      !w.animating && w.params.zoom.enabled && w.zoom.enabled && w.params.zoom.toggle && v(e)
    }), e("transitionEnd", () => {
      w.zoom.enabled && w.params.zoom.enabled && f()
    }), e("slideChange", () => {
      w.zoom.enabled && w.params.zoom.enabled && w.params.cssMode && f()
    }), Object.assign(w.zoom, {
      enable: M,
      disable: E,
      in: m,
      out: g,
      toggle: v
    })
  }, function ({
    swiper: d,
    extendParams: t,
    on: e,
    emit: h
  }) {
    t({
      lazy: {
        checkInView: !1,
        enabled: !1,
        loadPrevNext: !1,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: !1,
        scrollingElement: "",
        elementClass: "swiper-lazy",
        loadingClass: "swiper-lazy-loading",
        loadedClass: "swiper-lazy-loaded",
        preloaderClass: "swiper-lazy-preloader"
      }
    });
    let u = !(d.lazy = {}),
      c = !1;

    function p(t, r = !0) {
      const l = d.params.lazy;
      if (void 0 !== t && 0 !== d.slides.length) {
        const c = d.virtual && d.params.virtual.enabled ? d.$wrapperEl.children(`.${d.params.slideClass}[data-swiper-slide-index="${t}"]`) : d.slides.eq(t),
          e = c.find(`.${l.elementClass}:not(.${l.loadedClass}):not(.${l.loadingClass})`);
        !c.hasClass(l.elementClass) || c.hasClass(l.loadedClass) || c.hasClass(l.loadingClass) || e.push(c[0]), 0 !== e.length && e.each(t => {
          const e = P(t);
          e.addClass(l.loadingClass);
          const i = e.attr("data-background"),
            s = e.attr("data-src"),
            n = e.attr("data-srcset"),
            a = e.attr("data-sizes"),
            o = e.parent("picture");
          d.loadImage(e[0], s || i, n, a, !1, () => {
            var t;
            null == d || !d || d && !d.params || d.destroyed || (i ? (e.css("background-image", `url("${i}")`), e.removeAttr("data-background")) : (n && (e.attr("srcset", n), e.removeAttr("data-srcset")), a && (e.attr("sizes", a), e.removeAttr("data-sizes")), o.length && o.children("source").each(t => {
              const e = P(t);
              e.attr("data-srcset") && (e.attr("srcset", e.attr("data-srcset")), e.removeAttr("data-srcset"))
            }), s && (e.attr("src", s), e.removeAttr("data-src"))), e.addClass(l.loadedClass).removeClass(l.loadingClass), c.find(`.${l.preloaderClass}`).remove(), d.params.loop && r && (t = c.attr("data-swiper-slide-index"), c.hasClass(d.params.slideDuplicateClass) ? p(d.$wrapperEl.children(`[data-swiper-slide-index="${t}"]:not(.${d.params.slideDuplicateClass})`).index(), !1) : p(d.$wrapperEl.children(`.${d.params.slideDuplicateClass}[data-swiper-slide-index="${t}"]`).index(), !1)), h("lazyImageReady", c[0], e[0]), d.params.autoHeight && d.updateAutoHeight())
          }), h("lazyImageLoad", c[0], e[0])
        })
      }
    }

    function f() {
      const {
        $wrapperEl: e,
        params: i,
        slides: s,
        activeIndex: n
      } = d, a = d.virtual && i.virtual.enabled, t = i.lazy;
      let o = i.slidesPerView;

      function r(t) {
        if (a) {
          if (e.children(`.${i.slideClass}[data-swiper-slide-index="${t}"]`).length) return 1
        } else if (s[t]) return 1
      }

      function l(t) {
        return a ? P(t).attr("data-swiper-slide-index") : P(t).index()
      }
      if ("auto" === o && (o = 0), c = c || !0, d.params.watchSlidesProgress) e.children(`.${i.slideVisibleClass}`).each(t => {
        p(a ? P(t).attr("data-swiper-slide-index") : P(t).index())
      });
      else if (1 < o)
        for (let t = n; t < n + o; t += 1) r(t) && p(t);
      else p(n);
      if (t.loadPrevNext)
        if (1 < o || t.loadPrevNextAmount && 1 < t.loadPrevNextAmount) {
          const d = t.loadPrevNextAmount,
            e = o,
            i = Math.min(n + e + Math.max(d, e), s.length),
            a = Math.max(n - Math.max(e, d), 0);
          for (let t = n + o; t < i; t += 1) r(t) && p(t);
          for (let t = a; t < n; t += 1) r(t) && p(t)
        } else {
          const d = e.children(`.${i.slideNextClass}`);
          0 < d.length && p(l(d));
          const s = e.children(`.${i.slidePrevClass}`);
          0 < s.length && p(l(s))
        }
    }

    function m() {
      const i = A();
      if (d && !d.destroyed) {
        const n = d.params.lazy.scrollingElement ? P(d.params.lazy.scrollingElement) : P(i),
          a = n[0] === i,
          o = a ? i.innerWidth : n[0].offsetWidth,
          r = a ? i.innerHeight : n[0].offsetHeight,
          l = d.$el.offset(),
          {
            rtlTranslate: c
          } = d;
        let e = !1;
        c && (l.left -= d.$el[0].scrollLeft);
        var s = [
          [l.left, l.top],
          [l.left + d.width, l.top],
          [l.left, l.top + d.height],
          [l.left + d.width, l.top + d.height]
        ];
        for (let t = 0; t < s.length; t += 1) {
          const i = s[t];
          0 <= i[0] && i[0] <= o && 0 <= i[1] && i[1] <= r && (0 === i[0] && 0 === i[1] || (e = !0))
        }
        var t = !("touchstart" !== d.touchEvents.start || !d.support.passiveListener || !d.params.passiveListeners) && {
          passive: !0,
          capture: !1
        };
        e ? (f(), n.off("scroll", m, t)) : u || (u = !0, n.on("scroll", m, t))
      }
    }
    e("beforeInit", () => {
      d.params.lazy.enabled && d.params.preloadImages && (d.params.preloadImages = !1)
    }), e("init", () => {
      d.params.lazy.enabled && (d.params.lazy.checkInView ? m : f)()
    }), e("scroll", () => {
      d.params.freeMode && d.params.freeMode.enabled && !d.params.freeMode.sticky && f()
    }), e("scrollbarDragMove resize _freeModeNoMomentumRelease", () => {
      d.params.lazy.enabled && (d.params.lazy.checkInView ? m : f)()
    }), e("transitionStart", () => {
      d.params.lazy.enabled && (d.params.lazy.loadOnTransitionStart || !d.params.lazy.loadOnTransitionStart && !c) && (d.params.lazy.checkInView ? m : f)()
    }), e("transitionEnd", () => {
      d.params.lazy.enabled && !d.params.lazy.loadOnTransitionStart && (d.params.lazy.checkInView ? m : f)()
    }), e("slideChange", () => {
      var {
        lazy: t,
        cssMode: e,
        watchSlidesProgress: i,
        touchReleaseOnEdges: s,
        resistanceRatio: n
      } = d.params;
      t.enabled && (e || i && (s || 0 === n)) && f()
    }), Object.assign(d.lazy, {
      load: f,
      loadInSlide: p
    })
  }, function ({
    swiper: r,
    extendParams: t,
    on: e
  }) {
    function l(t, e) {
      const i = function () {
        let i, s, n;
        return (t, e) => {
          for (s = -1, i = t.length; 1 < i - s;) n = i + s >> 1, t[n] <= e ? s = n : i = n;
          return i
        }
      }();
      let s, n;
      return this.x = t, this.y = e, this.lastIndex = t.length - 1, this.interpolate = function (t) {
        return t ? (n = i(this.x, t), s = n - 1, (t - this.x[s]) * (this.y[n] - this.y[s]) / (this.x[n] - this.x[s]) + this.y[s]) : 0
      }, this
    }

    function i() {
      r.controller.control && r.controller.spline && (r.controller.spline = void 0, delete r.controller.spline)
    }
    t({
      controller: {
        control: void 0,
        inverse: !1,
        by: "slide"
      }
    }), r.controller = {
      control: void 0
    }, e("beforeInit", () => {
      r.controller.control = r.params.controller.control
    }), e("update", () => {
      i()
    }), e("resize", () => {
      i()
    }), e("observerUpdate", () => {
      i()
    }), e("setTranslate", (t, e, i) => {
      r.controller.control && r.controller.setTranslate(e, i)
    }), e("setTransition", (t, e, i) => {
      r.controller.control && r.controller.setTransition(e, i)
    }), Object.assign(r.controller, {
      setTranslate: function (t, e) {
        var i = r.controller.control;
        let s, n;
        var a = r.constructor;

        function o(t) {
          var e, i = r.rtlTranslate ? -r.translate : r.translate;
          "slide" === r.params.controller.by && (e = t, r.controller.spline || (r.controller.spline = r.params.loop ? new l(r.slidesGrid, e.slidesGrid) : new l(r.snapGrid, e.snapGrid)), n = -r.controller.spline.interpolate(-i)), n && "container" !== r.params.controller.by || (s = (t.maxTranslate() - t.minTranslate()) / (r.maxTranslate() - r.minTranslate()), n = (i - r.minTranslate()) * s + t.minTranslate()), r.params.controller.inverse && (n = t.maxTranslate() - n), t.updateProgress(n), t.setTranslate(n, r), t.updateActiveIndex(), t.updateSlidesClasses()
        }
        if (Array.isArray(i))
          for (let t = 0; t < i.length; t += 1) i[t] !== e && i[t] instanceof a && o(i[t]);
        else i instanceof a && e !== i && o(i)
      },
      setTransition: function (e, t) {
        const i = r.constructor,
          s = r.controller.control;
        let n;

        function a(t) {
          t.setTransition(e, r), 0 !== e && (t.transitionStart(), t.params.autoHeight && C(() => {
            t.updateAutoHeight()
          }), t.$wrapperEl.transitionEnd(() => {
            s && (t.params.loop && "slide" === r.params.controller.by && t.loopFix(), t.transitionEnd())
          }))
        }
        if (Array.isArray(s))
          for (n = 0; n < s.length; n += 1) s[n] !== t && s[n] instanceof i && a(s[n]);
        else s instanceof i && t !== s && a(s)
      }
    })
  }, function ({
    swiper: l,
    extendParams: t,
    on: e
  }) {
    t({
      a11y: {
        enabled: !0,
        notificationClass: "swiper-notification",
        prevSlideMessage: "Previous slide",
        nextSlideMessage: "Next slide",
        firstSlideMessage: "This is the first slide",
        lastSlideMessage: "This is the last slide",
        paginationBulletMessage: "Go to slide {{index}}",
        slideLabelMessage: "{{index}} / {{slidesLength}}",
        containerMessage: null,
        containerRoleDescriptionMessage: null,
        itemRoleDescriptionMessage: null,
        slideRole: "group"
      }
    });
    let c = null;

    function s(t) {
      const e = c;
      0 !== e.length && (e.html(""), e.html(t))
    }

    function n(t) {
      t.attr("tabIndex", "0")
    }

    function i(t) {
      t.attr("tabIndex", "-1")
    }

    function d(t, e) {
      t.attr("role", e)
    }

    function h(t, e) {
      t.attr("aria-roledescription", e)
    }

    function u(t, e) {
      t.attr("aria-label", e)
    }

    function a(t) {
      t.attr("aria-disabled", !0)
    }

    function o(t) {
      t.attr("aria-disabled", !1)
    }

    function p(t) {
      if (13 === t.keyCode || 32 === t.keyCode) {
        const e = l.params.a11y,
          i = P(t.target);
        l.navigation && l.navigation.$nextEl && i.is(l.navigation.$nextEl) && (l.isEnd && !l.params.loop || l.slideNext(), l.isEnd ? s(e.lastSlideMessage) : s(e.nextSlideMessage)), l.navigation && l.navigation.$prevEl && i.is(l.navigation.$prevEl) && (l.isBeginning && !l.params.loop || l.slidePrev(), l.isBeginning ? s(e.firstSlideMessage) : s(e.prevSlideMessage)), l.pagination && i.is(O(l.params.pagination.bulletClass)) && i[0].click()
      }
    }

    function r() {
      var t, e;
      l.params.loop || l.params.rewind || !l.navigation || ({
        $nextEl: t,
        $prevEl: e
      } = l.navigation, e && 0 < e.length && (l.isBeginning ? (a(e), i(e)) : (o(e), n(e))), t && 0 < t.length && (l.isEnd ? (a(t), i(t)) : (o(t), n(t))))
    }

    function f() {
      return l.pagination && l.pagination.bullets && l.pagination.bullets.length
    }

    function m() {
      return f() && l.params.pagination.clickable
    }
    const g = (t, e, i) => {
      n(t), "BUTTON" !== t[0].tagName && (d(t, "button"), t.on("keydown", p)), u(t, i), t.attr("aria-controls", e)
    };
    e("beforeInit", () => {
      c = P(`<span class="${l.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
    }), e("afterInit", () => {
      l.params.a11y.enabled && (function () {
        const n = l.params.a11y;
        l.$el.append(c);
        var t = l.$el;
        n.containerRoleDescriptionMessage && h(t, n.containerRoleDescriptionMessage), n.containerMessage && u(t, n.containerMessage);
        const e = l.$wrapperEl,
          i = e.attr("id") || `swiper-wrapper-${t=16,"x".repeat(t).replace(/x/g,()=>Math.round(16*Math.random()).toString(16))}`,
          s = l.params.autoplay && l.params.autoplay.enabled ? "off" : "polite";
        e.attr("id", i), e.attr("aria-live", s), n.itemRoleDescriptionMessage && h(P(l.slides), n.itemRoleDescriptionMessage), d(P(l.slides), n.slideRole);
        const a = (l.params.loop ? l.slides.filter(t => !t.classList.contains(l.params.slideDuplicateClass)) : l.slides).length;
        let o, r;
        l.slides.each((t, e) => {
          const i = P(t),
            s = l.params.loop ? parseInt(i.attr("data-swiper-slide-index"), 10) : e;
          u(i, n.slideLabelMessage.replace(/\{\{index\}\}/, s + 1).replace(/\{\{slidesLength\}\}/, a))
        }), l.navigation && l.navigation.$nextEl && (o = l.navigation.$nextEl), l.navigation && l.navigation.$prevEl && (r = l.navigation.$prevEl), o && o.length && g(o, i, n.nextSlideMessage), r && r.length && g(r, i, n.prevSlideMessage), m() && l.pagination.$el.on("keydown", O(l.params.pagination.bulletClass), p)
      }(), r())
    }), e("toEdge", () => {
      l.params.a11y.enabled && r()
    }), e("fromEdge", () => {
      l.params.a11y.enabled && r()
    }), e("paginationUpdate", () => {
      l.params.a11y.enabled && function () {
        const i = l.params.a11y;
        f() && l.pagination.bullets.each(t => {
          const e = P(t);
          l.params.pagination.clickable && (n(e), l.params.pagination.renderBullet || (d(e, "button"), u(e, i.paginationBulletMessage.replace(/\{\{index\}\}/, e.index() + 1)))), e.is(`.${l.params.pagination.bulletActiveClass}`) ? e.attr("aria-current", "true") : e.removeAttr("aria-current")
        })
      }()
    }), e("destroy", () => {
      l.params.a11y.enabled && function () {
        let t, e;
        c && 0 < c.length && c.remove(), l.navigation && l.navigation.$nextEl && (t = l.navigation.$nextEl), l.navigation && l.navigation.$prevEl && (e = l.navigation.$prevEl), t && t.off("keydown", p), e && e.off("keydown", p), m() && l.pagination.$el.off("keydown", O(l.params.pagination.bulletClass), p)
      }()
    })
  }, function ({
    swiper: o,
    extendParams: t,
    on: e
  }) {
    t({
      history: {
        enabled: !1,
        root: "",
        replaceState: !1,
        key: "slides"
      }
    });
    let r = !1,
      i = {};
    const l = t => t.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
      s = t => {
        var e = A();
        let i;
        i = t ? new URL(t) : e.location;
        t = i.pathname.slice(1).split("/").filter(t => "" !== t), e = t.length;
        return {
          key: t[e - 2],
          value: t[e - 1]
        }
      },
      n = (i, s) => {
        const n = A();
        if (r && o.params.history.enabled) {
          let t;
          t = o.params.url ? new URL(o.params.url) : n.location;
          const a = o.slides.eq(s);
          let e = l(a.attr("data-history"));
          if (0 < o.params.history.root.length) {
            let t = o.params.history.root;
            "/" === t[t.length - 1] && (t = t.slice(0, t.length - 1)), e = `${t}/${i}/${e}`
          } else t.pathname.includes(i) || (e = `${i}/${e}`);
          i = n.history.state;
          i && i.value === e || (o.params.history.replaceState ? n.history.replaceState({
            value: e
          }, null, e) : n.history.pushState({
            value: e
          }, null, e))
        }
      },
      a = (i, s, n) => {
        if (s)
          for (let t = 0, e = o.slides.length; t < e; t += 1) {
            const a = o.slides.eq(t);
            if (l(a.attr("data-history")) === s && !a.hasClass(o.params.slideDuplicateClass)) {
              const s = a.index();
              o.slideTo(s, i, n)
            }
          } else o.slideTo(0, i, n)
      },
      c = () => {
        i = s(o.params.url), a(o.params.speed, o.paths.value, !1)
      };
    e("init", () => {
      o.params.history.enabled && (() => {
        const t = A();
        if (o.params.history) {
          if (!t.history || !t.history.pushState) return o.params.history.enabled = !1, o.params.hashNavigation.enabled = !0;
          r = !0, i = s(o.params.url), (i.key || i.value) && (a(0, i.value, o.params.runCallbacksOnInit), o.params.history.replaceState || t.addEventListener("popstate", c))
        }
      })()
    }), e("destroy", () => {
      o.params.history.enabled && (() => {
        const t = A();
        o.params.history.replaceState || t.removeEventListener("popstate", c)
      })()
    }), e("transitionEnd _freeModeNoMomentumRelease", () => {
      r && n(o.params.history.key, o.activeIndex)
    }), e("slideChange", () => {
      r && o.params.cssMode && n(o.params.history.key, o.activeIndex)
    })
  }, function ({
    swiper: n,
    extendParams: t,
    emit: i,
    on: e
  }) {
    let a = !1;
    const o = x(),
      r = A();
    t({
      hashNavigation: {
        enabled: !1,
        replaceState: !1,
        watchState: !1
      }
    });
    const l = () => {
        i("hashChange");
        var t = o.location.hash.replace("#", "");
        if (t !== n.slides.eq(n.activeIndex).attr("data-hash")) {
          const i = n.$wrapperEl.children(`.${n.params.slideClass}[data-hash="${t}"]`).index();
          void 0 !== i && n.slideTo(i)
        }
      },
      s = () => {
        if (a && n.params.hashNavigation.enabled)
          if (n.params.hashNavigation.replaceState && r.history && r.history.replaceState) r.history.replaceState(null, null, `#${n.slides.eq(n.activeIndex).attr("data-hash")}` || ""), i("hashSet");
          else {
            const t = n.slides.eq(n.activeIndex),
              e = t.attr("data-hash") || t.attr("data-history");
            o.location.hash = e || "", i("hashSet")
          }
      };
    e("init", () => {
      n.params.hashNavigation.enabled && (() => {
        if (!(!n.params.hashNavigation.enabled || n.params.history && n.params.history.enabled)) {
          a = !0;
          const i = o.location.hash.replace("#", "");
          if (i)
            for (let t = 0, e = n.slides.length; t < e; t += 1) {
              const s = n.slides.eq(t);
              if ((s.attr("data-hash") || s.attr("data-history")) === i && !s.hasClass(n.params.slideDuplicateClass)) {
                const i = s.index();
                n.slideTo(i, 0, n.params.runCallbacksOnInit, !0)
              }
            }
          n.params.hashNavigation.watchState && P(r).on("hashchange", l)
        }
      })()
    }), e("destroy", () => {
      n.params.hashNavigation.enabled && n.params.hashNavigation.watchState && P(r).off("hashchange", l)
    }), e("transitionEnd _freeModeNoMomentumRelease", () => {
      a && s()
    }), e("slideChange", () => {
      a && n.params.cssMode && s()
    })
  }, function ({
    swiper: s,
    extendParams: t,
    on: e,
    emit: i
  }) {
    let n;

    function a() {
      const t = s.slides.eq(s.activeIndex);
      let e = s.params.autoplay.delay;
      t.attr("data-swiper-autoplay") && (e = t.attr("data-swiper-autoplay") || s.params.autoplay.delay), clearTimeout(n), n = C(() => {
        let t;
        s.params.autoplay.reverseDirection ? s.params.loop ? (s.loopFix(), t = s.slidePrev(s.params.speed, !0, !0), i("autoplay")) : s.isBeginning ? s.params.autoplay.stopOnLastSlide ? r() : (t = s.slideTo(s.slides.length - 1, s.params.speed, !0, !0), i("autoplay")) : (t = s.slidePrev(s.params.speed, !0, !0), i("autoplay")) : s.params.loop ? (s.loopFix(), t = s.slideNext(s.params.speed, !0, !0), i("autoplay")) : s.isEnd ? s.params.autoplay.stopOnLastSlide ? r() : (t = s.slideTo(0, s.params.speed, !0, !0), i("autoplay")) : (t = s.slideNext(s.params.speed, !0, !0), i("autoplay")), (s.params.cssMode && s.autoplay.running || !1 === t) && a()
      }, e)
    }

    function o() {
      return void 0 === n && !s.autoplay.running && (s.autoplay.running = !0, i("autoplayStart"), a(), !0)
    }

    function r() {
      return !!s.autoplay.running && void 0 !== n && (n && (clearTimeout(n), n = void 0), s.autoplay.running = !1, i("autoplayStop"), !0)
    }

    function l(t) {
      s.autoplay.running && (s.autoplay.paused || (n && clearTimeout(n), s.autoplay.paused = !0, 0 !== t && s.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach(t => {
        s.$wrapperEl[0].addEventListener(t, d)
      }) : (s.autoplay.paused = !1, a())))
    }

    function c() {
      var t = x();
      "hidden" === t.visibilityState && s.autoplay.running && l(), "visible" === t.visibilityState && s.autoplay.paused && (a(), s.autoplay.paused = !1)
    }

    function d(t) {
      s && !s.destroyed && s.$wrapperEl && t.target === s.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach(t => {
        s.$wrapperEl[0].removeEventListener(t, d)
      }), s.autoplay.paused = !1, (s.autoplay.running ? a : r)())
    }

    function h() {
      (s.params.autoplay.disableOnInteraction ? r : l)(), ["transitionend", "webkitTransitionEnd"].forEach(t => {
        s.$wrapperEl[0].removeEventListener(t, d)
      })
    }

    function u() {
      s.params.autoplay.disableOnInteraction || (s.autoplay.paused = !1, a())
    }
    t({
      autoplay: {
        enabled: !(s.autoplay = {
          running: !1,
          paused: !1
        }),
        delay: 3e3,
        waitForTransition: !0,
        disableOnInteraction: !0,
        stopOnLastSlide: !1,
        reverseDirection: !1,
        pauseOnMouseEnter: !1
      }
    }), e("init", () => {
      s.params.autoplay.enabled && (o(), x().addEventListener("visibilitychange", c), s.params.autoplay.pauseOnMouseEnter && (s.$el.on("mouseenter", h), s.$el.on("mouseleave", u)))
    }), e("beforeTransitionStart", (t, e, i) => {
      s.autoplay.running && (i || !s.params.autoplay.disableOnInteraction ? s.autoplay.pause(e) : r())
    }), e("sliderFirstMove", () => {
      s.autoplay.running && (s.params.autoplay.disableOnInteraction ? r : l)()
    }), e("touchEnd", () => {
      s.params.cssMode && s.autoplay.paused && !s.params.autoplay.disableOnInteraction && a()
    }), e("destroy", () => {
      s.$el.off("mouseenter", h), s.$el.off("mouseleave", u), s.autoplay.running && r(), x().removeEventListener("visibilitychange", c)
    }), Object.assign(s.autoplay, {
      pause: l,
      run: a,
      start: o,
      stop: r
    })
  }, function ({
    swiper: l,
    extendParams: t,
    on: e
  }) {
    t({
      thumbs: {
        swiper: null,
        multipleActiveThumbs: !0,
        autoScrollOffset: 0,
        slideThumbActiveClass: "swiper-slide-thumb-active",
        thumbsContainerClass: "swiper-thumbs"
      }
    });
    let i = !1,
      s = !1;

    function n() {
      var t = l.thumbs.swiper;
      if (t) {
        const i = t.clickedIndex,
          s = t.clickedSlide;
        if (!(s && P(s).hasClass(l.params.thumbs.slideThumbActiveClass) || null == i)) {
          let e;
          if (e = t.params.loop ? parseInt(P(t.clickedSlide).attr("data-swiper-slide-index"), 10) : i, l.params.loop) {
            let t = l.activeIndex;
            l.slides.eq(t).hasClass(l.params.slideDuplicateClass) && (l.loopFix(), l._clientLeft = l.$wrapperEl[0].clientLeft, t = l.activeIndex);
            const i = l.slides.eq(t).prevAll(`[data-swiper-slide-index="${e}"]`).eq(0).index(),
              s = l.slides.eq(t).nextAll(`[data-swiper-slide-index="${e}"]`).eq(0).index();
            e = void 0 === i || void 0 !== s && s - t < t - i ? s : i
          }
          l.slideTo(e)
        }
      }
    }

    function a() {
      var {
        thumbs: t
      } = l.params;
      if (i) return !1;
      i = !0;
      const e = l.constructor;
      if (t.swiper instanceof e) l.thumbs.swiper = t.swiper, Object.assign(l.thumbs.swiper.originalParams, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      }), Object.assign(l.thumbs.swiper.params, {
        watchSlidesProgress: !0,
        slideToClickedSlide: !1
      });
      else if (c(t.swiper)) {
        const i = Object.assign({}, t.swiper);
        Object.assign(i, {
          watchSlidesProgress: !0,
          slideToClickedSlide: !1
        }), l.thumbs.swiper = new e(i), s = !0
      }
      return l.thumbs.swiper.$el.addClass(l.params.thumbs.thumbsContainerClass), l.thumbs.swiper.on("tap", n), !0
    }

    function o(s) {
      const n = l.thumbs.swiper;
      if (n) {
        const a = "auto" === n.params.slidesPerView ? n.slidesPerViewDynamic() : n.params.slidesPerView,
          o = l.params.thumbs.autoScrollOffset,
          r = o && !n.params.loop;
        if (l.realIndex !== n.realIndex || r) {
          let t, e, i = n.activeIndex;
          if (n.params.loop) {
            n.slides.eq(i).hasClass(n.params.slideDuplicateClass) && (n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft, i = n.activeIndex);
            const s = n.slides.eq(i).prevAll(`[data-swiper-slide-index="${l.realIndex}"]`).eq(0).index(),
              a = n.slides.eq(i).nextAll(`[data-swiper-slide-index="${l.realIndex}"]`).eq(0).index();
            t = void 0 === s ? a : void 0 === a ? s : a - i == i - s ? 1 < n.params.slidesPerGroup ? a : i : a - i < i - s ? a : s, e = l.activeIndex > l.previousIndex ? "next" : "prev"
          } else t = l.realIndex, e = t > l.previousIndex ? "next" : "prev";
          r && (t += "next" === e ? o : -1 * o), n.visibleSlidesIndexes && n.visibleSlidesIndexes.indexOf(t) < 0 && (n.params.centeredSlides ? t = t > i ? t - Math.floor(a / 2) + 1 : t + Math.floor(a / 2) - 1 : t > i && n.params.slidesPerGroup, n.slideTo(t, s ? 0 : void 0))
        }
        let e = 1;
        var i = l.params.thumbs.slideThumbActiveClass;
        if (1 < l.params.slidesPerView && !l.params.centeredSlides && (e = l.params.slidesPerView), l.params.thumbs.multipleActiveThumbs || (e = 1), e = Math.floor(e), n.slides.removeClass(i), n.params.loop || n.params.virtual && n.params.virtual.enabled)
          for (let t = 0; t < e; t += 1) n.$wrapperEl.children(`[data-swiper-slide-index="${l.realIndex+t}"]`).addClass(i);
        else
          for (let t = 0; t < e; t += 1) n.slides.eq(l.realIndex + t).addClass(i)
      }
    }
    l.thumbs = {
      swiper: null
    }, e("beforeInit", () => {
      var {
        thumbs: t
      } = l.params;
      t && t.swiper && (a(), o(!0))
    }), e("slideChange update resize observerUpdate", () => {
      l.thumbs.swiper && o()
    }), e("setTransition", (t, e) => {
      const i = l.thumbs.swiper;
      i && i.setTransition(e)
    }), e("beforeDestroy", () => {
      const t = l.thumbs.swiper;
      t && s && t && t.destroy()
    }), Object.assign(l.thumbs, {
      init: a,
      update: o
    })
  }, function ({
    swiper: p,
    extendParams: t,
    emit: f,
    once: m
  }) {
    t({
      freeMode: {
        enabled: !1,
        momentum: !0,
        momentumRatio: 1,
        momentumBounce: !0,
        momentumBounceRatio: 1,
        momentumVelocityRatio: 1,
        sticky: !1,
        minimumVelocity: .02
      }
    }), Object.assign(p, {
      freeMode: {
        onTouchMove: function () {
          const {
            touchEventsData: t,
            touches: e
          } = p;
          0 === t.velocities.length && t.velocities.push({
            position: e[p.isHorizontal() ? "startX" : "startY"],
            time: t.touchStartTime
          }), t.velocities.push({
            position: e[p.isHorizontal() ? "currentX" : "currentY"],
            time: g()
          })
        },
        onTouchEnd: function ({
          currentPos: a
        }) {
          const {
            params: o,
            $wrapperEl: r,
            rtlTranslate: l,
            snapGrid: c,
            touchEventsData: d
          } = p, h = g() - d.touchStartTime;
          if (a < -p.minTranslate()) p.slideTo(p.activeIndex);
          else if (a > -p.maxTranslate()) p.slides.length < c.length ? p.slideTo(c.length - 1) : p.slideTo(p.slides.length - 1);
          else {
            if (o.freeMode.momentum) {
              if (1 < d.velocities.length) {
                const u = d.velocities.pop(),
                  f = d.velocities.pop(),
                  m = u.position - f.position,
                  r = u.time - f.time;
                p.velocity = m / r, p.velocity /= 2, Math.abs(p.velocity) < o.freeMode.minimumVelocity && (p.velocity = 0), (150 < r || 300 < g() - u.time) && (p.velocity = 0)
              } else p.velocity = 0;
              p.velocity *= o.freeMode.momentumVelocityRatio, d.velocities.length = 0;
              let t = 1e3 * o.freeMode.momentumRatio;
              const h = p.velocity * t;
              let i = p.translate + h;
              l && (i = -i);
              let e, s = !1;
              a = 20 * Math.abs(p.velocity) * o.freeMode.momentumBounceRatio;
              let n;
              if (i < p.maxTranslate()) o.freeMode.momentumBounce ? (i + p.maxTranslate() < -a && (i = p.maxTranslate() - a), e = p.maxTranslate(), s = !0, d.allowMomentumBounce = !0) : i = p.maxTranslate(), o.loop && o.centeredSlides && (n = !0);
              else if (i > p.minTranslate()) o.freeMode.momentumBounce ? (i - p.minTranslate() > a && (i = p.minTranslate() + a), e = p.minTranslate(), s = !0, d.allowMomentumBounce = !0) : i = p.minTranslate(), o.loop && o.centeredSlides && (n = !0);
              else if (o.freeMode.sticky) {
                let e;
                for (let t = 0; t < c.length; t += 1)
                  if (c[t] > -i) {
                    e = t;
                    break
                  } i = Math.abs(c[e] - i) < Math.abs(c[e - 1] - i) || "next" === p.swipeDirection ? c[e] : c[e - 1], i = -i
              }
              if (n && m("transitionEnd", () => {
                  p.loopFix()
                }), 0 !== p.velocity) {
                if (t = l ? Math.abs((-i - p.translate) / p.velocity) : Math.abs((i - p.translate) / p.velocity), o.freeMode.sticky) {
                  const f = Math.abs((l ? -i : i) - p.translate),
                    m = p.slidesSizesGrid[p.activeIndex];
                  t = f < m ? o.speed : f < 2 * m ? 1.5 * o.speed : 2.5 * o.speed
                }
              } else if (o.freeMode.sticky) return void p.slideToClosest();
              o.freeMode.momentumBounce && s ? (p.updateProgress(e), p.setTransition(t), p.setTranslate(i), p.transitionStart(!0, p.swipeDirection), p.animating = !0, r.transitionEnd(() => {
                p && !p.destroyed && d.allowMomentumBounce && (f("momentumBounce"), p.setTransition(o.speed), setTimeout(() => {
                  p.setTranslate(e), r.transitionEnd(() => {
                    p && !p.destroyed && p.transitionEnd()
                  })
                }, 0))
              })) : p.velocity ? (f("_freeModeNoMomentumRelease"), p.updateProgress(i), p.setTransition(t), p.setTranslate(i), p.transitionStart(!0, p.swipeDirection), p.animating || (p.animating = !0, r.transitionEnd(() => {
                p && !p.destroyed && p.transitionEnd()
              }))) : p.updateProgress(i), p.updateActiveIndex(), p.updateSlidesClasses()
            } else {
              if (o.freeMode.sticky) return void p.slideToClosest();
              o.freeMode && f("_freeModeNoMomentumRelease")
            }(!o.freeMode.momentum || h >= o.longSwipesMs) && (p.updateProgress(), p.updateActiveIndex(), p.updateSlidesClasses())
          }
        }
      }
    })
  }, function ({
    swiper: h,
    extendParams: t
  }) {
    let u, p, f;
    t({
      grid: {
        rows: 1,
        fill: "column"
      }
    }), h.grid = {
      initSlides: t => {
        var {
          slidesPerView: e
        } = h.params, {
          rows: i,
          fill: s
        } = h.params.grid;
        p = u / i, f = Math.floor(t / i), u = Math.floor(t / i) === t / i ? t : Math.ceil(t / i) * i, "auto" !== e && "row" === s && (u = Math.max(u, e * i))
      },
      updateSlide: (t, e, i, s) => {
        var {
          slidesPerGroup: n,
          spaceBetween: a
        } = h.params, {
          rows: o,
          fill: r
        } = h.params.grid;
        let l, c, d;
        if ("row" === r && 1 < n) {
          const h = Math.floor(t / (n * o)),
            p = t - o * n * h,
            f = 0 === h ? n : Math.min(Math.ceil((i - h * o * n) / o), n);
          d = Math.floor(p / f), c = p - d * f + h * n, l = c + d * u / o, e.css({
            "-webkit-order": l,
            order: l
          })
        } else "column" === r ? (c = Math.floor(t / o), d = t - c * o, (c > f || c === f && d === o - 1) && (d += 1, d >= o && (d = 0, c += 1))) : (d = Math.floor(t / p), c = t - d * p);
        e.css(s("margin-top"), 0 !== d ? a && `${a}px` : "")
      },
      updateWrapperSize: (i, s, t) => {
        var {
          spaceBetween: e,
          centeredSlides: n,
          roundLengths: a
        } = h.params, {
          rows: o
        } = h.params.grid;
        if (h.virtualSize = (i + e) * u, h.virtualSize = Math.ceil(h.virtualSize / o) - e, h.$wrapperEl.css({
            [t("width")]: `${h.virtualSize+e}px`
          }), n) {
          s.splice(0, s.length);
          const i = [];
          for (let e = 0; e < s.length; e += 1) {
            let t = s[e];
            a && (t = Math.floor(t)), s[e] < h.virtualSize + s[0] && i.push(t)
          }
          s.push(...i)
        }
      }
    }
  }, function ({
    swiper: t
  }) {
    Object.assign(t, {
      appendSlide: function (e) {
        const {
          $wrapperEl: i,
          params: t
        } = this;
        if (t.loop && this.loopDestroy(), "object" == typeof e && "length" in e)
          for (let t = 0; t < e.length; t += 1) e[t] && i.append(e[t]);
        else i.append(e);
        t.loop && this.loopCreate(), t.observer || this.update()
      }.bind(t),
      prependSlide: function (e) {
        const {
          params: t,
          $wrapperEl: i,
          activeIndex: s
        } = this;
        t.loop && this.loopDestroy();
        let n = s + 1;
        if ("object" == typeof e && "length" in e) {
          for (let t = 0; t < e.length; t += 1) e[t] && i.prepend(e[t]);
          n = s + e.length
        } else i.prepend(e);
        t.loop && this.loopCreate(), t.observer || this.update(), this.slideTo(n, 0, !1)
      }.bind(t),
      addSlide: function (e, i) {
        const s = this,
          {
            $wrapperEl: n,
            params: a,
            activeIndex: t
          } = s;
        let o = t;
        a.loop && (o -= s.loopedSlides, s.loopDestroy(), s.slides = n.children(`.${a.slideClass}`));
        var r = s.slides.length;
        if (e <= 0) s.prependSlide(i);
        else if (r <= e) s.appendSlide(i);
        else {
          let t = o > e ? o + 1 : o;
          const l = [];
          for (let t = r - 1; t >= e; --t) {
            const e = s.slides.eq(t);
            e.remove(), l.unshift(e)
          }
          if ("object" == typeof i && "length" in i) {
            for (let t = 0; t < i.length; t += 1) i[t] && n.append(i[t]);
            t = o > e ? o + i.length : o
          } else n.append(i);
          for (let t = 0; t < l.length; t += 1) n.append(l[t]);
          a.loop && s.loopCreate(), a.observer || s.update(), a.loop ? s.slideTo(t + s.loopedSlides, 0, !1) : s.slideTo(t, 0, !1)
        }
      }.bind(t),
      removeSlide: function (e) {
        const i = this,
          {
            params: t,
            $wrapperEl: s,
            activeIndex: n
          } = i;
        let a = n;
        t.loop && (a -= i.loopedSlides, i.loopDestroy(), i.slides = s.children(`.${t.slideClass}`));
        let o, r = a;
        if ("object" == typeof e && "length" in e) {
          for (let t = 0; t < e.length; t += 1) o = e[t], i.slides[o] && i.slides.eq(o).remove(), o < r && --r;
          r = Math.max(r, 0)
        } else o = e, i.slides[o] && i.slides.eq(o).remove(), o < r && --r, r = Math.max(r, 0);
        t.loop && i.loopCreate(), t.observer || i.update(), t.loop ? i.slideTo(r + i.loopedSlides, 0, !1) : i.slideTo(r, 0, !1)
      }.bind(t),
      removeAllSlides: function () {
        const e = [];
        for (let t = 0; t < this.slides.length; t += 1) e.push(t);
        this.removeSlide(e)
      }.bind(t)
    })
  }, function ({
    swiper: o,
    extendParams: t,
    on: e
  }) {
    t({
      fadeEffect: {
        crossFade: !1,
        transformEl: null
      }
    }), $({
      effect: "fade",
      swiper: o,
      on: e,
      setTranslate: () => {
        const {
          slides: s
        } = o, n = o.params.fadeEffect;
        for (let i = 0; i < s.length; i += 1) {
          const s = o.slides.eq(i);
          let t = -s[0].swiperSlideOffset;
          o.params.virtualTranslate || (t -= o.translate);
          let e = 0;
          o.isHorizontal() || (e = t, t = 0);
          var a = o.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(s[0].progress), 0) : 1 + Math.min(Math.max(s[0].progress, -1), 0);
          L(n, s).css({
            opacity: a
          }).transform(`translate3d(${t}px, ${e}px, 0px)`)
        }
      },
      setTransition: t => {
        var {
          transformEl: e
        } = o.params.fadeEffect;
        (e ? o.slides.find(e) : o.slides).transition(t), N({
          swiper: o,
          duration: t,
          transformEl: e,
          allSlides: !0
        })
      },
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        spaceBetween: 0,
        virtualTranslate: !o.params.cssMode
      })
    })
  }, function ({
    swiper: a,
    extendParams: t,
    on: e
  }) {
    t({
      cubeEffect: {
        slideShadows: !0,
        shadow: !0,
        shadowOffset: 20,
        shadowScale: .94
      }
    }), $({
      effect: "cube",
      swiper: a,
      on: e,
      setTranslate: () => {
        const {
          $el: r,
          $wrapperEl: t,
          slides: l,
          width: e,
          height: i,
          rtlTranslate: c,
          size: d,
          browser: h
        } = a, u = a.params.cubeEffect, p = a.isHorizontal(), f = a.virtual && a.params.virtual.enabled;
        let s, m = 0;
        u.shadow && (p ? (s = t.find(".swiper-cube-shadow"), 0 === s.length && (s = P('<div class="swiper-cube-shadow"></div>'), t.append(s)), s.css({
          height: `${e}px`
        })) : (s = r.find(".swiper-cube-shadow"), 0 === s.length && (s = P('<div class="swiper-cube-shadow"></div>'), r.append(s))));
        for (let o = 0; o < l.length; o += 1) {
          const r = l.eq(o);
          let t = o;
          f && (t = parseInt(r.attr("data-swiper-slide-index"), 10));
          let e = 90 * t,
            i = Math.floor(e / 360);
          c && (e = -e, i = Math.floor(-e / 360));
          const h = Math.max(Math.min(r[0].progress, 1), -1);
          let s = 0,
            n = 0,
            a = 0;
          t % 4 == 0 ? (s = 4 * -i * d, a = 0) : (t - 1) % 4 == 0 ? (s = 0, a = 4 * -i * d) : (t - 2) % 4 == 0 ? (s = d + 4 * i * d, a = d) : (t - 3) % 4 == 0 && (s = -d, a = 3 * d + 4 * d * i), c && (s = -s), p || (n = s, s = 0);
          var g = `rotateX(${p?0:-e}deg) rotateY(${p?e:0}deg) translate3d(${s}px, ${n}px, ${a}px)`;
          if (h <= 1 && -1 < h && (m = 90 * t + 90 * h, c && (m = 90 * -t - 90 * h)), r.transform(g), u.slideShadows) {
            let t = p ? r.find(".swiper-slide-shadow-left") : r.find(".swiper-slide-shadow-top"),
              e = p ? r.find(".swiper-slide-shadow-right") : r.find(".swiper-slide-shadow-bottom");
            0 === t.length && (t = P(`<div class="swiper-slide-shadow-${p?"left":"top"}"></div>`), r.append(t)), 0 === e.length && (e = P(`<div class="swiper-slide-shadow-${p?"right":"bottom"}"></div>`), r.append(e)), t.length && (t[0].style.opacity = Math.max(-h, 0)), e.length && (e[0].style.opacity = Math.max(h, 0))
          }
        }
        if (t.css({
            "-webkit-transform-origin": `50% 50% -${d/2}px`,
            "transform-origin": `50% 50% -${d/2}px`
          }), u.shadow)
          if (p) s.transform(`translate3d(0px, ${e/2+u.shadowOffset}px, ${-e/2}px) rotateX(90deg) rotateZ(0deg) scale(${u.shadowScale})`);
          else {
            const a = Math.abs(m) - 90 * Math.floor(Math.abs(m) / 90),
              r = 1.5 - (Math.sin(2 * a * Math.PI / 360) / 2 + Math.cos(2 * a * Math.PI / 360) / 2),
              t = u.shadowScale,
              l = u.shadowScale / r,
              e = u.shadowOffset;
            s.transform(`scale3d(${t}, 1, ${l}) translate3d(0px, ${i/2+e}px, ${-i/2/l}px) rotateX(-90deg)`)
          } var n = h.isSafari || h.isWebView ? -d / 2 : 0;
        t.transform(`translate3d(0px,0,${n}px) rotateX(${a.isHorizontal()?0:m}deg) rotateY(${a.isHorizontal()?-m:0}deg)`)
      },
      setTransition: t => {
        const {
          $el: e,
          slides: i
        } = a;
        i.transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), a.params.cubeEffect.shadow && !a.isHorizontal() && e.find(".swiper-cube-shadow").transition(t)
      },
      perspective: () => !0,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: !1,
        virtualTranslate: !0
      })
    })
  }, function ({
    swiper: h,
    extendParams: t,
    on: e
  }) {
    t({
      flipEffect: {
        slideShadows: !0,
        limitRotation: !0,
        transformEl: null
      }
    }), $({
      effect: "flip",
      swiper: h,
      on: e,
      setTranslate: () => {
        const {
          slides: o,
          rtlTranslate: r
        } = h, l = h.params.flipEffect;
        for (let a = 0; a < o.length; a += 1) {
          const d = o.eq(a);
          let i = d[0].progress;
          h.params.flipEffect.limitRotation && (i = Math.max(Math.min(d[0].progress, 1), -1));
          var c = d[0].swiperSlideOffset;
          let t = -180 * i,
            e = 0,
            s = h.params.cssMode ? -c - h.translate : -c,
            n = 0;
          if (h.isHorizontal() ? r && (t = -t) : (n = s, s = 0, e = -t, t = 0), d[0].style.zIndex = -Math.abs(Math.round(i)) + o.length, l.slideShadows) {
            let t = h.isHorizontal() ? d.find(".swiper-slide-shadow-left") : d.find(".swiper-slide-shadow-top"),
              e = h.isHorizontal() ? d.find(".swiper-slide-shadow-right") : d.find(".swiper-slide-shadow-bottom");
            0 === t.length && (t = H(l, d, h.isHorizontal() ? "left" : "top")), 0 === e.length && (e = H(l, d, h.isHorizontal() ? "right" : "bottom")), t.length && (t[0].style.opacity = Math.max(-i, 0)), e.length && (e[0].style.opacity = Math.max(i, 0))
          }
          c = `translate3d(${s}px, ${n}px, 0px) rotateX(${e}deg) rotateY(${t}deg)`;
          L(l, d).transform(c)
        }
      },
      setTransition: t => {
        var {
          transformEl: e
        } = h.params.flipEffect;
        (e ? h.slides.find(e) : h.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t), N({
          swiper: h,
          duration: t,
          transformEl: e
        })
      },
      perspective: () => !0,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        spaceBetween: 0,
        virtualTranslate: !h.params.cssMode
      })
    })
  }, function ({
    swiper: i,
    extendParams: t,
    on: e
  }) {
    t({
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        scale: 1,
        modifier: 1,
        slideShadows: !0,
        transformEl: null
      }
    }), $({
      effect: "coverflow",
      swiper: i,
      on: e,
      setTranslate: () => {
        const {
          width: l,
          height: c,
          slides: d,
          slidesSizesGrid: h
        } = i, u = i.params.coverflowEffect, p = i.isHorizontal(), f = i.translate, m = p ? l / 2 - f : c / 2 - f, g = p ? u.rotate : -u.rotate, v = u.depth;
        for (let r = 0, t = d.length; r < t; r += 1) {
          const l = d.eq(r),
            c = h[r],
            f = (m - l[0].swiperSlideOffset - c / 2) / c * u.modifier;
          let t = p ? g * f : 0,
            e = p ? 0 : g * f,
            i = -v * Math.abs(f),
            s = u.stretch;
          "string" == typeof s && -1 !== s.indexOf("%") && (s = parseFloat(u.stretch) / 100 * c);
          let n = p ? 0 : s * f,
            a = p ? s * f : 0,
            o = 1 - (1 - u.scale) * Math.abs(f);
          Math.abs(a) < .001 && (a = 0), Math.abs(n) < .001 && (n = 0), Math.abs(i) < .001 && (i = 0), Math.abs(t) < .001 && (t = 0), Math.abs(e) < .001 && (e = 0), Math.abs(o) < .001 && (o = 0);
          var b = `translate3d(${a}px,${n}px,${i}px)  rotateX(${e}deg) rotateY(${t}deg) scale(${o})`;
          if (L(u, l).transform(b), l[0].style.zIndex = 1 - Math.abs(Math.round(f)), u.slideShadows) {
            let t = p ? l.find(".swiper-slide-shadow-left") : l.find(".swiper-slide-shadow-top"),
              e = p ? l.find(".swiper-slide-shadow-right") : l.find(".swiper-slide-shadow-bottom");
            0 === t.length && (t = H(u, l, p ? "left" : "top")), 0 === e.length && (e = H(u, l, p ? "right" : "bottom")), t.length && (t[0].style.opacity = 0 < f ? f : 0), e.length && (e[0].style.opacity = 0 < -f ? -f : 0)
          }
        }
      },
      setTransition: t => {
        var {
          transformEl: e
        } = i.params.coverflowEffect;
        (e ? i.slides.find(e) : i.slides).transition(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(t)
      },
      perspective: () => !0,
      overwriteParams: () => ({
        watchSlidesProgress: !0
      })
    })
  }, function ({
    swiper: _,
    extendParams: t,
    on: e
  }) {
    t({
      creativeEffect: {
        transformEl: null,
        limitProgress: 1,
        shadowPerProgress: !1,
        progressMultiplier: 1,
        perspective: !0,
        prev: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        },
        next: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        }
      }
    });
    $({
      effect: "creative",
      swiper: _,
      on: e,
      setTranslate: () => {
        const {
          slides: n,
          $wrapperEl: t,
          slidesSizesGrid: a
        } = _, o = _.params.creativeEffect, {
          progressMultiplier: r
        } = o, l = _.params.centeredSlides;
        if (l) {
          const n = a[0] / 2 - _.params.slidesOffsetBefore || 0;
          t.transform(`translateX(calc(50% - ${n}px))`)
        }
        for (let s = 0; s < n.length; s += 1) {
          const a = n.eq(s),
            p = a[0].progress,
            f = Math.min(Math.max(a[0].progress, -o.limitProgress), o.limitProgress);
          let t = f;
          l || (t = Math.min(Math.max(a[0].originalProgress, -o.limitProgress), o.limitProgress));
          const m = a[0].swiperSlideOffset,
            g = [_.params.cssMode ? -m - _.translate : -m, 0, 0],
            v = [0, 0, 0];
          let e = !1;
          _.isHorizontal() || (g[1] = g[0], g[0] = 0);
          let i = {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            scale: 1,
            opacity: 1
          };
          f < 0 ? (i = o.next, e = !0) : 0 < f && (i = o.prev, e = !0), g.forEach((t, e) => {
            g[e] = `calc(${t}px + (${e=i.translate[e],"string"==typeof e?e:`${e}px`} * ${Math.abs(f*r)}))`
          }), v.forEach((t, e) => {
            v[e] = i.rotate[e] * Math.abs(f * r)
          }), a[0].style.zIndex = -Math.abs(Math.round(p)) + n.length;
          var c = g.join(", "),
            d = `rotateX(${v[0]}deg) rotateY(${v[1]}deg) rotateZ(${v[2]}deg)`,
            h = t < 0 ? `scale(${1+(1-i.scale)*t*r})` : `scale(${1-(1-i.scale)*t*r})`,
            u = t < 0 ? 1 + (1 - i.opacity) * t * r : 1 - (1 - i.opacity) * t * r,
            h = `translate3d(${c}) ${d} ${h}`;
          if (e && i.shadow || !e) {
            let t = a.children(".swiper-slide-shadow");
            if (0 === t.length && i.shadow && (t = H(o, a)), t.length) {
              const n = o.shadowPerProgress ? f * (1 / o.limitProgress) : f;
              t[0].style.opacity = Math.min(Math.max(Math.abs(n), 0), 1)
            }
          }
          const b = L(o, a);
          b.transform(h).css({
            opacity: u
          }), i.origin && b.css("transform-origin", i.origin)
        }
      },
      setTransition: t => {
        var {
          transformEl: e
        } = _.params.creativeEffect;
        (e ? _.slides.find(e) : _.slides).transition(t).find(".swiper-slide-shadow").transition(t), N({
          swiper: _,
          duration: t,
          transformEl: e,
          allSlides: !0
        })
      },
      perspective: () => _.params.creativeEffect.perspective,
      overwriteParams: () => ({
        watchSlidesProgress: !0,
        virtualTranslate: !_.params.cssMode
      })
    })
  }, function ({
    swiper: _,
    extendParams: t,
    on: e
  }) {
    t({
      cardsEffect: {
        slideShadows: !0,
        transformEl: null
      }
    }), $({
      effect: "cards",
      swiper: _,
      on: e,
      setTranslate: () => {
        const {
          slides: r,
          activeIndex: l
        } = _, c = _.params.cardsEffect, {
          startTranslate: d,
          isTouched: h
        } = _.touchEventsData, u = _.translate;
        for (let o = 0; o < r.length; o += 1) {
          const g = r.eq(o),
            v = g[0].progress,
            b = Math.min(Math.max(v, -4), 4);
          let t = g[0].swiperSlideOffset;
          _.params.centeredSlides && !_.params.cssMode && _.$wrapperEl.transform(`translateX(${_.minTranslate()}px)`), _.params.centeredSlides && _.params.cssMode && (t -= r[0].swiperSlideOffset);
          let e = _.params.cssMode ? -t - _.translate : -t,
            i = 0;
          var p = -100 * Math.abs(b);
          let s = 1,
            n = -2 * b,
            a = 8 - .75 * Math.abs(b);
          var f = (o === l || o === l - 1) && 0 < b && b < 1 && (h || _.params.cssMode) && u < d,
            m = (o === l || o === l + 1) && b < 0 && -1 < b && (h || _.params.cssMode) && d < u;
          if (f || m) {
            const _ = (1 - Math.abs((Math.abs(b) - .5) / .5)) ** .5;
            n += -28 * b * _, s += -.5 * _, a += 96 * _, i = -25 * _ * Math.abs(b) + "%"
          }
          if (e = b < 0 ? `calc(${e}px + (${a*Math.abs(b)}%))` : 0 < b ? `calc(${e}px + (-${a*Math.abs(b)}%))` : `${e}px`, !_.isHorizontal()) {
            const _ = i;
            i = e, e = _
          }
          p = `\n        translate3d(${e}, ${i}, ${p}px)\n        rotateZ(${n}deg)\n        scale(${b<0?""+(1+(1-s)*b):""+(1-(1-s)*b)})\n      `;
          if (c.slideShadows) {
            let t = g.find(".swiper-slide-shadow");
            0 === t.length && (t = H(c, g)), t.length && (t[0].style.opacity = Math.min(Math.max((Math.abs(b) - .5) / .5, 0), 1))
          }
          g[0].style.zIndex = -Math.abs(Math.round(v)) + r.length, L(c, g).transform(p)
        }
      },
      setTransition: t => {
        var {
          transformEl: e
        } = _.params.cardsEffect;
        (e ? _.slides.find(e) : _.slides).transition(t).find(".swiper-slide-shadow").transition(t), N({
          swiper: _,
          duration: t,
          transformEl: e
        })
      },
      perspective: () => !0,
      overwriteParams: () => ({
        watchSlidesProgress: !0,
        virtualTranslate: !_.params.cssMode
      })
    })
  }];
  return M.use(F), M
}), Object.keys || (Object.keys = function (t) {
    var e, i = [];
    for (e in t) t.hasOwnProperty(e) && i.push(e);
    return i
  }), $.DateTimePicker = $.DateTimePicker || {
    name: "DateTimePicker",
    i18n: {},
    defaults: {
      mode: "date",
      defaultDate: null,
      dateSeparator: "-",
      timeSeparator: ":",
      timeMeridiemSeparator: " ",
      dateTimeSeparator: " ",
      monthYearSeparator: " ",
      dateTimeFormat: "dd-MM-yyyy HH:mm",
      dateFormat: "dd-MM-yyyy",
      timeFormat: "HH:mm",
      maxDate: null,
      minDate: null,
      maxTime: null,
      minTime: null,
      maxDateTime: null,
      minDateTime: null,
      shortDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      fullDayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      fullMonthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      labels: null,
      minuteInterval: 1,
      roundOffMinutes: !0,
      secondsInterval: 1,
      roundOffSeconds: !0,
      showHeader: !0,
      titleContentDate: "Set Date",
      titleContentTime: "Set Time",
      titleContentDateTime: "Set Date & Time",
      buttonsToDisplay: ["HeaderCloseButton", "SetButton", "ClearButton"],
      setButtonContent: "Set",
      clearButtonContent: "Clear",
      incrementButtonContent: "+",
      decrementButtonContent: "-",
      setValueInTextboxOnEveryClick: !1,
      readonlyInputs: !1,
      animationDuration: 400,
      touchHoldInterval: 300,
      captureTouchHold: !1,
      mouseHoldInterval: 50,
      captureMouseHold: !1,
      isPopup: !0,
      parentElement: "body",
      isInline: !1,
      inputElement: null,
      language: "",
      init: null,
      addEventHandlers: null,
      beforeShow: null,
      afterShow: null,
      beforeHide: null,
      afterHide: null,
      buttonClicked: null,
      settingValueOfElement: null,
      formatHumanDate: null,
      parseDateTimeString: null,
      formatDateTimeString: null
    },
    dataObject: {
      dCurrentDate: new Date,
      iCurrentDay: 0,
      iCurrentMonth: 0,
      iCurrentYear: 0,
      iCurrentHour: 0,
      iCurrentMinutes: 0,
      iCurrentSeconds: 0,
      sCurrentMeridiem: "",
      iMaxNumberOfDays: 0,
      sDateFormat: "",
      sTimeFormat: "",
      sDateTimeFormat: "",
      dMinValue: null,
      dMaxValue: null,
      sArrInputDateFormats: [],
      sArrInputTimeFormats: [],
      sArrInputDateTimeFormats: [],
      bArrMatchFormat: [],
      bDateMode: !1,
      bTimeMode: !1,
      bDateTimeMode: !1,
      oInputElement: null,
      iTabIndex: 0,
      bElemFocused: !1,
      bIs12Hour: !1,
      sTouchButton: null,
      iTouchStart: null,
      oTimeInterval: null,
      bIsTouchDevice: "ontouchstart" in document.documentElement
    }
  }, $.cf = {
    _isValid: function (t) {
      return null != t && "" !== t
    },
    _compare: function (t, e) {
      return null != t && null != e && t.toLowerCase() === e.toLowerCase()
    }
  },
  function (t) {
    "function" == typeof define && define.amd ? define(["jquery"], t) : "object" == typeof exports ? module.exports = t(require("jquery")) : t(jQuery)
  }(function (_) {
    "use strict";

    function a(t, e) {
      this.element = t;
      t = "", t = (_.cf._isValid(e) && _.cf._isValid(e.language) ? e : _.DateTimePicker.defaults).language;
      this.settings = _.extend({}, _.DateTimePicker.defaults, _.DateTimePicker.i18n[t], e), this.options = e, this.oData = _.extend({}, _.DateTimePicker.dataObject), this._defaults = _.DateTimePicker.defaults, this._name = _.DateTimePicker.name, this.init()
    }
    _.fn.DateTimePicker = function (t) {
      var e, i, s = _(this).data(),
        n = s ? Object.keys(s) : [];
      if ("string" != typeof t) return this.each(function () {
        _.removeData(this, "plugin_DateTimePicker"), _.data(this, "plugin_DateTimePicker") || _.data(this, "plugin_DateTimePicker", new a(this, t))
      });
      if (_.cf._isValid(s))
        if ("destroy" === t)
          if (0 < n.length) {
            for (e in n)
              if (-1 !== (i = n[e]).search("plugin_DateTimePicker")) {
                _(document).unbind("click.DateTimePicker keydown.DateTimePicker keyup.DateTimePicker"), _(this).children().remove(), _(this).removeData(), _(this).unbind(), _(this).removeClass("dtpicker-overlay dtpicker-mobile dtpicker-inline"), s = s[i], console.log("Destroyed DateTimePicker Object"), console.log(s);
                break
              }
          } else console.log("No DateTimePicker Object Defined For This Element");
      else if ("object" === t)
        if (0 < n.length) {
          for (e in n)
            if (-1 !== (i = n[e]).search("plugin_DateTimePicker")) return s[i]
        } else console.log("No DateTimePicker Object Defined For This Element")
    }, a.prototype = {
      init: function () {
        var t = this;
        t._setDateFormatArray(), t._setTimeFormatArray(), t._setDateTimeFormatArray(), console.log(_(t.element).data("parentelement") + " " + _(t.element).attr("data-parentelement")), void 0 !== _(t.element).data("parentelement") && (t.settings.parentElement = _(t.element).data("parentelement")), t.settings.isPopup && !t.settings.isInline && (t._createPicker(), _(t.element).addClass("dtpicker-mobile")), t.settings.isInline && (t._createPicker(), t._showPicker(t.settings.inputElement)), t.settings.init && t.settings.init.call(t), t._addEventHandlersForInput()
      },
      _setDateFormatArray: function () {
        var t = this;
        t.oData.sArrInputDateFormats = [];
        var e = "dd" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "yyyy";
        t.oData.sArrInputDateFormats.push(e), e = "MM" + t.settings.dateSeparator + "dd" + t.settings.dateSeparator + "yyyy", t.oData.sArrInputDateFormats.push(e), e = "yyyy" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "dd", t.oData.sArrInputDateFormats.push(e), e = "dd" + t.settings.dateSeparator + "MMM" + t.settings.dateSeparator + "yyyy", t.oData.sArrInputDateFormats.push(e), e = "MM" + t.settings.monthYearSeparator + "yyyy", t.oData.sArrInputDateFormats.push(e), e = "MMM" + t.settings.monthYearSeparator + "yyyy", t.oData.sArrInputDateFormats.push(e), e = "MMMM" + t.settings.monthYearSeparator + "yyyy", t.oData.sArrInputDateFormats.push(e), e = "yyyy" + t.settings.monthYearSeparator + "MM", t.oData.sArrInputDateFormats.push(e)
      },
      _setTimeFormatArray: function () {
        var t = this;
        t.oData.sArrInputTimeFormats = [];
        var e = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss" + t.settings.timeMeridiemSeparator + "AA";
        t.oData.sArrInputTimeFormats.push(e), e = "HH" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss", t.oData.sArrInputTimeFormats.push(e), e = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeMeridiemSeparator + "AA", t.oData.sArrInputTimeFormats.push(e), e = "HH" + t.settings.timeSeparator + "mm", t.oData.sArrInputTimeFormats.push(e)
      },
      _setDateTimeFormatArray: function () {
        var t = this;
        t.oData.sArrInputDateTimeFormats = [];
        var e = "dd" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "yyyy",
          i = "HH" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss",
          s = e + t.settings.dateTimeSeparator + i;
        t.oData.sArrInputDateTimeFormats.push(s), e = "dd" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "yyyy", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss" + t.settings.timeMeridiemSeparator + "AA", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "MM" + t.settings.dateSeparator + "dd" + t.settings.dateSeparator + "yyyy", i = "HH" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "MM" + t.settings.dateSeparator + "dd" + t.settings.dateSeparator + "yyyy", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss" + t.settings.timeMeridiemSeparator + "AA", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "yyyy" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "dd", i = "HH" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "yyyy" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "dd", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss" + t.settings.timeMeridiemSeparator + "AA", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "dd" + t.settings.dateSeparator + "MMM" + t.settings.dateSeparator + "yyyy", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "dd" + t.settings.dateSeparator + "MMM" + t.settings.dateSeparator + "yyyy", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeSeparator + "ss" + t.settings.timeMeridiemSeparator + "AA", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "dd" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "yyyy", i = "HH" + t.settings.timeSeparator + "mm", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "dd" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "yyyy", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeMeridiemSeparator + "AA", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "MM" + t.settings.dateSeparator + "dd" + t.settings.dateSeparator + "yyyy", i = "HH" + t.settings.timeSeparator + "mm", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "MM" + t.settings.dateSeparator + "dd" + t.settings.dateSeparator + "yyyy", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeMeridiemSeparator + "AA", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "yyyy" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "dd", i = "HH" + t.settings.timeSeparator + "mm", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "yyyy" + t.settings.dateSeparator + "MM" + t.settings.dateSeparator + "dd", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeMeridiemSeparator + "AA", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "dd" + t.settings.dateSeparator + "MMM" + t.settings.dateSeparator + "yyyy", i = "hh" + t.settings.timeSeparator + "mm", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s), e = "dd" + t.settings.dateSeparator + "MMM" + t.settings.dateSeparator + "yyyy", i = "hh" + t.settings.timeSeparator + "mm" + t.settings.timeMeridiemSeparator + "AA", s = e + t.settings.dateTimeSeparator + i, t.oData.sArrInputDateTimeFormats.push(s)
      },
      _matchFormat: function (t, e) {
        var i = this;
        i.oData.bArrMatchFormat = [], i.oData.bDateMode = !1, i.oData.bTimeMode = !1, i.oData.bDateTimeMode = !1;
        var s, n = [];
        for (t = _.cf._isValid(t) ? t : i.settings.mode, _.cf._compare(t, "date") ? (e = _.cf._isValid(e) ? e : i.oData.sDateFormat, i.oData.bDateMode = !0, n = i.oData.sArrInputDateFormats) : _.cf._compare(t, "time") ? (e = _.cf._isValid(e) ? e : i.oData.sTimeFormat, i.oData.bTimeMode = !0, n = i.oData.sArrInputTimeFormats) : _.cf._compare(t, "datetime") && (e = _.cf._isValid(e) ? e : i.oData.sDateTimeFormat, i.oData.bDateTimeMode = !0, n = i.oData.sArrInputDateTimeFormats), s = 0; s < n.length; s++) i.oData.bArrMatchFormat.push(_.cf._compare(e, n[s]))
      },
      _setMatchFormat: function (t, e, i) {
        0 < t && this._matchFormat(e, i)
      },
      _createPicker: function () {
        var e = this;
        e.settings.isInline ? _(e.element).addClass("dtpicker-inline") : (_(e.element).addClass("dtpicker-overlay"), _(".dtpicker-overlay").click(function (t) {
          e._hidePicker("")
        }));
        _(e.element).html("<div class='dtpicker-bg'><div class='dtpicker-cont'><div class='dtpicker-content'><div class='dtpicker-subcontent'></div></div></div></div>")
      },
      _addEventHandlersForInput: function () {
        var t, e = this;
        e.settings.isInline || (e.oData.oInputElement = null, _(e.settings.parentElement).find("input[type='date'], input[type='time'], input[type='datetime']").each(function () {
          _(this).attr("data-field", _(this).attr("type")), _(this).attr("type", "text")
        }), t = "[data-field='date'], [data-field='time'], [data-field='datetime']", _(e.settings.parentElement).off("focus", t, e._inputFieldFocus).on("focus", t, {
          obj: e
        }, e._inputFieldFocus), _(e.settings.parentElement).off("click", t, e._inputFieldClick).on("click", t, {
          obj: e
        }, e._inputFieldClick)), e.settings.addEventHandlers && e.settings.addEventHandlers.call(e)
      },
      _inputFieldFocus: function (t) {
        t = t.data.obj;
        t.showDateTimePicker(this), t.oData.bMouseDown = !1
      },
      _inputFieldClick: function (t) {
        var e = t.data.obj;
        _.cf._compare(_(this).prop("tagName"), "input") || e.showDateTimePicker(this), t.stopPropagation()
      },
      getDateObjectForInputField: function (t) {
        var e = this;
        if (_.cf._isValid(t)) {
          var i, s = e._getValueOfElement(t),
            n = _(t).data("field"),
            a = "";
          return _.cf._isValid(n) || (n = e.settings.mode), e.settings.formatDateTimeString ? i = e.settings.parseDateTimeString.call(e, s, n, a, _(t)) : (a = _(t).data("format"), _.cf._isValid(a) || (_.cf._compare(n, "date") ? a = e.settings.dateFormat : _.cf._compare(n, "time") ? a = e.settings.timeFormat : _.cf._compare(n, "datetime") && (a = e.settings.dateTimeFormat)), e._matchFormat(n, a), _.cf._compare(n, "date") ? i = e._parseDate(s) : _.cf._compare(n, "time") ? i = e._parseTime(s) : _.cf._compare(n, "datetime") && (i = e._parseDateTime(s))), i
        }
      },
      setDateTimeStringInInputField: function (t, s) {
        var e, n = this;
        s = s || n.oData.dCurrentDate, _.cf._isValid(t) ? (e = [], "string" == typeof t ? e.push(t) : "object" == typeof t && (e = t)) : e = _.cf._isValid(n.settings.parentElement) ? _(n.settings.parentElement).find("[data-field='date'], [data-field='time'], [data-field='datetime']") : _("[data-field='date'], [data-field='time'], [data-field='datetime']"), e.each(function () {
          var t, e, i = _(this).data("field");
          _.cf._isValid(i) || (i = n.settings.mode), e = !(t = "Custom"), n.settings.formatDateTimeString || (t = _(this).data("format"), _.cf._isValid(t) || (_.cf._compare(i, "date") ? t = n.settings.dateFormat : _.cf._compare(i, "time") ? t = n.settings.timeFormat : _.cf._compare(i, "datetime") && (t = n.settings.dateTimeFormat)), e = n.getIs12Hour(i, t)), e = n._setOutput(i, t, e, s, this), n._setValueOfElement(e, _(this))
        })
      },
      getDateTimeStringInFormat: function (t, e, i) {
        return this._setOutput(t, e, this.getIs12Hour(t, e), i)
      },
      showDateTimePicker: function (t) {
        null !== this.oData.oInputElement ? this.settings.isInline || this._hidePicker(0, t) : this._showPicker(t)
      },
      _setButtonAction: function (t) {
        var e = this;
        null !== e.oData.oInputElement && (e._setValueOfElement(e._setOutput()), t ? (e.settings.buttonClicked && e.settings.buttonClicked.call(e, "TAB", e.oData.oInputElement), e.settings.isInline || e._hidePicker(0)) : e.settings.isInline || e._hidePicker(""))
      },
      _setOutput: function (t, e, i, s, n) {
        var a = this;
        s = _.cf._isValid(s) ? s : a.oData.dCurrentDate, i = i || a.oData.bIs12Hour;
        var o = a._setVariablesForDate(s, !0, !0),
          r = "",
          l = a._formatDate(o),
          c = a._formatTime(o),
          s = _.extend({}, l, c),
          o = "",
          l = "",
          c = Function.length;
        return a.settings.formatDateTimeString ? r = a.settings.formatDateTimeString.call(a, s, t, e, n) : (a._setMatchFormat(c, t, e), a.oData.bDateMode ? a.oData.bArrMatchFormat[0] ? r = s.dd + a.settings.dateSeparator + s.MM + a.settings.dateSeparator + s.yyyy : a.oData.bArrMatchFormat[1] ? r = s.MM + a.settings.dateSeparator + s.dd + a.settings.dateSeparator + s.yyyy : a.oData.bArrMatchFormat[2] ? r = s.yyyy + a.settings.dateSeparator + s.MM + a.settings.dateSeparator + s.dd : a.oData.bArrMatchFormat[3] ? r = s.dd + a.settings.dateSeparator + s.monthShort + a.settings.dateSeparator + s.yyyy : a.oData.bArrMatchFormat[4] ? r = s.MM + a.settings.monthYearSeparator + s.yyyy : a.oData.bArrMatchFormat[5] ? r = s.monthShort + a.settings.monthYearSeparator + s.yyyy : a.oData.bArrMatchFormat[6] ? r = s.month + a.settings.monthYearSeparator + s.yyyy : a.oData.bArrMatchFormat[7] && (r = s.yyyy + a.settings.monthYearSeparator + s.MM) : a.oData.bTimeMode ? a.oData.bArrMatchFormat[0] ? r = s.hh + a.settings.timeSeparator + s.mm + a.settings.timeSeparator + s.ss + a.settings.timeMeridiemSeparator + s.ME : a.oData.bArrMatchFormat[1] ? r = s.HH + a.settings.timeSeparator + s.mm + a.settings.timeSeparator + s.ss : a.oData.bArrMatchFormat[2] ? r = s.hh + a.settings.timeSeparator + s.mm + a.settings.timeMeridiemSeparator + s.ME : a.oData.bArrMatchFormat[3] && (r = s.HH + a.settings.timeSeparator + s.mm) : a.oData.bDateTimeMode && (a.oData.bArrMatchFormat[0] || a.oData.bArrMatchFormat[1] || a.oData.bArrMatchFormat[8] || a.oData.bArrMatchFormat[9] ? o = s.dd + a.settings.dateSeparator + s.MM + a.settings.dateSeparator + s.yyyy : a.oData.bArrMatchFormat[2] || a.oData.bArrMatchFormat[3] || a.oData.bArrMatchFormat[10] || a.oData.bArrMatchFormat[11] ? o = s.MM + a.settings.dateSeparator + s.dd + a.settings.dateSeparator + s.yyyy : a.oData.bArrMatchFormat[4] || a.oData.bArrMatchFormat[5] || a.oData.bArrMatchFormat[12] || a.oData.bArrMatchFormat[13] ? o = s.yyyy + a.settings.dateSeparator + s.MM + a.settings.dateSeparator + s.dd : (a.oData.bArrMatchFormat[6] || a.oData.bArrMatchFormat[7] || a.oData.bArrMatchFormat[14] || a.oData.bArrMatchFormat[15]) && (o = s.dd + a.settings.dateSeparator + s.monthShort + a.settings.dateSeparator + s.yyyy), e = a.oData.bArrMatchFormat[0] || a.oData.bArrMatchFormat[1] || a.oData.bArrMatchFormat[2] || a.oData.bArrMatchFormat[3] || a.oData.bArrMatchFormat[4] || a.oData.bArrMatchFormat[5] || a.oData.bArrMatchFormat[6] || a.oData.bArrMatchFormat[7], l = i ? e ? s.hh + a.settings.timeSeparator + s.mm + a.settings.timeSeparator + s.ss + a.settings.timeMeridiemSeparator + s.ME : s.hh + a.settings.timeSeparator + s.mm + a.settings.timeMeridiemSeparator + s.ME : e ? s.HH + a.settings.timeSeparator + s.mm + a.settings.timeSeparator + s.ss : s.HH + a.settings.timeSeparator + s.mm, "" !== o && "" !== l && (r = o + a.settings.dateTimeSeparator + l)), a._setMatchFormat(c)), r
      },
      _clearButtonAction: function () {
        null !== this.oData.oInputElement && this._setValueOfElement(""), this.settings.isInline || this._hidePicker("")
      },
      _setOutputOnIncrementOrDecrement: function () {
        _.cf._isValid(this.oData.oInputElement) && this.settings.setValueInTextboxOnEveryClick && this._setValueOfElement(this._setOutput())
      },
      _showPicker: function (t) {
        var e, i, s, n, a, o, r, l, c, d, h, u, p, f, m, g, v, b = this;
        null === b.oData.oInputElement && (b.oData.oInputElement = t, b.oData.iTabIndex = parseInt(_(t).attr("tabIndex")), e = _(t).data("field") || "", i = _(t).data("min") || "", s = _(t).data("max") || "", n = _(t).data("format") || "", d = _(t).data("view") || "", a = _(t).data("startend") || "", o = _(t).data("startendelem") || "", r = b._getValueOfElement(t) || "", "" !== d && (_.cf._compare(d, "Popup") ? b.setIsPopup(!0) : b.setIsPopup(!1)), b.settings.isPopup || b.settings.isInline || (b._createPicker(), l = _(b.oData.oInputElement).offset().top + _(b.oData.oInputElement).outerHeight(), c = _(b.oData.oInputElement).offset().left, d = _(b.oData.oInputElement).outerWidth(), _(b.element).css({
          position: "absolute",
          top: l,
          left: c,
          width: d,
          height: "auto"
        })), b.settings.beforeShow && b.settings.beforeShow.call(b, t), e = _.cf._isValid(e) ? e : b.settings.mode, b.settings.mode = e, _.cf._isValid(n) || (_.cf._compare(e, "date") ? n = b.settings.dateFormat : _.cf._compare(e, "time") ? n = b.settings.timeFormat : _.cf._compare(e, "datetime") && (n = b.settings.dateTimeFormat)), b._matchFormat(e, n), b.oData.dMinValue = null, b.oData.dMaxValue = null, b.oData.bIs12Hour = !1, b.oData.bDateMode ? (h = i || b.settings.minDate, u = s || b.settings.maxDate, b.oData.sDateFormat = n, _.cf._isValid(h) && (b.oData.dMinValue = b._parseDate(h)), _.cf._isValid(u) && (b.oData.dMaxValue = b._parseDate(u)), "" !== a && (_.cf._compare(a, "start") || _.cf._compare(a, "end")) && "" !== o && 1 <= _(o).length && "" !== (p = b._getValueOfElement(_(o))) && (f = b.settings.parseDateTimeString ? b.settings.parseDateTimeString.call(b, p, e, n, _(o)) : b._parseDate(p), _.cf._compare(a, "start") ? (!_.cf._isValid(u) || b._compareDates(f, b.oData.dMaxValue) < 0) && (b.oData.dMaxValue = new Date(f)) : _.cf._compare(a, "end") && (!_.cf._isValid(h) || 0 < b._compareDates(f, b.oData.dMinValue)) && (b.oData.dMinValue = new Date(f))), b.settings.parseDateTimeString ? b.oData.dCurrentDate = b.settings.parseDateTimeString.call(b, r, e, n, _(t)) : b.oData.dCurrentDate = b._parseDate(r), b.oData.dCurrentDate.setHours(0), b.oData.dCurrentDate.setMinutes(0), b.oData.dCurrentDate.setSeconds(0)) : b.oData.bTimeMode ? (h = i || b.settings.minTime, u = s || b.settings.maxTime, b.oData.sTimeFormat = n, b.oData.bIs12Hour = b.getIs12Hour(), _.cf._isValid(h) && (b.oData.dMinValue = b._parseTime(h), _.cf._isValid(u) || (b.oData.sTimeFormat === b.oData.sArrInputTimeFormats[0] ? u = "11:59:59 PM" : b.oData.sTimeFormat === b.oData.sArrInputTimeFormats[1] ? u = "23:59:59" : b.oData.sTimeFormat === b.oData.sArrInputTimeFormats[2] ? u = "11:59 PM" : b.oData.sTimeFormat === b.oData.sArrInputTimeFormats[3] && (u = "23:59"), b.oData.dMaxValue = b._parseTime(u))), _.cf._isValid(u) && (b.oData.dMaxValue = b._parseTime(u), _.cf._isValid(h) || (b.oData.sTimeFormat === b.oData.sArrInputTimeFormats[0] ? h = "12:00:00 AM" : b.oData.sTimeFormat === b.oData.sArrInputTimeFormats[1] ? h = "00:00:00" : b.oData.sTimeFormat === b.oData.sArrInputTimeFormats[2] ? h = "12:00 AM" : b.oData.sTimeFormat === b.oData.sArrInputTimeFormats[3] && (h = "00:00"), b.oData.dMinValue = b._parseTime(h))), "" !== a && (_.cf._compare(a, "start") || _.cf._compare(a, "end")) && "" !== o && 1 <= _(o).length && "" !== (m = b._getValueOfElement(_(o))) && (b.settings.parseDateTimeString ? f = b.settings.parseDateTimeString.call(b, m, e, n, _(o)) : g = b._parseTime(m), _.cf._compare(a, "start") ? (g.setMinutes(g.getMinutes() - 1), _.cf._isValid(u) && 2 !== b._compareTime(g, b.oData.dMaxValue) || (b.oData.dMaxValue = new Date(g))) : _.cf._compare(a, "end") && (g.setMinutes(g.getMinutes() + 1), _.cf._isValid(h) && 3 !== b._compareTime(g, b.oData.dMinValue) || (b.oData.dMinValue = new Date(g)))), b.settings.parseDateTimeString ? b.oData.dCurrentDate = b.settings.parseDateTimeString.call(b, r, e, n, _(t)) : b.oData.dCurrentDate = b._parseTime(r)) : b.oData.bDateTimeMode && (h = i || b.settings.minDateTime, u = s || b.settings.maxDateTime, b.oData.sDateTimeFormat = n, b.oData.bIs12Hour = b.getIs12Hour(), _.cf._isValid(h) && (b.oData.dMinValue = b._parseDateTime(h)), _.cf._isValid(u) && (b.oData.dMaxValue = b._parseDateTime(u)), "" !== a && (_.cf._compare(a, "start") || _.cf._compare(a, "end")) && "" !== o && 1 <= _(o).length && "" !== (v = b._getValueOfElement(_(o))) && (v = b.settings.parseDateTimeString ? b.settings.parseDateTimeString.call(b, v, e, n, _(o)) : b._parseDateTime(v), _.cf._compare(a, "start") ? (!_.cf._isValid(u) || b._compareDateTime(v, b.oData.dMaxValue) < 0) && (b.oData.dMaxValue = new Date(v)) : _.cf._compare(a, "end") && (!_.cf._isValid(h) || 0 < b._compareDateTime(v, b.oData.dMinValue)) && (b.oData.dMinValue = new Date(v))), b.settings.parseDateTimeString ? b.oData.dCurrentDate = b.settings.parseDateTimeString.call(b, r, e, n, _(t)) : b.oData.dCurrentDate = b._parseDateTime(r)), b._setVariablesForDate(), b._modifyPicker(), _(b.element).fadeIn(b.settings.animationDuration), b.settings.afterShow && setTimeout(function () {
          b.settings.afterShow.call(b, t)
        }, b.settings.animationDuration))
      },
      _hidePicker: function (t, e) {
        var i = this,
          s = i.oData.oInputElement;
        i.settings.beforeHide && i.settings.beforeHide.call(i, s), _.cf._isValid(t) || (t = i.settings.animationDuration), _.cf._isValid(i.oData.oInputElement) && (_(i.oData.oInputElement).blur(), i.oData.oInputElement = null), _(i.element).fadeOut(t), 0 === t ? _(i.element).find(".dtpicker-subcontent").html("") : setTimeout(function () {
          _(i.element).find(".dtpicker-subcontent").html("")
        }, t), _(document).unbind("click.DateTimePicker keydown.DateTimePicker keyup.DateTimePicker"), i.settings.afterHide && (0 === t ? i.settings.afterHide.call(i, s) : setTimeout(function () {
          i.settings.afterHide.call(i, s)
        }, t)), _.cf._isValid(e) && i._showPicker(e)
      },
      _modifyPicker: function () {
        var t, e = this,
          i = [];
        e.oData.bDateMode ? (e.settings.titleContentDate, t = 3, e.oData.bArrMatchFormat[0] ? i = ["day", "month", "year"] : e.oData.bArrMatchFormat[1] ? i = ["month", "day", "year"] : e.oData.bArrMatchFormat[2] ? i = ["year", "month", "day"] : e.oData.bArrMatchFormat[3] ? i = ["day", "month", "year"] : e.oData.bArrMatchFormat[4] || e.oData.bArrMatchFormat[5] || e.oData.bArrMatchFormat[6] ? (t = 2, i = ["month", "year"]) : e.oData.bArrMatchFormat[7] && (t = 2, i = ["year", "month"])) : e.oData.bTimeMode ? (e.settings.titleContentTime, e.oData.bArrMatchFormat[0] ? (t = 4, i = ["hour", "minutes", "seconds", "meridiem"]) : e.oData.bArrMatchFormat[1] ? (t = 3, i = ["hour", "minutes", "seconds"]) : e.oData.bArrMatchFormat[2] ? (t = 3, i = ["hour", "minutes", "meridiem"]) : e.oData.bArrMatchFormat[3] && (t = 2, i = ["hour", "minutes"])) : e.oData.bDateTimeMode && (e.settings.titleContentDateTime, e.oData.bArrMatchFormat[0] ? (t = 6, i = ["day", "month", "year", "hour", "minutes", "seconds"]) : e.oData.bArrMatchFormat[1] ? (t = 7, i = ["day", "month", "year", "hour", "minutes", "seconds", "meridiem"]) : e.oData.bArrMatchFormat[2] ? (t = 6, i = ["month", "day", "year", "hour", "minutes", "seconds"]) : e.oData.bArrMatchFormat[3] ? (t = 7, i = ["month", "day", "year", "hour", "minutes", "seconds", "meridiem"]) : e.oData.bArrMatchFormat[4] ? (t = 6, i = ["year", "month", "day", "hour", "minutes", "seconds"]) : e.oData.bArrMatchFormat[5] ? (t = 7, i = ["year", "month", "day", "hour", "minutes", "seconds", "meridiem"]) : e.oData.bArrMatchFormat[6] ? (t = 6, i = ["day", "month", "year", "hour", "minutes", "seconds"]) : e.oData.bArrMatchFormat[7] ? (t = 7, i = ["day", "month", "year", "hour", "minutes", "seconds", "meridiem"]) : e.oData.bArrMatchFormat[8] ? (t = 5, i = ["day", "month", "year", "hour", "minutes"]) : e.oData.bArrMatchFormat[9] ? (t = 6, i = ["day", "month", "year", "hour", "minutes", "meridiem"]) : e.oData.bArrMatchFormat[10] ? (t = 5, i = ["month", "day", "year", "hour", "minutes"]) : e.oData.bArrMatchFormat[11] ? (t = 6, i = ["month", "day", "year", "hour", "minutes", "meridiem"]) : e.oData.bArrMatchFormat[12] ? (t = 5, i = ["year", "month", "day", "hour", "minutes"]) : e.oData.bArrMatchFormat[13] ? (t = 6, i = ["year", "month", "day", "hour", "minutes", "meridiem"]) : e.oData.bArrMatchFormat[14] ? (t = 5, i = ["day", "month", "year", "hour", "minutes"]) : e.oData.bArrMatchFormat[15] && (t = 6, i = ["day", "month", "year", "hour", "minutes", "meridiem"]));
        for (var s = "dtpicker-comp" + t, n = !1, a = !1, o = !1, r = 0; r < e.settings.buttonsToDisplay.length; r++) _.cf._compare(e.settings.buttonsToDisplay[r], "HeaderCloseButton") ? n = !0 : _.cf._compare(e.settings.buttonsToDisplay[r], "SetButton") ? a = !0 : _.cf._compare(e.settings.buttonsToDisplay[r], "ClearButton") && (o = !0);
        var l = "";
        e.settings.showHeader && (l += "<div class='dtpicker-header'>", l += "<div class='dtpicker-title'>Pilih Tanggal</div>", n && (l += "<a class='dtpicker-close' id='dtpicker-close'><img src='./assets/images/close.svg'></a>"), l += "</div>");
        var c = "";
        for (c += "<div class='dtpicker-components'>", r = 0; r < t; r++) {
          var d = i[r];
          c += "<div class='dtpicker-compOutline " + s + "'>", c += "<div class='dtpicker-comp " + d + "'>", c += "<a class='dtpicker-compButton increment'>" + e.settings.incrementButtonContent + "</a>", e.settings.readonlyInputs ? c += "<input type='text' class='dtpicker-compValue' readonly>" : c += "<input type='text' class='dtpicker-compValue'>", c += "<a class='dtpicker-compButton decrement'>" + e.settings.decrementButtonContent + "</a>", e.settings.labels && (c += "<div class='dtpicker-label'>" + e.settings.labels[d] + "</div>"), c += "</div>", c += "</div>"
        }
        var h = "";
        h += "<div class='dtpicker-buttonCont" + (a && o ? " dtpicker-twoButtons" : " dtpicker-singleButton") + "'>", a && (h += "<a class='dtpicker-button dtpicker-buttonSet'>Selesai</a>"), n && (h += "<a class='dtpicker-button dtpicker-buttonClear'>" + e.settings.clearButtonContent + "</a>");
        h = l + (c += "</div>") + (h += "</div>");
        _(e.element).find(".dtpicker-subcontent").html(h), e._setCurrentDate(), e._addEventHandlersForPicker()
      },
      _addEventHandlersForPicker: function () {
        var e, i, t, s = this;
        s.settings.isInline || _(document).on("click.DateTimePicker", function (t) {
          s.oData.bElemFocused && s._hidePicker("")
        }), _(document).on("keydown.DateTimePicker", function (t) {
          return i = parseInt(t.keyCode || t.which), _(".dtpicker-compValue").is(":focus") || 9 !== i ? _(".dtpicker-compValue").is(":focus") ? 38 === i ? (e = _(".dtpicker-compValue:focus").parent().attr("class"), s._incrementDecrementActionsUsingArrowAndMouse(e, "inc"), !1) : 40 === i ? (e = _(".dtpicker-compValue:focus").parent().attr("class"), s._incrementDecrementActionsUsingArrowAndMouse(e, "dec"), !1) : void 0 : void 0 : (s._setButtonAction(!0), _("[tabIndex=" + (s.oData.iTabIndex + 1) + "]").focus(), !1)
        }), s.settings.isInline || _(document).on("keydown.DateTimePicker", function (t) {
          i = parseInt(t.keyCode || t.which), _(".dtpicker-compValue").is(":focus") || 9 === i || s._hidePicker("")
        }), _(".dtpicker-cont *").click(function (t) {
          t.stopPropagation()
        }), s.settings.readonlyInputs || (_(".dtpicker-compValue").not(".month .dtpicker-compValue, .meridiem .dtpicker-compValue").keyup(function () {
          this.value = this.value.replace(/[^0-9\.]/g, "")
        }), _(".dtpicker-compValue").focus(function () {
          s.oData.bElemFocused = !0, _(this).select()
        }), _(".dtpicker-compValue").blur(function () {
          s._getValuesFromInputBoxes(), s._setCurrentDate(), s.oData.bElemFocused = !1;
          var t = _(this).parent().parent();
          setTimeout(function () {
            t.is(":last-child") && !s.oData.bElemFocused && s._setButtonAction(!1)
          }, 50)
        }), _(".dtpicker-compValue").keyup(function (t) {
          var e, i = _(this),
            s = i.val(),
            n = s.length;
          i.parent().hasClass("day") || i.parent().hasClass("hour") || i.parent().hasClass("minutes") || i.parent().hasClass("meridiem") ? 2 < n && (e = s.slice(0, 2), i.val(e)) : i.parent().hasClass("month") ? 3 < n && (e = s.slice(0, 3), i.val(e)) : i.parent().hasClass("year") && 4 < n && (e = s.slice(0, 4), i.val(e)), 9 === parseInt(t.keyCode || t.which) && _(this).select()
        })), _(s.element).find(".dtpicker-compValue").on("mousewheel DOMMouseScroll onmousewheel", function (t) {
          if (_(".dtpicker-compValue").is(":focus")) return 0 < Math.max(-1, Math.min(1, t.originalEvent.wheelDelta)) ? (e = _(".dtpicker-compValue:focus").parent().attr("class"), s._incrementDecrementActionsUsingArrowAndMouse(e, "inc")) : (e = _(".dtpicker-compValue:focus").parent().attr("class"), s._incrementDecrementActionsUsingArrowAndMouse(e, "dec")), !1
        }), _(s.element).find(".dtpicker-close").click(function (t) {
          s.settings.buttonClicked && s.settings.buttonClicked.call(s, "CLOSE", s.oData.oInputElement), s.settings.isInline || s._hidePicker("")
        }), _(s.element).find(".dtpicker-buttonSet").click(function (t) {
          s.settings.buttonClicked && s.settings.buttonClicked.call(s, "SET", s.oData.oInputElement), s._setButtonAction(!1)
        }), _(s.element).find(".dtpicker-buttonClear").click(function (t) {
          s.settings.buttonClicked && s.settings.buttonClicked.call(s, "CLEAR", s.oData.oInputElement), s._clearButtonAction()
        }), s.settings.captureTouchHold || s.settings.captureMouseHold ? (t = "", s.settings.captureTouchHold && s.oData.bIsTouchDevice && (t += "touchstart touchmove touchend "), s.settings.captureMouseHold && (t += "mousedown mouseup"), _(".dtpicker-cont *").on(t, function (t) {
          s._clearIntervalForTouchEvents()
        }), s._bindTouchEvents("day"), s._bindTouchEvents("month"), s._bindTouchEvents("year"), s._bindTouchEvents("hour"), s._bindTouchEvents("minutes"), s._bindTouchEvents("seconds")) : (_(s.element).find(".day .increment, .day .increment *").click(function (t) {
          s.oData.iCurrentDay++, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".day .decrement, .day .decrement *").click(function (t) {
          s.oData.iCurrentDay--, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".month .increment, .month .increment *").click(function (t) {
          s.oData.iCurrentMonth++, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".month .decrement, .month .decrement *").click(function (t) {
          s.oData.iCurrentMonth--, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".year .increment, .year .increment *").click(function (t) {
          s.oData.iCurrentYear++, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".year .decrement, .year .decrement *").click(function (t) {
          s.oData.iCurrentYear--, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".hour .increment, .hour .increment *").click(function (t) {
          s.oData.iCurrentHour++, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".hour .decrement, .hour .decrement *").click(function (t) {
          s.oData.iCurrentHour--, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".minutes .increment, .minutes .increment *").click(function (t) {
          s.oData.iCurrentMinutes += s.settings.minuteInterval, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".minutes .decrement, .minutes .decrement *").click(function (t) {
          s.oData.iCurrentMinutes -= s.settings.minuteInterval, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".seconds .increment, .seconds .increment *").click(function (t) {
          s.oData.iCurrentSeconds += s.settings.secondsInterval, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        }), _(s.element).find(".seconds .decrement, .seconds .decrement *").click(function (t) {
          s.oData.iCurrentSeconds -= s.settings.secondsInterval, s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        })), _(s.element).find(".meridiem .dtpicker-compButton, .meridiem .dtpicker-compButton *").click(function (t) {
          _.cf._compare(s.oData.sCurrentMeridiem, "AM") ? (s.oData.sCurrentMeridiem = "PM", s.oData.iCurrentHour += 12) : _.cf._compare(s.oData.sCurrentMeridiem, "PM") && (s.oData.sCurrentMeridiem = "AM", s.oData.iCurrentHour -= 12), s._setCurrentDate(), s._setOutputOnIncrementOrDecrement()
        })
      },
      _adjustMinutes: function (t) {
        return t = this.settings.roundOffMinutes && 1 !== this.settings.minuteInterval ? t % this.settings.minuteInterval ? t - t % this.settings.minuteInterval + this.settings.minuteInterval : t : t
      },
      _adjustSeconds: function (t) {
        return t = this.settings.roundOffSeconds && 1 !== this.settings.secondsInterval ? t % this.settings.secondsInterval ? t - t % this.settings.secondsInterval + this.settings.secondsInterval : t : t
      },
      _getValueOfElement: function (t) {
        return _.cf._compare(_(t).prop("tagName"), "INPUT") ? _(t).val() : _(t).html()
      },
      _setValueOfElement: function (t, e) {
        _.cf._isValid(e) || (e = _(this.oData.oInputElement)), _.cf._compare(e.prop("tagName"), "INPUT") ? e.val(t) : e.html(t);
        var i = this.getDateObjectForInputField(e);
        return this.settings.settingValueOfElement && this.settings.settingValueOfElement.call(this, t, i, e), e.change(), t
      },
      _bindTouchEvents: function (e) {
        var i = this;
        _(i.element).find("." + e + " .increment, ." + e + " .increment *").on("touchstart mousedown", function (t) {
          t.stopPropagation(), _.cf._isValid(i.oData.sTouchButton) || (i.oData.iTouchStart = (new Date).getTime(), i.oData.sTouchButton = e + "-inc", i._setIntervalForTouchEvents())
        }), _(i.element).find("." + e + " .increment, ." + e + " .increment *").on("touchend mouseup", function (t) {
          t.stopPropagation(), i._clearIntervalForTouchEvents()
        }), _(i.element).find("." + e + " .decrement, ." + e + " .decrement *").on("touchstart mousedown", function (t) {
          t.stopPropagation(), _.cf._isValid(i.oData.sTouchButton) || (i.oData.iTouchStart = (new Date).getTime(), i.oData.sTouchButton = e + "-dec", i._setIntervalForTouchEvents())
        }), _(i.element).find("." + e + " .decrement, ." + e + " .decrement *").on("touchend mouseup", function (t) {
          t.stopPropagation(), i._clearIntervalForTouchEvents()
        })
      },
      _setIntervalForTouchEvents: function () {
        var t, e = this,
          i = e.oData.bIsTouchDevice ? e.settings.touchHoldInterval : e.settings.mouseHoldInterval;
        _.cf._isValid(e.oData.oTimeInterval) || (e.oData.oTimeInterval = setInterval(function () {
          t = (new Date).getTime() - e.oData.iTouchStart, i < t && _.cf._isValid(e.oData.sTouchButton) && ("day-inc" === e.oData.sTouchButton ? e.oData.iCurrentDay++ : "day-dec" === e.oData.sTouchButton ? e.oData.iCurrentDay-- : "month-inc" === e.oData.sTouchButton ? e.oData.iCurrentMonth++ : "month-dec" === e.oData.sTouchButton ? e.oData.iCurrentMonth-- : "year-inc" === e.oData.sTouchButton ? e.oData.iCurrentYear++ : "year-dec" === e.oData.sTouchButton ? e.oData.iCurrentYear-- : "hour-inc" === e.oData.sTouchButton ? e.oData.iCurrentHour++ : "hour-dec" === e.oData.sTouchButton ? e.oData.iCurrentHour-- : "minute-inc" === e.oData.sTouchButton ? e.oData.iCurrentMinutes += e.settings.minuteInterval : "minute-dec" === e.oData.sTouchButton ? e.oData.iCurrentMinutes -= e.settings.minuteInterval : "second-inc" === e.oData.sTouchButton ? e.oData.iCurrentSeconds += e.settings.secondsInterval : "second-dec" === e.oData.sTouchButton && (e.oData.iCurrentSeconds -= e.settings.secondsInterval), e._setCurrentDate(), e._setOutputOnIncrementOrDecrement(), e.oData.iTouchStart = (new Date).getTime())
        }, i))
      },
      _clearIntervalForTouchEvents: function () {
        clearInterval(this.oData.oTimeInterval), _.cf._isValid(this.oData.sTouchButton) && (this.oData.sTouchButton = null, this.oData.iTouchStart = 0), this.oData.oTimeInterval = null
      },
      _incrementDecrementActionsUsingArrowAndMouse: function (t, e) {
        var i = this;
        t.includes("day") ? "inc" === e ? i.oData.iCurrentDay++ : "dec" === e && i.oData.iCurrentDay-- : t.includes("month") ? "inc" === e ? i.oData.iCurrentMonth++ : "dec" === e && i.oData.iCurrentMonth-- : t.includes("year") ? "inc" === e ? i.oData.iCurrentYear++ : "dec" === e && i.oData.iCurrentYear-- : t.includes("hour") ? "inc" === e ? i.oData.iCurrentHour++ : "dec" === e && i.oData.iCurrentHour-- : t.includes("minutes") ? "inc" === e ? i.oData.iCurrentMinutes += i.settings.minuteInterval : "dec" === e && (i.oData.iCurrentMinutes -= i.settings.minuteInterval) : t.includes("seconds") && ("inc" === e ? i.oData.iCurrentSeconds += i.settings.secondsInterval : "dec" === e && (i.oData.iCurrentSeconds -= i.settings.secondsInterval)), i._setCurrentDate(), i._setOutputOnIncrementOrDecrement()
      },
      _parseDate: function (t) {
        var e, i = this,
          s = i.settings.defaultDate ? new Date(i.settings.defaultDate) : new Date,
          n = s.getDate(),
          a = s.getMonth(),
          o = s.getFullYear();
        return _.cf._isValid(t) && ("string" == typeof t ? (e = i.oData.bArrMatchFormat[4] || i.oData.bArrMatchFormat[5] || i.oData.bArrMatchFormat[6] ? t.split(i.settings.monthYearSeparator) : t.split(i.settings.dateSeparator), i.oData.bArrMatchFormat[0] ? (n = parseInt(e[0]), a = parseInt(e[1] - 1), o = parseInt(e[2])) : i.oData.bArrMatchFormat[1] ? (a = parseInt(e[0] - 1), n = parseInt(e[1]), o = parseInt(e[2])) : i.oData.bArrMatchFormat[2] ? (o = parseInt(e[0]), a = parseInt(e[1] - 1), n = parseInt(e[2])) : i.oData.bArrMatchFormat[3] ? (n = parseInt(e[0]), a = i._getShortMonthIndex(e[1]), o = parseInt(e[2])) : i.oData.bArrMatchFormat[4] ? (n = 1, a = parseInt(e[0]) - 1, o = parseInt(e[1])) : i.oData.bArrMatchFormat[5] ? (n = 1, a = i._getShortMonthIndex(e[0]), o = parseInt(e[1])) : i.oData.bArrMatchFormat[6] ? (n = 1, a = i._getFullMonthIndex(e[0]), o = parseInt(e[1])) : i.oData.bArrMatchFormat[7] && (n = 1, a = parseInt(e[1]) - 1, o = parseInt(e[0]))) : (n = t.getDate(), a = t.getMonth(), o = t.getFullYear())), s = new Date(o, a, n, 0, 0, 0, 0)
      },
      _parseTime: function (t) {
        var e, i, s = this,
          n = s.settings.defaultDate ? new Date(s.settings.defaultDate) : new Date,
          a = n.getDate(),
          o = n.getMonth(),
          r = n.getFullYear(),
          l = n.getHours(),
          c = n.getMinutes(),
          d = n.getSeconds(),
          h = s.oData.bArrMatchFormat[0] || s.oData.bArrMatchFormat[1],
          d = h ? s._adjustSeconds(d) : 0;
        return _.cf._isValid(t) && ("string" == typeof t ? (s.oData.bIs12Hour && (t = (i = t.split(s.settings.timeMeridiemSeparator))[0], e = i[1], _.cf._compare(e, "AM") || _.cf._compare(e, "PM") || (e = "")), i = t.split(s.settings.timeSeparator), l = parseInt(i[0]), c = parseInt(i[1]), h && (d = parseInt(i[2]), d = s._adjustSeconds(d)), 12 === l && _.cf._compare(e, "AM") ? l = 0 : l < 12 && _.cf._compare(e, "PM") && (l += 12)) : (l = t.getHours(), c = t.getMinutes(), h && (d = t.getSeconds(), d = s._adjustSeconds(d)))), c = s._adjustMinutes(c), n = new Date(r, o, a, l, c, d, 0)
      },
      _parseDateTime: function (t) {
        var e, i, s = this,
          n = s.settings.defaultDate ? new Date(s.settings.defaultDate) : new Date,
          a = n.getDate(),
          o = n.getMonth(),
          r = n.getFullYear(),
          l = n.getHours(),
          c = n.getMinutes(),
          d = n.getSeconds(),
          h = "",
          u = s.oData.bArrMatchFormat[0] || s.oData.bArrMatchFormat[1] || s.oData.bArrMatchFormat[2] || s.oData.bArrMatchFormat[3] || s.oData.bArrMatchFormat[4] || s.oData.bArrMatchFormat[5] || s.oData.bArrMatchFormat[6] || s.oData.bArrMatchFormat[7],
          d = u ? s._adjustSeconds(d) : 0;
        return _.cf._isValid(t) && ("string" == typeof t ? (i = (e = t.split(s.settings.dateTimeSeparator))[0].split(s.settings.dateSeparator), s.oData.bArrMatchFormat[0] || s.oData.bArrMatchFormat[1] || s.oData.bArrMatchFormat[8] || s.oData.bArrMatchFormat[9] ? (a = parseInt(i[0]), o = parseInt(i[1] - 1), r = parseInt(i[2])) : s.oData.bArrMatchFormat[2] || s.oData.bArrMatchFormat[3] || s.oData.bArrMatchFormat[10] || s.oData.bArrMatchFormat[11] ? (o = parseInt(i[0] - 1), a = parseInt(i[1]), r = parseInt(i[2])) : s.oData.bArrMatchFormat[4] || s.oData.bArrMatchFormat[5] || s.oData.bArrMatchFormat[12] || s.oData.bArrMatchFormat[13] ? (r = parseInt(i[0]), o = parseInt(i[1] - 1), a = parseInt(i[2])) : (s.oData.bArrMatchFormat[6] || s.oData.bArrMatchFormat[7] || s.oData.bArrMatchFormat[14] || s.oData.bArrMatchFormat[15]) && (a = parseInt(i[0]), o = s._getShortMonthIndex(i[1]), r = parseInt(i[2])), i = e[1], _.cf._isValid(i) && (s.oData.bIs12Hour && (h = _.cf._compare(s.settings.dateTimeSeparator, s.settings.timeMeridiemSeparator) && 3 === e.length ? e[2] : (i = (e = i.split(s.settings.timeMeridiemSeparator))[0], e[1]), _.cf._compare(h, "AM") || _.cf._compare(h, "PM") || (h = "")), i = i.split(s.settings.timeSeparator), l = parseInt(i[0]), c = parseInt(i[1]), u && (d = parseInt(i[2])), 12 === l && _.cf._compare(h, "AM") ? l = 0 : l < 12 && _.cf._compare(h, "PM") && (l += 12))) : (a = t.getDate(), o = t.getMonth(), r = t.getFullYear(), l = t.getHours(), c = t.getMinutes(), u && (d = t.getSeconds(), d = s._adjustSeconds(d)))), c = s._adjustMinutes(c), n = new Date(r, o, a, l, c, d, 0)
      },
      _getShortMonthIndex: function (t) {
        for (var e = 0; e < this.settings.shortMonthNames.length; e++)
          if (_.cf._compare(t, this.settings.shortMonthNames[e])) return e
      },
      _getFullMonthIndex: function (t) {
        for (var e = 0; e < this.settings.fullMonthNames.length; e++)
          if (_.cf._compare(t, this.settings.fullMonthNames[e])) return e
      },
      getIs12Hour: function (t, e) {
        var i = this,
          s = !1,
          n = Function.length;
        return i._setMatchFormat(n, t, e), i.oData.bTimeMode ? s = i.oData.bArrMatchFormat[0] || i.oData.bArrMatchFormat[2] : i.oData.bDateTimeMode && (s = i.oData.bArrMatchFormat[1] || i.oData.bArrMatchFormat[3] || i.oData.bArrMatchFormat[5] || i.oData.bArrMatchFormat[7] || i.oData.bArrMatchFormat[9] || i.oData.bArrMatchFormat[11] || i.oData.bArrMatchFormat[13] || i.oData.bArrMatchFormat[15]), i._setMatchFormat(n), s
      },
      _setVariablesForDate: function (t, e, i) {
        var s, n = {},
          a = _.cf._isValid(t);
        if (a ? (s = new Date(t), _.cf._isValid(e) || (e = !0), _.cf._isValid(i) || (i = !0)) : (s = "[object Date]" === Object.prototype.toString.call(this.oData.dCurrentDate) && isFinite(this.oData.dCurrentDate) ? new Date(this.oData.dCurrentDate) : new Date, _.cf._isValid(e) || (e = this.oData.bTimeMode || this.oData.bDateTimeMode), _.cf._isValid(i) || (i = this.oData.bIs12Hour)), n.iCurrentDay = s.getDate(), n.iCurrentMonth = s.getMonth(), n.iCurrentYear = s.getFullYear(), n.iCurrentWeekday = s.getDay(), e && (n.iCurrentHour = s.getHours(), n.iCurrentMinutes = s.getMinutes(), n.iCurrentSeconds = s.getSeconds(), i && (n.sCurrentMeridiem = this._determineMeridiemFromHourAndMinutes(n.iCurrentHour, n.iCurrentMinutes))), a) return n;
        this.oData = _.extend(this.oData, n)
      },
      _getValuesFromInputBoxes: function () {
        var t, e, i, s = this;
        (s.oData.bDateMode || s.oData.bDateTimeMode) && (1 < (i = _(s.element).find(".month .dtpicker-compValue").val()).length && (i = i.charAt(0).toUpperCase() + i.slice(1)), -1 !== (e = s.settings.shortMonthNames.indexOf(i)) ? s.oData.iCurrentMonth = parseInt(e) : i.match("^[+|-]?[0-9]+$") && (s.oData.iCurrentMonth = parseInt(i - 1)), s.oData.iCurrentDay = parseInt(_(s.element).find(".day .dtpicker-compValue").val()) || s.oData.iCurrentDay, s.oData.iCurrentYear = parseInt(_(s.element).find(".year .dtpicker-compValue").val()) || s.oData.iCurrentYear), (s.oData.bTimeMode || s.oData.bDateTimeMode) && (t = parseInt(_(s.element).find(".hour .dtpicker-compValue").val()), e = s._adjustMinutes(parseInt(_(s.element).find(".minutes .dtpicker-compValue").val())), i = s._adjustMinutes(parseInt(_(s.element).find(".seconds .dtpicker-compValue").val())), s.oData.iCurrentHour = isNaN(t) ? s.oData.iCurrentHour : t, s.oData.iCurrentMinutes = isNaN(e) ? s.oData.iCurrentMinutes : e, s.oData.iCurrentSeconds = isNaN(i) ? s.oData.iCurrentSeconds : i, 59 < s.oData.iCurrentSeconds && (s.oData.iCurrentMinutes += s.oData.iCurrentSeconds / 60, s.oData.iCurrentSeconds = s.oData.iCurrentSeconds % 60), 59 < s.oData.iCurrentMinutes && (s.oData.iCurrentHour += s.oData.iCurrentMinutes / 60, s.oData.iCurrentMinutes = s.oData.iCurrentMinutes % 60), s.oData.bIs12Hour ? 12 < s.oData.iCurrentHour && (s.oData.iCurrentHour = s.oData.iCurrentHour % 12) : 23 < s.oData.iCurrentHour && (s.oData.iCurrentHour = s.oData.iCurrentHour % 23), s.oData.bIs12Hour && (i = _(s.element).find(".meridiem .dtpicker-compValue").val(), (_.cf._compare(i, "AM") || _.cf._compare(i, "PM")) && (s.oData.sCurrentMeridiem = i), _.cf._compare(s.oData.sCurrentMeridiem, "PM") && 12 !== s.oData.iCurrentHour && s.oData.iCurrentHour < 13 && (s.oData.iCurrentHour += 12), _.cf._compare(s.oData.sCurrentMeridiem, "AM") && 12 === s.oData.iCurrentHour && (s.oData.iCurrentHour = 0)))
      },
      _setCurrentDate: function () {
        var t = this;
        (t.oData.bTimeMode || t.oData.bDateTimeMode) && (59 < t.oData.iCurrentSeconds ? (t.oData.iCurrentMinutes += t.oData.iCurrentSeconds / 60, t.oData.iCurrentSeconds = t.oData.iCurrentSeconds % 60) : t.oData.iCurrentSeconds < 0 && (t.oData.iCurrentMinutes -= t.settings.minuteInterval, t.oData.iCurrentSeconds += 60), t.oData.iCurrentMinutes = t._adjustMinutes(t.oData.iCurrentMinutes), t.oData.iCurrentSeconds = t._adjustSeconds(t.oData.iCurrentSeconds));
        var e, i, s, n, a, o = new Date(t.oData.iCurrentYear, t.oData.iCurrentMonth, t.oData.iCurrentDay, t.oData.iCurrentHour, t.oData.iCurrentMinutes, t.oData.iCurrentSeconds, 0),
          r = !1,
          l = !1;
        null !== t.oData.dMaxValue && (r = o.getTime() > t.oData.dMaxValue.getTime()), null !== t.oData.dMinValue && (l = o.getTime() < t.oData.dMinValue.getTime()), (r || l) && (a = s = !1, null !== t.oData.dMaxValue && (s = t.oData.dCurrentDate.getTime() > t.oData.dMaxValue.getTime()), null !== t.oData.dMinValue && (a = t.oData.dCurrentDate.getTime() < t.oData.dMinValue.getTime()), s || a ? (s && (o = new Date(t.oData.dMaxValue), console.log("Info : Date/Time/DateTime you entered is later than Maximum value, so DateTimePicker is showing Maximum value in Input Field.")), a && (o = new Date(t.oData.dMinValue), console.log("Info : Date/Time/DateTime you entered is earlier than Minimum value, so DateTimePicker is showing Minimum value in Input Field.")), console.log("Please enter proper Date/Time/DateTime values.")) : o = new Date(t.oData.dCurrentDate)), t.oData.dCurrentDate = new Date(o), t._setVariablesForDate(), i = {}, s = l = r = "", (t.oData.bDateMode || t.oData.bDateTimeMode) && (t.oData.bDateMode && (t.oData.bArrMatchFormat[4] || t.oData.bArrMatchFormat[5] || t.oData.bArrMatchFormat[6]) && (t.oData.iCurrentDay = 1), n = t._formatDate(), _(t.element).find(".day .dtpicker-compValue").val(n.dd), t.oData.bDateMode ? t.oData.bArrMatchFormat[4] || t.oData.bArrMatchFormat[7] ? _(t.element).find(".month .dtpicker-compValue").val(n.mm) : t.oData.bArrMatchFormat[6] ? _(t.element).find(".month .dtpicker-compValue").val(n.month) : _(t.element).find(".month .dtpicker-compValue").val(n.monthShort) : _(t.element).find(".month .dtpicker-compValue").val(n.monthShort), _(t.element).find(".year .dtpicker-compValue").val(n.yyyy), t.settings.formatHumanDate ? i = _.extend(i, n) : t.oData.bDateMode && (t.oData.bArrMatchFormat[4] || t.oData.bArrMatchFormat[5] || t.oData.bArrMatchFormat[6] || t.oData.bArrMatchFormat[7]) ? t.oData.bArrMatchFormat[4] ? r = n.MM + t.settings.monthYearSeparator + n.yyyy : t.oData.bArrMatchFormat[5] ? r = n.monthShort + t.settings.monthYearSeparator + n.yyyy : t.oData.bArrMatchFormat[6] ? r = n.month + t.settings.monthYearSeparator + n.yyyy : t.oData.bArrMatchFormat[7] && (r = n.yyyy + t.settings.monthYearSeparator + n.MM) : r = n.dayShort + ", " + n.month + " " + n.dd + ", " + n.yyyy), (t.oData.bTimeMode || t.oData.bDateTimeMode) && (a = t._formatTime(), t.oData.bIs12Hour && _(t.element).find(".meridiem .dtpicker-compValue").val(t.oData.sCurrentMeridiem), _(t.element).find(".hour .dtpicker-compValue").val(a.hour), _(t.element).find(".minutes .dtpicker-compValue").val(a.mm), _(t.element).find(".seconds .dtpicker-compValue").val(a.ss), t.settings.formatHumanDate ? i = _.extend(i, a) : (o = t.oData.bTimeMode && (t.oData.bArrMatchFormat[0] || t.oData.bArrMatchFormat[1]), n = t.oData.bDateTimeMode && (t.oData.bArrMatchFormat[0] || t.oData.bArrMatchFormat[1] || t.oData.bArrMatchFormat[2] || t.oData.bArrMatchFormat[3] || t.oData.bArrMatchFormat[4] || t.oData.bArrMatchFormat[5] || t.oData.bArrMatchFormat[6] || t.oData.bArrMatchFormat[7]), l = o || n ? a.hour + t.settings.timeSeparator + a.mm + t.settings.timeSeparator + a.ss : a.hour + t.settings.timeSeparator + a.mm, t.oData.bIs12Hour && (l += t.settings.timeMeridiemSeparator + t.oData.sCurrentMeridiem))), t.settings.formatHumanDate ? (t.oData.bDateTimeMode ? e = t.oData.sDateFormat : t.oData.bDateMode ? e = t.oData.sTimeFormat : t.oData.bTimeMode && (e = t.oData.sDateTimeFormat), s = t.settings.formatHumanDate.call(t, i, t.settings.mode, e)) : t.oData.bDateTimeMode ? s = r + t.settings.dateTimeSeparator + l : t.oData.bDateMode ? s = r : t.oData.bTimeMode && (s = l), _(t.element).find(".dtpicker-value").html(s), t._setButtons()
      },
      _formatDate: function (t) {
        var e, i, s, n, a = {};
        return _.cf._isValid(t) ? a = _.extend({}, t) : (a.iCurrentDay = this.oData.iCurrentDay, a.iCurrentMonth = this.oData.iCurrentMonth, a.iCurrentYear = this.oData.iCurrentYear, a.iCurrentWeekday = this.oData.iCurrentWeekday), e = a.iCurrentDay, i = a.iCurrentMonth, s = a.iCurrentMonth + 1, n = this.settings.shortMonthNames[i], t = this.settings.fullMonthNames[i], i = a.iCurrentYear, a = a.iCurrentWeekday, {
          dd: e = e < 10 ? "0" + e : e,
          MM: s = s < 10 ? "0" + s : s,
          monthShort: n,
          month: t,
          yyyy: i,
          dayShort: this.settings.shortDayNames[a],
          day: this.settings.fullDayNames[a]
        }
      },
      _formatTime: function (t) {
        var e, i, s, n, a, o, r = {};
        return _.cf._isValid(t) ? r = _.extend({}, t) : (r.iCurrentHour = this.oData.iCurrentHour, r.iCurrentMinutes = this.oData.iCurrentMinutes, r.iCurrentSeconds = this.oData.iCurrentSeconds, r.sCurrentMeridiem = this.oData.sCurrentMeridiem), a = i = (e = r.iCurrentHour) < 10 ? "0" + e : e, 12 < (s = r.iCurrentHour) && (s -= 12), n = (s = "00" === i ? 12 : s) < 10 ? "0" + s : s, this.oData.bIs12Hour && (a = n), o = r.iCurrentMinutes, t = r.iCurrentSeconds, {
          H: e,
          HH: i,
          h: s,
          hh: n,
          hour: a,
          m: r.iCurrentMinutes,
          mm: o = o < 10 ? "0" + o : o,
          s: r.iCurrentSeconds,
          ss: t = t < 10 ? "0" + t : t,
          ME: r.sCurrentMeridiem
        }
      },
      _setButtons: function () {
        var t, e, i, s = this;
        _(s.element).find(".dtpicker-compButton").removeClass("dtpicker-compButtonDisable").addClass("dtpicker-compButtonEnable"), null !== s.oData.dMaxValue && (s.oData.bTimeMode ? ((s.oData.iCurrentHour + 1 > s.oData.dMaxValue.getHours() || s.oData.iCurrentHour + 1 === s.oData.dMaxValue.getHours() && s.oData.iCurrentMinutes > s.oData.dMaxValue.getMinutes()) && _(s.element).find(".hour .increment").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), s.oData.iCurrentHour >= s.oData.dMaxValue.getHours() && s.oData.iCurrentMinutes + 1 > s.oData.dMaxValue.getMinutes() && _(s.element).find(".minutes .increment").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable")) : ((t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay + 1, s.oData.iCurrentHour, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0)).getTime() > s.oData.dMaxValue.getTime() && _(s.element).find(".day .increment").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth + 1, s.oData.iCurrentDay, s.oData.iCurrentHour, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0)).getTime() > s.oData.dMaxValue.getTime() && _(s.element).find(".month .increment").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear + 1, s.oData.iCurrentMonth, s.oData.iCurrentDay, s.oData.iCurrentHour, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0)).getTime() > s.oData.dMaxValue.getTime() && _(s.element).find(".year .increment").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay, s.oData.iCurrentHour + 1, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0)).getTime() > s.oData.dMaxValue.getTime() && _(s.element).find(".hour .increment").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay, s.oData.iCurrentHour, s.oData.iCurrentMinutes + 1, s.oData.iCurrentSeconds, 0)).getTime() > s.oData.dMaxValue.getTime() && _(s.element).find(".minutes .increment").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay, s.oData.iCurrentHour, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds + 1, 0)).getTime() > s.oData.dMaxValue.getTime() && _(s.element).find(".seconds .increment").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"))), null !== s.oData.dMinValue && (s.oData.bTimeMode ? ((s.oData.iCurrentHour - 1 < s.oData.dMinValue.getHours() || s.oData.iCurrentHour - 1 === s.oData.dMinValue.getHours() && s.oData.iCurrentMinutes < s.oData.dMinValue.getMinutes()) && _(s.element).find(".hour .decrement").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), s.oData.iCurrentHour <= s.oData.dMinValue.getHours() && s.oData.iCurrentMinutes - 1 < s.oData.dMinValue.getMinutes() && _(s.element).find(".minutes .decrement").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable")) : ((t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay - 1, s.oData.iCurrentHour, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0)).getTime() < s.oData.dMinValue.getTime() && _(s.element).find(".day .decrement").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth - 1, s.oData.iCurrentDay, s.oData.iCurrentHour, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0)).getTime() < s.oData.dMinValue.getTime() && _(s.element).find(".month .decrement").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear - 1, s.oData.iCurrentMonth, s.oData.iCurrentDay, s.oData.iCurrentHour, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0)).getTime() < s.oData.dMinValue.getTime() && _(s.element).find(".year .decrement").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay, s.oData.iCurrentHour - 1, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0)).getTime() < s.oData.dMinValue.getTime() && _(s.element).find(".hour .decrement").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay, s.oData.iCurrentHour, s.oData.iCurrentMinutes - 1, s.oData.iCurrentSeconds, 0)).getTime() < s.oData.dMinValue.getTime() && _(s.element).find(".minutes .decrement").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"), (t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay, s.oData.iCurrentHour, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds - 1, 0)).getTime() < s.oData.dMinValue.getTime() && _(s.element).find(".seconds .decrement").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"))), s.oData.bIs12Hour && (null === s.oData.dMaxValue && null === s.oData.dMinValue || (e = s.oData.iCurrentHour, _.cf._compare(s.oData.sCurrentMeridiem, "AM") ? e += 12 : _.cf._compare(s.oData.sCurrentMeridiem, "PM") && (e -= 12), t = new Date(s.oData.iCurrentYear, s.oData.iCurrentMonth, s.oData.iCurrentDay, e, s.oData.iCurrentMinutes, s.oData.iCurrentSeconds, 0), null !== s.oData.dMaxValue && (s.oData.bTimeMode ? (i = s.oData.iCurrentMinutes, (e > s.oData.dMaxValue.getHours() || e === s.oData.dMaxValue.getHours() && i > s.oData.dMaxValue.getMinutes()) && _(s.element).find(".meridiem .dtpicker-compButton").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable")) : t.getTime() > s.oData.dMaxValue.getTime() && _(s.element).find(".meridiem .dtpicker-compButton").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable")), null !== s.oData.dMinValue && (s.oData.bTimeMode ? (i = s.oData.iCurrentMinutes, (e < s.oData.dMinValue.getHours() || e === s.oData.dMinValue.getHours() && i < s.oData.dMinValue.getMinutes()) && _(s.element).find(".meridiem .dtpicker-compButton").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable")) : t.getTime() < s.oData.dMinValue.getTime() && _(s.element).find(".meridiem .dtpicker-compButton").removeClass("dtpicker-compButtonEnable").addClass("dtpicker-compButtonDisable"))))
      },
      setIsPopup: function (t) {
        var e, i, s = this;
        s.settings.isInline || (s.settings.isPopup = t, "none" !== _(s.element).css("display") && s._hidePicker(0), s.settings.isPopup ? (_(s.element).addClass("dtpicker-mobile"), _(s.element).css({
          position: "fixed",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%"
        })) : (_(s.element).removeClass("dtpicker-mobile"), null !== s.oData.oInputElement && (e = _(s.oData.oInputElement).offset().top + _(s.oData.oInputElement).outerHeight(), i = _(s.oData.oInputElement).offset().left, t = _(s.oData.oInputElement).outerWidth(), _(s.element).css({
          position: "absolute",
          top: e,
          left: i,
          width: t,
          height: "auto"
        }))))
      },
      _compareDates: function (t, e) {
        e = ((t = new Date(t.getDate(), t.getMonth(), t.getFullYear(), 0, 0, 0, 0)).getTime() - e.getTime()) / 864e5;
        return 0 == e ? e : e / Math.abs(e)
      },
      _compareTime: function (t, e) {
        var i = 0;
        return t.getHours() === e.getHours() && t.getMinutes() === e.getMinutes() ? i = 1 : t.getHours() < e.getHours() ? i = 2 : t.getHours() > e.getHours() ? i = 3 : t.getHours() === e.getHours() && (t.getMinutes() < e.getMinutes() ? i = 2 : t.getMinutes() > e.getMinutes() && (i = 3)), i
      },
      _compareDateTime: function (t, e) {
        e = (t.getTime() - e.getTime()) / 6e4;
        return 0 == e ? e : e / Math.abs(e)
      },
      _determineMeridiemFromHourAndMinutes: function (t, e) {
        return 12 < t || 12 === t && 0 <= e ? "PM" : "AM"
      },
      setLanguage: function (t) {
        return this.settings = _.extend({}, _.DateTimePicker.defaults, _.DateTimePicker.i18n[t], this.options), this.settings.language = t, this._setDateFormatArray(), this._setTimeFormatArray(), this._setDateTimeFormatArray(), this
      }
    }
  }), $(document).on("click", "#dtpicker-close", function () {
    $(".dtpicker-mobile").hide(), alert(1)
  }), $(document).ready(function () {
    $(".reg-calendar").datepicker({
      dateFormat: "dd MM yy",
      showOn: "both",
      buttonText: '<img src="./assets/images/ico-calendar-outline.svg" alt="calendar" title="calendar" loading="lazy">',
      altField: ".usia-anak",
      altFormat: "yy-mm-dd",
      changeMonth: !0,
      changeYear: !0
    }), datePick(), $("#datepicker").datepicker(), $("#dtBox").DateTimePicker({
      dateFormat: "dd-MMM-yyyy"
    })
  }),
  function (t) {
    "function" == typeof define && define.amd ? define(["jquery"], t) : t(jQuery)
  }(function (x) {
    x.ui = x.ui || {}, x.ui.version = "1.12.1";
    var n, s, C, k, a, o, r, l, c, i, d = 0,
      h = Array.prototype.slice;

    function T(t, e, i) {
      return [parseFloat(t[0]) * (c.test(t[0]) ? e / 100 : 1), parseFloat(t[1]) * (c.test(t[1]) ? i / 100 : 1)]
    }

    function D(t, e) {
      return parseInt(x.css(t, e), 10) || 0
    }
    x.cleanData = (n = x.cleanData, function (t) {
      for (var e, i, s = 0; null != (i = t[s]); s++) try {
        (e = x._data(i, "events")) && e.remove && x(i).triggerHandler("remove")
      } catch (t) {}
      n(t)
    }), x.widget = function (t, i, e) {
      var s, n, a, o = {},
        r = t.split(".")[0],
        l = r + "-" + (t = t.split(".")[1]);
      return e || (e = i, i = x.Widget), x.isArray(e) && (e = x.extend.apply(null, [{}].concat(e))), x.expr[":"][l.toLowerCase()] = function (t) {
        return !!x.data(t, l)
      }, x[r] = x[r] || {}, s = x[r][t], n = x[r][t] = function (t, e) {
        if (!this._createWidget) return new n(t, e);
        arguments.length && this._createWidget(t, e)
      }, x.extend(n, s, {
        version: e.version,
        _proto: x.extend({}, e),
        _childConstructors: []
      }), (a = new i).options = x.widget.extend({}, a.options), x.each(e, function (e, s) {
        function n() {
          return i.prototype[e].apply(this, arguments)
        }

        function a(t) {
          return i.prototype[e].apply(this, t)
        }
        x.isFunction(s) ? o[e] = function () {
          var t, e = this._super,
            i = this._superApply;
          return this._super = n, this._superApply = a, t = s.apply(this, arguments), this._super = e, this._superApply = i, t
        } : o[e] = s
      }), n.prototype = x.widget.extend(a, {
        widgetEventPrefix: s && a.widgetEventPrefix || t
      }, o, {
        constructor: n,
        namespace: r,
        widgetName: t,
        widgetFullName: l
      }), s ? (x.each(s._childConstructors, function (t, e) {
        var i = e.prototype;
        x.widget(i.namespace + "." + i.widgetName, n, e._proto)
      }), delete s._childConstructors) : i._childConstructors.push(n), x.widget.bridge(t, n), n
    }, x.widget.extend = function (t) {
      for (var e, i, s = h.call(arguments, 1), n = 0, a = s.length; n < a; n++)
        for (e in s[n]) i = s[n][e], s[n].hasOwnProperty(e) && void 0 !== i && (x.isPlainObject(i) ? t[e] = x.isPlainObject(t[e]) ? x.widget.extend({}, t[e], i) : x.widget.extend({}, i) : t[e] = i);
      return t
    }, x.widget.bridge = function (a, e) {
      var o = e.prototype.widgetFullName || a;
      x.fn[a] = function (i) {
        var t = "string" == typeof i,
          s = h.call(arguments, 1),
          n = this;
        return t ? this.length || "instance" !== i ? this.each(function () {
          var t, e = x.data(this, o);
          return "instance" === i ? (n = e, !1) : e ? x.isFunction(e[i]) && "_" !== i.charAt(0) ? (t = e[i].apply(e, s)) !== e && void 0 !== t ? (n = t && t.jquery ? n.pushStack(t.get()) : t, !1) : void 0 : x.error("no such method '" + i + "' for " + a + " widget instance") : x.error("cannot call methods on " + a + " prior to initialization; attempted to call method '" + i + "'")
        }) : n = void 0 : (s.length && (i = x.widget.extend.apply(null, [i].concat(s))), this.each(function () {
          var t = x.data(this, o);
          t ? (t.option(i || {}), t._init && t._init()) : x.data(this, o, new e(i, this))
        })), n
      }
    }, x.Widget = function () {}, x.Widget._childConstructors = [], x.Widget.prototype = {
      widgetName: "widget",
      widgetEventPrefix: "",
      defaultElement: "<div>",
      options: {
        classes: {},
        disabled: !1,
        create: null
      },
      _createWidget: function (t, e) {
        e = x(e || this.defaultElement || this)[0], this.element = x(e), this.uuid = d++, this.eventNamespace = "." + this.widgetName + this.uuid, this.bindings = x(), this.hoverable = x(), this.focusable = x(), this.classesElementLookup = {}, e !== this && (x.data(e, this.widgetFullName, this), this._on(!0, this.element, {
          remove: function (t) {
            t.target === e && this.destroy()
          }
        }), this.document = x(e.style ? e.ownerDocument : e.document || e), this.window = x(this.document[0].defaultView || this.document[0].parentWindow)), this.options = x.widget.extend({}, this.options, this._getCreateOptions(), t), this._create(), this.options.disabled && this._setOptionDisabled(this.options.disabled), this._trigger("create", null, this._getCreateEventData()), this._init()
      },
      _getCreateOptions: function () {
        return {}
      },
      _getCreateEventData: x.noop,
      _create: x.noop,
      _init: x.noop,
      destroy: function () {
        var i = this;
        this._destroy(), x.each(this.classesElementLookup, function (t, e) {
          i._removeClass(e, t)
        }), this.element.off(this.eventNamespace).removeData(this.widgetFullName), this.widget().off(this.eventNamespace).removeAttr("aria-disabled"), this.bindings.off(this.eventNamespace)
      },
      _destroy: x.noop,
      widget: function () {
        return this.element
      },
      option: function (t, e) {
        var i, s, n, a = t;
        if (0 === arguments.length) return x.widget.extend({}, this.options);
        if ("string" == typeof t)
          if (a = {}, t = (i = t.split(".")).shift(), i.length) {
            for (s = a[t] = x.widget.extend({}, this.options[t]), n = 0; n < i.length - 1; n++) s[i[n]] = s[i[n]] || {}, s = s[i[n]];
            if (t = i.pop(), 1 === arguments.length) return void 0 === s[t] ? null : s[t];
            s[t] = e
          } else {
            if (1 === arguments.length) return void 0 === this.options[t] ? null : this.options[t];
            a[t] = e
          } return this._setOptions(a), this
      },
      _setOptions: function (t) {
        for (var e in t) this._setOption(e, t[e]);
        return this
      },
      _setOption: function (t, e) {
        return "classes" === t && this._setOptionClasses(e), this.options[t] = e, "disabled" === t && this._setOptionDisabled(e), this
      },
      _setOptionClasses: function (t) {
        var e, i, s;
        for (e in t) s = this.classesElementLookup[e], t[e] !== this.options.classes[e] && s && s.length && (i = x(s.get()), this._removeClass(s, e), i.addClass(this._classes({
          element: i,
          keys: e,
          classes: t,
          add: !0
        })))
      },
      _setOptionDisabled: function (t) {
        this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !!t), t && (this._removeClass(this.hoverable, null, "ui-state-hover"), this._removeClass(this.focusable, null, "ui-state-focus"))
      },
      enable: function () {
        return this._setOptions({
          disabled: !1
        })
      },
      disable: function () {
        return this._setOptions({
          disabled: !0
        })
      },
      _classes: function (n) {
        var a = [],
          o = this;

        function t(t, e) {
          for (var i, s = 0; s < t.length; s++) i = o.classesElementLookup[t[s]] || x(), i = n.add ? x(x.unique(i.get().concat(n.element.get()))) : x(i.not(n.element).get()), o.classesElementLookup[t[s]] = i, a.push(t[s]), e && n.classes[t[s]] && a.push(n.classes[t[s]])
        }
        return n = x.extend({
          element: this.element,
          classes: this.options.classes || {}
        }, n), this._on(n.element, {
          remove: "_untrackClassesElement"
        }), n.keys && t(n.keys.match(/\S+/g) || [], !0), n.extra && t(n.extra.match(/\S+/g) || []), a.join(" ")
      },
      _untrackClassesElement: function (i) {
        var s = this;
        x.each(s.classesElementLookup, function (t, e) {
          -1 !== x.inArray(i.target, e) && (s.classesElementLookup[t] = x(e.not(i.target).get()))
        })
      },
      _removeClass: function (t, e, i) {
        return this._toggleClass(t, e, i, !1)
      },
      _addClass: function (t, e, i) {
        return this._toggleClass(t, e, i, !0)
      },
      _toggleClass: function (t, e, i, s) {
        var n = "string" == typeof t || null === t,
          i = {
            extra: n ? e : i,
            keys: n ? t : e,
            element: n ? this.element : t,
            add: s = "boolean" == typeof s ? s : i
          };
        return i.element.toggleClass(this._classes(i), s), this
      },
      _on: function (n, a, t) {
        var o, r = this;
        "boolean" != typeof n && (t = a, a = n, n = !1), t ? (a = o = x(a), this.bindings = this.bindings.add(a)) : (t = a, a = this.element, o = this.widget()), x.each(t, function (t, e) {
          function i() {
            if (n || !0 !== r.options.disabled && !x(this).hasClass("ui-state-disabled")) return ("string" == typeof e ? r[e] : e).apply(r, arguments)
          }
          "string" != typeof e && (i.guid = e.guid = e.guid || i.guid || x.guid++);
          var s = t.match(/^([\w:-]*)\s*(.*)$/),
            t = s[1] + r.eventNamespace,
            s = s[2];
          s ? o.on(t, s, i) : a.on(t, i)
        })
      },
      _off: function (t, e) {
        e = (e || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, t.off(e).off(e), this.bindings = x(this.bindings.not(t).get()), this.focusable = x(this.focusable.not(t).get()), this.hoverable = x(this.hoverable.not(t).get())
      },
      _delay: function (t, e) {
        var i = this;
        return setTimeout(function () {
          return ("string" == typeof t ? i[t] : t).apply(i, arguments)
        }, e || 0)
      },
      _hoverable: function (t) {
        this.hoverable = this.hoverable.add(t), this._on(t, {
          mouseenter: function (t) {
            this._addClass(x(t.currentTarget), null, "ui-state-hover")
          },
          mouseleave: function (t) {
            this._removeClass(x(t.currentTarget), null, "ui-state-hover")
          }
        })
      },
      _focusable: function (t) {
        this.focusable = this.focusable.add(t), this._on(t, {
          focusin: function (t) {
            this._addClass(x(t.currentTarget), null, "ui-state-focus")
          },
          focusout: function (t) {
            this._removeClass(x(t.currentTarget), null, "ui-state-focus")
          }
        })
      },
      _trigger: function (t, e, i) {
        var s, n, a = this.options[t];
        if (i = i || {}, (e = x.Event(e)).type = (t === this.widgetEventPrefix ? t : this.widgetEventPrefix + t).toLowerCase(), e.target = this.element[0], n = e.originalEvent)
          for (s in n) s in e || (e[s] = n[s]);
        return this.element.trigger(e, i), !(x.isFunction(a) && !1 === a.apply(this.element[0], [e].concat(i)) || e.isDefaultPrevented())
      }
    }, x.each({
      show: "fadeIn",
      hide: "fadeOut"
    }, function (a, o) {
      x.Widget.prototype["_" + a] = function (e, t, i) {
        var s, n = (t = "string" == typeof t ? {
          effect: t
        } : t) ? !0 !== t && "number" != typeof t && t.effect || o : a;
        "number" == typeof (t = t || {}) && (t = {
          duration: t
        }), s = !x.isEmptyObject(t), t.complete = i, t.delay && e.delay(t.delay), s && x.effects && x.effects.effect[n] ? e[a](t) : n !== a && e[n] ? e[n](t.duration, t.easing, i) : e.queue(function (t) {
          x(this)[a](), i && i.call(e[0]), t()
        })
      }
    }), x.widget, C = Math.max, k = Math.abs, a = /left|center|right/, o = /top|center|bottom/, r = /[\+\-]\d+(\.[\d]+)?%?/, l = /^\w+/, c = /%$/, i = x.fn.position, x.position = {
      scrollbarWidth: function () {
        if (void 0 !== s) return s;
        var t, e = x("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
          i = e.children()[0];
        return x("body").append(e), t = i.offsetWidth, e.css("overflow", "scroll"), t === (i = i.offsetWidth) && (i = e[0].clientWidth), e.remove(), s = t - i
      },
      getScrollInfo: function (t) {
        var e = t.isWindow || t.isDocument ? "" : t.element.css("overflow-x"),
          i = t.isWindow || t.isDocument ? "" : t.element.css("overflow-y"),
          e = "scroll" === e || "auto" === e && t.width < t.element[0].scrollWidth;
        return {
          width: "scroll" === i || "auto" === i && t.height < t.element[0].scrollHeight ? x.position.scrollbarWidth() : 0,
          height: e ? x.position.scrollbarWidth() : 0
        }
      },
      getWithinInfo: function (t) {
        var e = x(t || window),
          i = x.isWindow(e[0]),
          s = !!e[0] && 9 === e[0].nodeType;
        return {
          element: e,
          isWindow: i,
          isDocument: s,
          offset: i || s ? {
            left: 0,
            top: 0
          } : x(t).offset(),
          scrollLeft: e.scrollLeft(),
          scrollTop: e.scrollTop(),
          width: e.outerWidth(),
          height: e.outerHeight()
        }
      }
    }, x.fn.position = function (h) {
      if (!h || !h.of) return i.apply(this, arguments);
      h = x.extend({}, h);
      var u, p, f, m, g, t, v = x(h.of),
        b = x.position.getWithinInfo(h.within),
        _ = x.position.getScrollInfo(b),
        y = (h.collision || "flip").split(" "),
        w = {},
        e = 9 === (t = (e = v)[0]).nodeType ? {
          width: e.width(),
          height: e.height(),
          offset: {
            top: 0,
            left: 0
          }
        } : x.isWindow(t) ? {
          width: e.width(),
          height: e.height(),
          offset: {
            top: e.scrollTop(),
            left: e.scrollLeft()
          }
        } : t.preventDefault ? {
          width: 0,
          height: 0,
          offset: {
            top: t.pageY,
            left: t.pageX
          }
        } : {
          width: e.outerWidth(),
          height: e.outerHeight(),
          offset: e.offset()
        };
      return v[0].preventDefault && (h.at = "left top"), p = e.width, f = e.height, g = x.extend({}, m = e.offset), x.each(["my", "at"], function () {
        var t, e, i = (h[this] || "").split(" ");
        (i = 1 === i.length ? a.test(i[0]) ? i.concat(["center"]) : o.test(i[0]) ? ["center"].concat(i) : ["center", "center"] : i)[0] = a.test(i[0]) ? i[0] : "center", i[1] = o.test(i[1]) ? i[1] : "center", t = r.exec(i[0]), e = r.exec(i[1]), w[this] = [t ? t[0] : 0, e ? e[0] : 0], h[this] = [l.exec(i[0])[0], l.exec(i[1])[0]]
      }), 1 === y.length && (y[1] = y[0]), "right" === h.at[0] ? g.left += p : "center" === h.at[0] && (g.left += p / 2), "bottom" === h.at[1] ? g.top += f : "center" === h.at[1] && (g.top += f / 2), u = T(w.at, p, f), g.left += u[0], g.top += u[1], this.each(function () {
        var i, t, o = x(this),
          r = o.outerWidth(),
          l = o.outerHeight(),
          e = D(this, "marginLeft"),
          s = D(this, "marginTop"),
          n = r + e + D(this, "marginRight") + _.width,
          a = l + s + D(this, "marginBottom") + _.height,
          c = x.extend({}, g),
          d = T(w.my, o.outerWidth(), o.outerHeight());
        "right" === h.my[0] ? c.left -= r : "center" === h.my[0] && (c.left -= r / 2), "bottom" === h.my[1] ? c.top -= l : "center" === h.my[1] && (c.top -= l / 2), c.left += d[0], c.top += d[1], i = {
          marginLeft: e,
          marginTop: s
        }, x.each(["left", "top"], function (t, e) {
          x.ui.position[y[t]] && x.ui.position[y[t]][e](c, {
            targetWidth: p,
            targetHeight: f,
            elemWidth: r,
            elemHeight: l,
            collisionPosition: i,
            collisionWidth: n,
            collisionHeight: a,
            offset: [u[0] + d[0], u[1] + d[1]],
            my: h.my,
            at: h.at,
            within: b,
            elem: o
          })
        }), h.using && (t = function (t) {
          var e = m.left - c.left,
            i = e + p - r,
            s = m.top - c.top,
            n = s + f - l,
            a = {
              target: {
                element: v,
                left: m.left,
                top: m.top,
                width: p,
                height: f
              },
              element: {
                element: o,
                left: c.left,
                top: c.top,
                width: r,
                height: l
              },
              horizontal: i < 0 ? "left" : 0 < e ? "right" : "center",
              vertical: n < 0 ? "top" : 0 < s ? "bottom" : "middle"
            };
          p < r && k(e + i) < p && (a.horizontal = "center"), f < l && k(s + n) < f && (a.vertical = "middle"), C(k(e), k(i)) > C(k(s), k(n)) ? a.important = "horizontal" : a.important = "vertical", h.using.call(this, t, a)
        }), o.offset(x.extend(c, {
          using: t
        }))
      })
    }, x.ui.position = {
      fit: {
        left: function (t, e) {
          var i = e.within,
            s = i.isWindow ? i.scrollLeft : i.offset.left,
            n = i.width,
            a = t.left - e.collisionPosition.marginLeft,
            o = s - a,
            r = a + e.collisionWidth - n - s;
          e.collisionWidth > n ? 0 < o && r <= 0 ? (i = t.left + o + e.collisionWidth - n - s, t.left += o - i) : t.left = !(0 < r && o <= 0) && r < o ? s + n - e.collisionWidth : s : 0 < o ? t.left += o : 0 < r ? t.left -= r : t.left = C(t.left - a, t.left)
        },
        top: function (t, e) {
          var i = e.within,
            s = i.isWindow ? i.scrollTop : i.offset.top,
            n = e.within.height,
            a = t.top - e.collisionPosition.marginTop,
            o = s - a,
            r = a + e.collisionHeight - n - s;
          e.collisionHeight > n ? 0 < o && r <= 0 ? (i = t.top + o + e.collisionHeight - n - s, t.top += o - i) : t.top = !(0 < r && o <= 0) && r < o ? s + n - e.collisionHeight : s : 0 < o ? t.top += o : 0 < r ? t.top -= r : t.top = C(t.top - a, t.top)
        }
      },
      flip: {
        left: function (t, e) {
          var i = e.within,
            s = i.offset.left + i.scrollLeft,
            n = i.width,
            a = i.isWindow ? i.scrollLeft : i.offset.left,
            o = t.left - e.collisionPosition.marginLeft,
            r = o - a,
            l = o + e.collisionWidth - n - a,
            c = "left" === e.my[0] ? -e.elemWidth : "right" === e.my[0] ? e.elemWidth : 0,
            i = "left" === e.at[0] ? e.targetWidth : "right" === e.at[0] ? -e.targetWidth : 0,
            o = -2 * e.offset[0];
          r < 0 ? ((s = t.left + c + i + o + e.collisionWidth - n - s) < 0 || s < k(r)) && (t.left += c + i + o) : 0 < l && (0 < (a = t.left - e.collisionPosition.marginLeft + c + i + o - a) || k(a) < l) && (t.left += c + i + o)
        },
        top: function (t, e) {
          var i = e.within,
            s = i.offset.top + i.scrollTop,
            n = i.height,
            a = i.isWindow ? i.scrollTop : i.offset.top,
            o = t.top - e.collisionPosition.marginTop,
            r = o - a,
            l = o + e.collisionHeight - n - a,
            c = "top" === e.my[1] ? -e.elemHeight : "bottom" === e.my[1] ? e.elemHeight : 0,
            i = "top" === e.at[1] ? e.targetHeight : "bottom" === e.at[1] ? -e.targetHeight : 0,
            o = -2 * e.offset[1];
          r < 0 ? ((s = t.top + c + i + o + e.collisionHeight - n - s) < 0 || s < k(r)) && (t.top += c + i + o) : 0 < l && (0 < (a = t.top - e.collisionPosition.marginTop + c + i + o - a) || k(a) < l) && (t.top += c + i + o)
        }
      },
      flipfit: {
        left: function () {
          x.ui.position.flip.left.apply(this, arguments), x.ui.position.fit.left.apply(this, arguments)
        },
        top: function () {
          x.ui.position.flip.top.apply(this, arguments), x.ui.position.fit.top.apply(this, arguments)
        }
      }
    }, x.ui.position, x.extend(x.expr[":"], {
      data: x.expr.createPseudo ? x.expr.createPseudo(function (e) {
        return function (t) {
          return !!x.data(t, e)
        }
      }) : function (t, e, i) {
        return !!x.data(t, i[3])
      }
    }), x.fn.extend({
      disableSelection: (t = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown", function () {
        return this.on(t + ".ui-disableSelection", function (t) {
          t.preventDefault()
        })
      }),
      enableSelection: function () {
        return this.off(".ui-disableSelection")
      }
    });
    var t, u, e, p, f, m, g, v, b, _, y, w, S, M, E, A, P, I, O, $, L, N, H, F = "ui-effects-animated",
      z = x;

    function R(t, e, i, s) {
      return t = {
        effect: t = x.isPlainObject(t) ? (e = t).effect : t
      }, x.isFunction(e = null == e ? {} : e) && (s = e, i = null, e = {}), "number" != typeof e && !x.fx.speeds[e] || (s = i, i = e, e = {}), x.isFunction(i) && (s = i, i = null), e && x.extend(t, e), i = i || e.duration, t.duration = x.fx.off ? 0 : "number" == typeof i ? i : i in x.fx.speeds ? x.fx.speeds[i] : x.fx.speeds._default, t.complete = s || e.complete, t
    }

    function B(t) {
      return !t || "number" == typeof t || x.fx.speeds[t] || "string" == typeof t && !x.effects.effect[t] || x.isFunction(t) || "object" == typeof t && !t.effect
    }

    function j(t, e) {
      var i = e.outerWidth(),
        e = e.outerHeight(),
        t = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/.exec(t) || ["", 0, i, e, 0];
      return {
        top: parseFloat(t[1]) || 0,
        right: "auto" === t[2] ? i : parseFloat(t[2]),
        bottom: "auto" === t[3] ? e : parseFloat(t[3]),
        left: parseFloat(t[4]) || 0
      }
    }

    function W(t) {
      var e, i, s = t.ownerDocument.defaultView ? t.ownerDocument.defaultView.getComputedStyle(t, null) : t.currentStyle,
        n = {};
      if (s && s.length && s[0] && s[s[0]])
        for (i = s.length; i--;) "string" == typeof s[e = s[i]] && (n[x.camelCase(e)] = s[e]);
      else
        for (e in s) "string" == typeof s[e] && (n[e] = s[e]);
      return n
    }

    function V(t, e, i) {
      var s = I[e.type] || {};
      return null == t ? i || !e.def ? null : e.def : (t = s.floor ? ~~t : parseFloat(t), isNaN(t) ? e.def : s.mod ? (t + s.mod) % s.mod : t < 0 ? 0 : s.max < t ? s.max : t)
    }

    function q(s) {
      var n = A(),
        a = n._rgba = [];
      return s = s.toLowerCase(), L(E, function (t, e) {
        var i = e.re.exec(s),
          i = i && e.parse(i),
          e = e.space || "rgba";
        if (i) return i = n[e](i), n[P[e].cache] = i[P[e].cache], a = n._rgba = i._rgba, !1
      }), a.length ? ("0,0,0,0" === a.join() && w.extend(a, S.transparent), n) : S[s]
    }

    function Y(t, e, i) {
      return 6 * (i = (i + 1) % 1) < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t
    }
    x.effects = {
      effect: {}
    }, M = /^([\-+])=\s*(\d+\.?\d*)/, E = [{
      re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      parse: function (t) {
        return [t[1], t[2], t[3], t[4]]
      }
    }, {
      re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      parse: function (t) {
        return [2.55 * t[1], 2.55 * t[2], 2.55 * t[3], t[4]]
      }
    }, {
      re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
      parse: function (t) {
        return [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)]
      }
    }, {
      re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
      parse: function (t) {
        return [parseInt(t[1] + t[1], 16), parseInt(t[2] + t[2], 16), parseInt(t[3] + t[3], 16)]
      }
    }, {
      re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
      space: "hsla",
      parse: function (t) {
        return [t[1], t[2] / 100, t[3] / 100, t[4]]
      }
    }], A = (w = z).Color = function (t, e, i, s) {
      return new w.Color.fn.parse(t, e, i, s)
    }, P = {
      rgba: {
        props: {
          red: {
            idx: 0,
            type: "byte"
          },
          green: {
            idx: 1,
            type: "byte"
          },
          blue: {
            idx: 2,
            type: "byte"
          }
        }
      },
      hsla: {
        props: {
          hue: {
            idx: 0,
            type: "degrees"
          },
          saturation: {
            idx: 1,
            type: "percent"
          },
          lightness: {
            idx: 2,
            type: "percent"
          }
        }
      }
    }, I = {
      byte: {
        floor: !0,
        max: 255
      },
      percent: {
        max: 1
      },
      degrees: {
        mod: 360,
        floor: !0
      }
    }, O = A.support = {}, $ = w("<p>")[0], L = w.each, $.style.cssText = "background-color:rgba(1,1,1,.5)", O.rgba = -1 < $.style.backgroundColor.indexOf("rgba"), L(P, function (t, e) {
      e.cache = "_" + t, e.props.alpha = {
        idx: 3,
        type: "percent",
        def: 1
      }
    }), (A.fn = w.extend(A.prototype, {
      parse: function (n, t, e, i) {
        if (void 0 === n) return this._rgba = [null, null, null, null], this;
        (n.jquery || n.nodeType) && (n = w(n).css(t), t = void 0);
        var a = this,
          s = w.type(n),
          o = this._rgba = [];
        return void 0 !== t && (n = [n, t, e, i], s = "array"), "string" === s ? this.parse(q(n) || S._default) : "array" === s ? (L(P.rgba.props, function (t, e) {
          o[e.idx] = V(n[e.idx], e)
        }), this) : "object" === s ? (L(P, n instanceof A ? function (t, e) {
          n[e.cache] && (a[e.cache] = n[e.cache].slice())
        } : function (t, i) {
          var s = i.cache;
          L(i.props, function (t, e) {
            if (!a[s] && i.to) {
              if ("alpha" === t || null == n[t]) return;
              a[s] = i.to(a._rgba)
            }
            a[s][e.idx] = V(n[t], e, !0)
          }), a[s] && w.inArray(null, a[s].slice(0, 3)) < 0 && (a[s][3] = 1, i.from && (a._rgba = i.from(a[s])))
        }), this) : void 0
      },
      is: function (t) {
        var n = A(t),
          a = !0,
          o = this;
        return L(P, function (t, e) {
          var i, s = n[e.cache];
          return s && (i = o[e.cache] || e.to && e.to(o._rgba) || [], L(e.props, function (t, e) {
            if (null != s[e.idx]) return a = s[e.idx] === i[e.idx]
          })), a
        }), a
      },
      _space: function () {
        var i = [],
          s = this;
        return L(P, function (t, e) {
          s[e.cache] && i.push(t)
        }), i.pop()
      },
      transition: function (t, o) {
        var e = (c = A(t))._space(),
          i = P[e],
          t = 0 === this.alpha() ? A("transparent") : this,
          r = t[i.cache] || i.to(t._rgba),
          l = r.slice(),
          c = c[i.cache];
        return L(i.props, function (t, e) {
          var i = e.idx,
            s = r[i],
            n = c[i],
            a = I[e.type] || {};
          null !== n && (null === s ? l[i] = n : (a.mod && (n - s > a.mod / 2 ? s += a.mod : s - n > a.mod / 2 && (s -= a.mod)), l[i] = V((n - s) * o + s, e)))
        }), this[e](l)
      },
      blend: function (t) {
        if (1 === this._rgba[3]) return this;
        var e = this._rgba.slice(),
          i = e.pop(),
          s = A(t)._rgba;
        return A(w.map(e, function (t, e) {
          return (1 - i) * s[e] + i * t
        }))
      },
      toRgbaString: function () {
        var t = "rgba(",
          e = w.map(this._rgba, function (t, e) {
            return null == t ? 2 < e ? 1 : 0 : t
          });
        return 1 === e[3] && (e.pop(), t = "rgb("), t + e.join() + ")"
      },
      toHslaString: function () {
        var t = "hsla(",
          e = w.map(this.hsla(), function (t, e) {
            return null == t && (t = 2 < e ? 1 : 0), t = e && e < 3 ? Math.round(100 * t) + "%" : t
          });
        return 1 === e[3] && (e.pop(), t = "hsl("), t + e.join() + ")"
      },
      toHexString: function (t) {
        var e = this._rgba.slice(),
          i = e.pop();
        return t && e.push(~~(255 * i)), "#" + w.map(e, function (t) {
          return 1 === (t = (t || 0).toString(16)).length ? "0" + t : t
        }).join("")
      },
      toString: function () {
        return 0 === this._rgba[3] ? "transparent" : this.toRgbaString()
      }
    })).parse.prototype = A.fn, P.hsla.to = function (t) {
      if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]];
      var e = t[0] / 255,
        i = t[1] / 255,
        s = t[2] / 255,
        n = t[3],
        a = Math.max(e, i, s),
        o = Math.min(e, i, s),
        r = a - o,
        l = a + o,
        t = .5 * l,
        l = 0 == r ? 0 : t <= .5 ? r / l : r / (2 - l);
      return [Math.round(o === a ? 0 : e === a ? 60 * (i - s) / r + 360 : i === a ? 60 * (s - e) / r + 120 : 60 * (e - i) / r + 240) % 360, l, t, null == n ? 1 : n]
    }, P.hsla.from = function (t) {
      if (null == t[0] || null == t[1] || null == t[2]) return [null, null, null, t[3]];
      var e = t[0] / 360,
        i = t[1],
        s = t[2],
        t = t[3],
        i = s <= .5 ? s * (1 + i) : s + i - s * i,
        s = 2 * s - i;
      return [Math.round(255 * Y(s, i, e + 1 / 3)), Math.round(255 * Y(s, i, e)), Math.round(255 * Y(s, i, e - 1 / 3)), t]
    }, L(P, function (l, t) {
      var a = t.props,
        o = t.cache,
        r = t.to,
        c = t.from;
      A.fn[l] = function (t) {
        if (r && !this[o] && (this[o] = r(this._rgba)), void 0 === t) return this[o].slice();
        var e, i = w.type(t),
          s = "array" === i || "object" === i ? t : arguments,
          n = this[o].slice();
        return L(a, function (t, e) {
          t = s["object" === i ? t : e.idx];
          null == t && (t = n[e.idx]), n[e.idx] = V(t, e)
        }), c ? ((e = A(c(n)))[o] = n, e) : A(n)
      }, L(a, function (o, r) {
        A.fn[o] || (A.fn[o] = function (t) {
          var e, i = w.type(t),
            s = "alpha" === o ? this._hsla ? "hsla" : "rgba" : l,
            n = this[s](),
            a = n[r.idx];
          return "undefined" === i ? a : ("function" === i && (t = t.call(this, a), i = w.type(t)), null == t && r.empty ? this : ("string" === i && (e = M.exec(t)) && (t = a + parseFloat(e[2]) * ("+" === e[1] ? 1 : -1)), n[r.idx] = t, this[s](n)))
        })
      })
    }), (A.hook = function (t) {
      t = t.split(" ");
      L(t, function (t, a) {
        w.cssHooks[a] = {
          set: function (t, e) {
            var i, s, n = "";
            if ("transparent" !== e && ("string" !== w.type(e) || (i = q(e)))) {
              if (e = A(i || e), !O.rgba && 1 !== e._rgba[3]) {
                for (s = "backgroundColor" === a ? t.parentNode : t;
                  ("" === n || "transparent" === n) && s && s.style;) try {
                  n = w.css(s, "backgroundColor"), s = s.parentNode
                } catch (t) {}
                e = e.blend(n && "transparent" !== n ? n : "_default")
              }
              e = e.toRgbaString()
            }
            try {
              t.style[a] = e
            } catch (t) {}
          }
        }, w.fx.step[a] = function (t) {
          t.colorInit || (t.start = A(t.elem, a), t.end = A(t.end), t.colorInit = !0), w.cssHooks[a].set(t.elem, t.start.transition(t.end, t.pos))
        }
      })
    })("backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor"), w.cssHooks.borderColor = {
      expand: function (i) {
        var s = {};
        return L(["Top", "Right", "Bottom", "Left"], function (t, e) {
          s["border" + e + "Color"] = i
        }), s
      }
    }, S = w.Color.names = {
      aqua: "#00ffff",
      black: "#000000",
      blue: "#0000ff",
      fuchsia: "#ff00ff",
      gray: "#808080",
      green: "#008000",
      lime: "#00ff00",
      maroon: "#800000",
      navy: "#000080",
      olive: "#808000",
      purple: "#800080",
      red: "#ff0000",
      silver: "#c0c0c0",
      teal: "#008080",
      white: "#ffffff",
      yellow: "#ffff00",
      transparent: [null, null, null, 0],
      _default: "#ffffff"
    }, _ = ["add", "remove", "toggle"], y = {
      border: 1,
      borderBottom: 1,
      borderColor: 1,
      borderLeft: 1,
      borderRight: 1,
      borderTop: 1,
      borderWidth: 1,
      margin: 1,
      padding: 1
    }, x.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function (t, e) {
      x.fx.step[e] = function (t) {
        ("none" !== t.end && !t.setAttr || 1 === t.pos && !t.setAttr) && (z.style(t.elem, e, t.end), t.setAttr = !0)
      }
    }), x.fn.addBack || (x.fn.addBack = function (t) {
      return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
    }), x.effects.animateClass = function (n, t, e, i) {
      var a = x.speed(t, e, i);
      return this.queue(function () {
        var t, i = x(this),
          e = i.attr("class") || "",
          s = (s = a.children ? i.find("*").addBack() : i).map(function () {
            return {
              el: x(this),
              start: W(this)
            }
          });
        (t = function () {
          x.each(_, function (t, e) {
            n[e] && i[e + "Class"](n[e])
          })
        })(), s = s.map(function () {
          return this.end = W(this.el[0]), this.diff = function (t, e) {
            var i, s, n = {};
            for (i in e) s = e[i], t[i] !== s && (y[i] || !x.fx.step[i] && isNaN(parseFloat(s)) || (n[i] = s));
            return n
          }(this.start, this.end), this
        }), i.attr("class", e), s = s.map(function () {
          var t = this,
            e = x.Deferred(),
            i = x.extend({}, a, {
              queue: !1,
              complete: function () {
                e.resolve(t)
              }
            });
          return this.el.animate(this.diff, i), e.promise()
        }), x.when.apply(x, s.get()).done(function () {
          t(), x.each(arguments, function () {
            var e = this.el;
            x.each(this.diff, function (t) {
              e.css(t, "")
            })
          }), a.complete.call(i[0])
        })
      })
    }, x.fn.extend({
      addClass: (g = x.fn.addClass, function (t, e, i, s) {
        return e ? x.effects.animateClass.call(this, {
          add: t
        }, e, i, s) : g.apply(this, arguments)
      }),
      removeClass: (b = x.fn.removeClass, function (t, e, i, s) {
        return 1 < arguments.length ? x.effects.animateClass.call(this, {
          remove: t
        }, e, i, s) : b.apply(this, arguments)
      }),
      toggleClass: (v = x.fn.toggleClass, function (t, e, i, s, n) {
        return "boolean" == typeof e || void 0 === e ? i ? x.effects.animateClass.call(this, e ? {
          add: t
        } : {
          remove: t
        }, i, s, n) : v.apply(this, arguments) : x.effects.animateClass.call(this, {
          toggle: t
        }, e, i, s)
      }),
      switchClass: function (t, e, i, s, n) {
        return x.effects.animateClass.call(this, {
          add: e,
          remove: t
        }, i, s, n)
      }
    }), x.expr && x.expr.filters && x.expr.filters.animated && (x.expr.filters.animated = (e = x.expr.filters.animated, function (t) {
      return !!x(t).data(F) || e(t)
    })), !1 !== x.uiBackCompat && x.extend(x.effects, {
      save: function (t, e) {
        for (var i = 0, s = e.length; i < s; i++) null !== e[i] && t.data("ui-effects-" + e[i], t[0].style[e[i]])
      },
      restore: function (t, e) {
        for (var i, s = 0, n = e.length; s < n; s++) null !== e[s] && (i = t.data("ui-effects-" + e[s]), t.css(e[s], i))
      },
      setMode: function (t, e) {
        return e = "toggle" === e ? t.is(":hidden") ? "show" : "hide" : e
      },
      createWrapper: function (i) {
        if (i.parent().is(".ui-effects-wrapper")) return i.parent();
        var s = {
            width: i.outerWidth(!0),
            height: i.outerHeight(!0),
            float: i.css("float")
          },
          t = x("<div></div>").addClass("ui-effects-wrapper").css({
            fontSize: "100%",
            background: "transparent",
            border: "none",
            margin: 0,
            padding: 0
          }),
          e = {
            width: i.width(),
            height: i.height()
          },
          n = document.activeElement;
        try {
          n.id
        } catch (t) {
          n = document.body
        }
        return i.wrap(t), i[0] !== n && !x.contains(i[0], n) || x(n).trigger("focus"), t = i.parent(), "static" === i.css("position") ? (t.css({
          position: "relative"
        }), i.css({
          position: "relative"
        })) : (x.extend(s, {
          position: i.css("position"),
          zIndex: i.css("z-index")
        }), x.each(["top", "left", "bottom", "right"], function (t, e) {
          s[e] = i.css(e), isNaN(parseInt(s[e], 10)) && (s[e] = "auto")
        }), i.css({
          position: "relative",
          top: 0,
          left: 0,
          right: "auto",
          bottom: "auto"
        })), i.css(e), t.css(s).show()
      },
      removeWrapper: function (t) {
        var e = document.activeElement;
        return t.parent().is(".ui-effects-wrapper") && (t.parent().replaceWith(t), t[0] !== e && !x.contains(t[0], e) || x(e).trigger("focus")), t
      }
    }), x.extend(x.effects, {
      version: "1.12.1",
      define: function (t, e, i) {
        return i || (i = e, e = "effect"), x.effects.effect[t] = i, x.effects.effect[t].mode = e, i
      },
      scaledDimensions: function (t, e, i) {
        if (0 === e) return {
          height: 0,
          width: 0,
          outerHeight: 0,
          outerWidth: 0
        };
        var s = "horizontal" !== i ? (e || 100) / 100 : 1,
          e = "vertical" !== i ? (e || 100) / 100 : 1;
        return {
          height: t.height() * e,
          width: t.width() * s,
          outerHeight: t.outerHeight() * e,
          outerWidth: t.outerWidth() * s
        }
      },
      clipToBox: function (t) {
        return {
          width: t.clip.right - t.clip.left,
          height: t.clip.bottom - t.clip.top,
          left: t.clip.left,
          top: t.clip.top
        }
      },
      unshift: function (t, e, i) {
        var s = t.queue();
        1 < e && s.splice.apply(s, [1, 0].concat(s.splice(e, i))), t.dequeue()
      },
      saveStyle: function (t) {
        t.data("ui-effects-style", t[0].style.cssText)
      },
      restoreStyle: function (t) {
        t[0].style.cssText = t.data("ui-effects-style") || "", t.removeData("ui-effects-style")
      },
      mode: function (t, e) {
        t = t.is(":hidden");
        return "toggle" === e && (e = t ? "show" : "hide"), e = (t ? "hide" === e : "show" === e) ? "none" : e
      },
      getBaseline: function (t, e) {
        var i, s;
        switch (t[0]) {
          case "top":
            i = 0;
            break;
          case "middle":
            i = .5;
            break;
          case "bottom":
            i = 1;
            break;
          default:
            i = t[0] / e.height
        }
        switch (t[1]) {
          case "left":
            s = 0;
            break;
          case "center":
            s = .5;
            break;
          case "right":
            s = 1;
            break;
          default:
            s = t[1] / e.width
        }
        return {
          x: s,
          y: i
        }
      },
      createPlaceholder: function (t) {
        var e, i = t.css("position"),
          s = t.position();
        return t.css({
          marginTop: t.css("marginTop"),
          marginBottom: t.css("marginBottom"),
          marginLeft: t.css("marginLeft"),
          marginRight: t.css("marginRight")
        }).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()), /^(static|relative)/.test(i) && (i = "absolute", e = x("<" + t[0].nodeName + ">").insertAfter(t).css({
          display: /^(inline|ruby)/.test(t.css("display")) ? "inline-block" : "block",
          visibility: "hidden",
          marginTop: t.css("marginTop"),
          marginBottom: t.css("marginBottom"),
          marginLeft: t.css("marginLeft"),
          marginRight: t.css("marginRight"),
          float: t.css("float")
        }).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).addClass("ui-effects-placeholder"), t.data("ui-effects-placeholder", e)), t.css({
          position: i,
          left: s.left,
          top: s.top
        }), e
      },
      removePlaceholder: function (t) {
        var e = "ui-effects-placeholder",
          i = t.data(e);
        i && (i.remove(), t.removeData(e))
      },
      cleanUp: function (t) {
        x.effects.restoreStyle(t), x.effects.removePlaceholder(t)
      },
      setTransition: function (s, t, n, a) {
        return a = a || {}, x.each(t, function (t, e) {
          var i = s.cssUnit(e);
          0 < i[0] && (a[e] = i[0] * n + i[1])
        }), a
      }
    }), x.fn.extend({
      effect: function () {
        function t(t) {
          var e = x(this),
            i = x.effects.mode(e, r) || a;
          e.data(F, !0), l.push(i), a && ("show" === i || i === a && "hide" === i) && e.show(), a && "none" === i || x.effects.saveStyle(e), x.isFunction(t) && t()
        }
        var s = R.apply(this, arguments),
          n = x.effects.effect[s.effect],
          a = n.mode,
          e = s.queue,
          i = e || "fx",
          o = s.complete,
          r = s.mode,
          l = [];
        return x.fx.off || !n ? r ? this[r](s.duration, o) : this.each(function () {
          o && o.call(this)
        }) : !1 === e ? this.each(t).each(c) : this.queue(i, t).queue(i, c);

        function c(t) {
          var e = x(this);

          function i() {
            x.isFunction(o) && o.call(e[0]), x.isFunction(t) && t()
          }
          s.mode = l.shift(), !1 === x.uiBackCompat || a ? "none" === s.mode ? (e[r](), i()) : n.call(e[0], s, function () {
            e.removeData(F), x.effects.cleanUp(e), "hide" === s.mode && e.hide(), i()
          }) : (e.is(":hidden") ? "hide" === r : "show" === r) ? (e[r](), i()) : n.call(e[0], s, i)
        }
      },
      show: (m = x.fn.show, function (t) {
        if (B(t)) return m.apply(this, arguments);
        var e = R.apply(this, arguments);
        return e.mode = "show", this.effect.call(this, e)
      }),
      hide: (f = x.fn.hide, function (t) {
        if (B(t)) return f.apply(this, arguments);
        var e = R.apply(this, arguments);
        return e.mode = "hide", this.effect.call(this, e)
      }),
      toggle: (p = x.fn.toggle, function (t) {
        if (B(t) || "boolean" == typeof t) return p.apply(this, arguments);
        var e = R.apply(this, arguments);
        return e.mode = "toggle", this.effect.call(this, e)
      }),
      cssUnit: function (t) {
        var i = this.css(t),
          s = [];
        return x.each(["em", "px", "%", "pt"], function (t, e) {
          0 < i.indexOf(e) && (s = [parseFloat(i), e])
        }), s
      },
      cssClip: function (t) {
        return t ? this.css("clip", "rect(" + t.top + "px " + t.right + "px " + t.bottom + "px " + t.left + "px)") : j(this.css("clip"), this)
      },
      transfer: function (t, e) {
        var i = x(this),
          s = x(t.to),
          n = "fixed" === s.css("position"),
          a = x("body"),
          o = n ? a.scrollTop() : 0,
          r = n ? a.scrollLeft() : 0,
          a = s.offset(),
          a = {
            top: a.top - o,
            left: a.left - r,
            height: s.innerHeight(),
            width: s.innerWidth()
          },
          s = i.offset(),
          l = x("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(t.className).css({
            top: s.top - o,
            left: s.left - r,
            height: i.innerHeight(),
            width: i.innerWidth(),
            position: n ? "fixed" : "absolute"
          }).animate(a, t.duration, t.easing, function () {
            l.remove(), x.isFunction(e) && e()
          })
      }
    }), x.fx.step.clip = function (t) {
      t.clipInit || (t.start = x(t.elem).cssClip(), "string" == typeof t.end && (t.end = j(t.end, t.elem)), t.clipInit = !0), x(t.elem).cssClip({
        top: t.pos * (t.end.top - t.start.top) + t.start.top,
        right: t.pos * (t.end.right - t.start.right) + t.start.right,
        bottom: t.pos * (t.end.bottom - t.start.bottom) + t.start.bottom,
        left: t.pos * (t.end.left - t.start.left) + t.start.left
      })
    }, u = {}, x.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function (e, t) {
      u[t] = function (t) {
        return Math.pow(t, e + 2)
      }
    }), x.extend(u, {
      Sine: function (t) {
        return 1 - Math.cos(t * Math.PI / 2)
      },
      Circ: function (t) {
        return 1 - Math.sqrt(1 - t * t)
      },
      Elastic: function (t) {
        return 0 === t || 1 === t ? t : -Math.pow(2, 8 * (t - 1)) * Math.sin((80 * (t - 1) - 7.5) * Math.PI / 15)
      },
      Back: function (t) {
        return t * t * (3 * t - 2)
      },
      Bounce: function (t) {
        for (var e, i = 4; t < ((e = Math.pow(2, --i)) - 1) / 11;);
        return 1 / Math.pow(4, 3 - i) - 7.5625 * Math.pow((3 * e - 2) / 22 - t, 2)
      }
    }), x.each(u, function (t, e) {
      x.easing["easeIn" + t] = e, x.easing["easeOut" + t] = function (t) {
        return 1 - e(1 - t)
      }, x.easing["easeInOut" + t] = function (t) {
        return t < .5 ? e(2 * t) / 2 : 1 - e(-2 * t + 2) / 2
      }
    }), x.effects, x.effects.define("blind", "hide", function (t, e) {
      var i = {
          up: ["bottom", "top"],
          vertical: ["bottom", "top"],
          down: ["top", "bottom"],
          left: ["right", "left"],
          horizontal: ["right", "left"],
          right: ["left", "right"]
        },
        s = x(this),
        n = t.direction || "up",
        a = s.cssClip(),
        o = {
          clip: x.extend({}, a)
        },
        r = x.effects.createPlaceholder(s);
      o.clip[i[n][0]] = o.clip[i[n][1]], "show" === t.mode && (s.cssClip(o.clip), r && r.css(x.effects.clipToBox(o)), o.clip = a), r && r.animate(x.effects.clipToBox(o), t.duration, t.easing), s.animate(o, {
        queue: !1,
        duration: t.duration,
        easing: t.easing,
        complete: e
      })
    }), x.effects.define("bounce", function (t, e) {
      var i, s, n = x(this),
        a = t.mode,
        o = "hide" === a,
        r = "show" === a,
        l = t.direction || "up",
        c = t.distance,
        d = t.times || 5,
        a = 2 * d + (r || o ? 1 : 0),
        h = t.duration / a,
        u = t.easing,
        p = "up" === l || "down" === l ? "top" : "left",
        f = "up" === l || "left" === l,
        m = 0,
        t = n.queue().length;
      for (x.effects.createPlaceholder(n), l = n.css(p), c = c || n["top" == p ? "outerHeight" : "outerWidth"]() / 3, r && ((s = {
          opacity: 1
        })[p] = l, n.css("opacity", 0).css(p, f ? 2 * -c : 2 * c).animate(s, h, u)), o && (c /= Math.pow(2, d - 1)), (s = {})[p] = l; m < d; m++)(i = {})[p] = (f ? "-=" : "+=") + c, n.animate(i, h, u).animate(s, h, u), c = o ? 2 * c : c / 2;
      o && ((i = {
        opacity: 0
      })[p] = (f ? "-=" : "+=") + c, n.animate(i, h, u)), n.queue(e), x.effects.unshift(n, t, 1 + a)
    }), x.effects.define("clip", "hide", function (t, e) {
      var i = {},
        s = x(this),
        n = t.direction || "vertical",
        a = "both" === n,
        o = a || "horizontal" === n,
        a = a || "vertical" === n,
        n = s.cssClip();
      i.clip = {
        top: a ? (n.bottom - n.top) / 2 : n.top,
        right: o ? (n.right - n.left) / 2 : n.right,
        bottom: a ? (n.bottom - n.top) / 2 : n.bottom,
        left: o ? (n.right - n.left) / 2 : n.left
      }, x.effects.createPlaceholder(s), "show" === t.mode && (s.cssClip(i.clip), i.clip = n), s.animate(i, {
        queue: !1,
        duration: t.duration,
        easing: t.easing,
        complete: e
      })
    }), x.effects.define("drop", "hide", function (t, e) {
      var i = x(this),
        s = "show" === t.mode,
        n = t.direction || "left",
        a = "up" === n || "down" === n ? "top" : "left",
        o = "up" === n || "left" === n ? "-=" : "+=",
        r = "+=" == o ? "-=" : "+=",
        l = {
          opacity: 0
        };
      x.effects.createPlaceholder(i), n = t.distance || i["top" == a ? "outerHeight" : "outerWidth"](!0) / 2, l[a] = o + n, s && (i.css(l), l[a] = r + n, l.opacity = 1), i.animate(l, {
        queue: !1,
        duration: t.duration,
        easing: t.easing,
        complete: e
      })
    }), x.effects.define("explode", "hide", function (t, e) {
      var i, s, n, a, o, r, l = t.pieces ? Math.round(Math.sqrt(t.pieces)) : 3,
        c = l,
        d = x(this),
        h = "show" === t.mode,
        u = d.show().css("visibility", "hidden").offset(),
        p = Math.ceil(d.outerWidth() / c),
        f = Math.ceil(d.outerHeight() / l),
        m = [];

      function g() {
        m.push(this), m.length === l * c && (d.css({
          visibility: "visible"
        }), x(m).remove(), e())
      }
      for (i = 0; i < l; i++)
        for (a = u.top + i * f, r = i - (l - 1) / 2, s = 0; s < c; s++) n = u.left + s * p, o = s - (c - 1) / 2, d.clone().appendTo("body").wrap("<div></div>").css({
          position: "absolute",
          visibility: "visible",
          left: -s * p,
          top: -i * f
        }).parent().addClass("ui-effects-explode").css({
          position: "absolute",
          overflow: "hidden",
          width: p,
          height: f,
          left: n + (h ? o * p : 0),
          top: a + (h ? r * f : 0),
          opacity: h ? 0 : 1
        }).animate({
          left: n + (h ? 0 : o * p),
          top: a + (h ? 0 : r * f),
          opacity: h ? 1 : 0
        }, t.duration || 500, t.easing, g)
    }), x.effects.define("fade", "toggle", function (t, e) {
      var i = "show" === t.mode;
      x(this).css("opacity", i ? 0 : 1).animate({
        opacity: i ? 1 : 0
      }, {
        queue: !1,
        duration: t.duration,
        easing: t.easing,
        complete: e
      })
    }), x.effects.define("fold", "hide", function (e, t) {
      var i = x(this),
        s = e.mode,
        n = "show" === s,
        a = "hide" === s,
        o = e.size || 15,
        r = /([0-9]+)%/.exec(o),
        l = e.horizFirst ? ["right", "bottom"] : ["bottom", "right"],
        c = e.duration / 2,
        d = x.effects.createPlaceholder(i),
        h = i.cssClip(),
        u = {
          clip: x.extend({}, h)
        },
        p = {
          clip: x.extend({}, h)
        },
        f = [h[l[0]], h[l[1]]],
        s = i.queue().length;
      r && (o = parseInt(r[1], 10) / 100 * f[a ? 0 : 1]), u.clip[l[0]] = o, p.clip[l[0]] = o, p.clip[l[1]] = 0, n && (i.cssClip(p.clip), d && d.css(x.effects.clipToBox(p)), p.clip = h), i.queue(function (t) {
        d && d.animate(x.effects.clipToBox(u), c, e.easing).animate(x.effects.clipToBox(p), c, e.easing), t()
      }).animate(u, c, e.easing).animate(p, c, e.easing).queue(t), x.effects.unshift(i, s, 4)
    }), x.effects.define("highlight", "show", function (t, e) {
      var i = x(this),
        s = {
          backgroundColor: i.css("backgroundColor")
        };
      "hide" === t.mode && (s.opacity = 0), x.effects.saveStyle(i), i.css({
        backgroundImage: "none",
        backgroundColor: t.color || "#ffff99"
      }).animate(s, {
        queue: !1,
        duration: t.duration,
        easing: t.easing,
        complete: e
      })
    }), x.effects.define("size", function (s, e) {
      var n, i = x(this),
        t = ["fontSize"],
        a = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
        o = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
        r = s.mode,
        l = "effect" !== r,
        c = s.scale || "both",
        d = s.origin || ["middle", "center"],
        h = i.css("position"),
        u = i.position(),
        p = x.effects.scaledDimensions(i),
        f = s.from || p,
        m = s.to || x.effects.scaledDimensions(i, 0);
      x.effects.createPlaceholder(i), "show" === r && (r = f, f = m, m = r), n = {
        from: {
          y: f.height / p.height,
          x: f.width / p.width
        },
        to: {
          y: m.height / p.height,
          x: m.width / p.width
        }
      }, "box" !== c && "both" !== c || (n.from.y !== n.to.y && (f = x.effects.setTransition(i, a, n.from.y, f), m = x.effects.setTransition(i, a, n.to.y, m)), n.from.x !== n.to.x && (f = x.effects.setTransition(i, o, n.from.x, f), m = x.effects.setTransition(i, o, n.to.x, m))), "content" !== c && "both" !== c || n.from.y !== n.to.y && (f = x.effects.setTransition(i, t, n.from.y, f), m = x.effects.setTransition(i, t, n.to.y, m)), d && (d = x.effects.getBaseline(d, p), f.top = (p.outerHeight - f.outerHeight) * d.y + u.top, f.left = (p.outerWidth - f.outerWidth) * d.x + u.left, m.top = (p.outerHeight - m.outerHeight) * d.y + u.top, m.left = (p.outerWidth - m.outerWidth) * d.x + u.left), i.css(f), "content" !== c && "both" !== c || (a = a.concat(["marginTop", "marginBottom"]).concat(t), o = o.concat(["marginLeft", "marginRight"]), i.find("*[width]").each(function () {
        var t = x(this),
          e = x.effects.scaledDimensions(t),
          i = {
            height: e.height * n.from.y,
            width: e.width * n.from.x,
            outerHeight: e.outerHeight * n.from.y,
            outerWidth: e.outerWidth * n.from.x
          },
          e = {
            height: e.height * n.to.y,
            width: e.width * n.to.x,
            outerHeight: e.height * n.to.y,
            outerWidth: e.width * n.to.x
          };
        n.from.y !== n.to.y && (i = x.effects.setTransition(t, a, n.from.y, i), e = x.effects.setTransition(t, a, n.to.y, e)), n.from.x !== n.to.x && (i = x.effects.setTransition(t, o, n.from.x, i), e = x.effects.setTransition(t, o, n.to.x, e)), l && x.effects.saveStyle(t), t.css(i), t.animate(e, s.duration, s.easing, function () {
          l && x.effects.restoreStyle(t)
        })
      })), i.animate(m, {
        queue: !1,
        duration: s.duration,
        easing: s.easing,
        complete: function () {
          var t = i.offset();
          0 === m.opacity && i.css("opacity", f.opacity), l || (i.css("position", "static" === h ? "relative" : h).offset(t), x.effects.saveStyle(i)), e()
        }
      })
    }), x.effects.define("scale", function (t, e) {
      var i = x(this),
        s = t.mode,
        s = parseInt(t.percent, 10) || (0 === parseInt(t.percent, 10) || "effect" !== s ? 0 : 100),
        s = x.extend(!0, {
          from: x.effects.scaledDimensions(i),
          to: x.effects.scaledDimensions(i, s, t.direction || "both"),
          origin: t.origin || ["middle", "center"]
        }, t);
      t.fade && (s.from.opacity = 1, s.to.opacity = 0), x.effects.effect.size.call(this, s, e)
    }), x.effects.define("puff", "hide", function (t, e) {
      t = x.extend(!0, {}, t, {
        fade: !0,
        percent: parseInt(t.percent, 10) || 150
      });
      x.effects.effect.scale.call(this, t, e)
    }), x.effects.define("pulsate", "show", function (t, e) {
      var i = x(this),
        s = t.mode,
        n = "show" === s,
        a = 2 * (t.times || 5) + (n || "hide" === s ? 1 : 0),
        o = t.duration / a,
        r = 0,
        l = 1,
        s = i.queue().length;
      for (!n && i.is(":visible") || (i.css("opacity", 0).show(), r = 1); l < a; l++) i.animate({
        opacity: r
      }, o, t.easing), r = 1 - r;
      i.animate({
        opacity: r
      }, o, t.easing), i.queue(e), x.effects.unshift(i, s, 1 + a)
    }), x.effects.define("shake", function (t, e) {
      var i = 1,
        s = x(this),
        n = t.direction || "left",
        a = t.distance || 20,
        o = t.times || 3,
        r = 2 * o + 1,
        l = Math.round(t.duration / r),
        c = "up" === n || "down" === n ? "top" : "left",
        d = "up" === n || "left" === n,
        h = {},
        u = {},
        p = {},
        n = s.queue().length;
      for (x.effects.createPlaceholder(s), h[c] = (d ? "-=" : "+=") + a, u[c] = (d ? "+=" : "-=") + 2 * a, p[c] = (d ? "-=" : "+=") + 2 * a, s.animate(h, l, t.easing); i < o; i++) s.animate(u, l, t.easing).animate(p, l, t.easing);
      s.animate(u, l, t.easing).animate(h, l / 2, t.easing).queue(e), x.effects.unshift(s, n, 1 + r)
    }), x.effects.define("slide", "show", function (t, e) {
      var i, s, n = x(this),
        a = {
          up: ["bottom", "top"],
          down: ["top", "bottom"],
          left: ["right", "left"],
          right: ["left", "right"]
        },
        o = t.mode,
        r = t.direction || "left",
        l = "up" === r || "down" === r ? "top" : "left",
        c = "up" === r || "left" === r,
        d = t.distance || n["top" == l ? "outerHeight" : "outerWidth"](!0),
        h = {};
      x.effects.createPlaceholder(n), i = n.cssClip(), s = n.position()[l], h[l] = (c ? -1 : 1) * d + s, h.clip = n.cssClip(), h.clip[a[r][1]] = h.clip[a[r][0]], "show" === o && (n.cssClip(h.clip), n.css(l, h[l]), h.clip = i, h[l] = s), n.animate(h, {
        queue: !1,
        duration: t.duration,
        easing: t.easing,
        complete: e
      })
    }), !1 !== x.uiBackCompat && x.effects.define("transfer", function (t, e) {
      x(this).transfer(t, e)
    }), x.ui.focusable = function (t, e) {
      var i, s, n, a, o, r = t.nodeName.toLowerCase();
      return "area" === r ? (s = (i = t.parentNode).name, !(!t.href || !s || "map" !== i.nodeName.toLowerCase()) && 0 < (n = x("img[usemap='#" + s + "']")).length && n.is(":visible")) : (/^(input|select|textarea|button|object)$/.test(r) ? (a = !t.disabled) && (o = x(t).closest("fieldset")[0]) && (a = !o.disabled) : a = "a" === r && t.href || e, a && x(t).is(":visible") && function (t) {
        for (var e = t.css("visibility");
          "inherit" === e;) e = (t = t.parent()).css("visibility");
        return "hidden" !== e
      }(x(t)))
    }, x.extend(x.expr[":"], {
      focusable: function (t) {
        return x.ui.focusable(t, null != x.attr(t, "tabindex"))
      }
    }), x.ui.focusable, x.fn.form = function () {
      return "string" == typeof this[0].form ? this.closest("form") : x(this[0].form)
    }, x.ui.formResetMixin = {
      _formResetHandler: function () {
        var e = x(this);
        setTimeout(function () {
          var t = e.data("ui-form-reset-instances");
          x.each(t, function () {
            this.refresh()
          })
        })
      },
      _bindFormResetHandler: function () {
        var t;
        this.form = this.element.form(), this.form.length && ((t = this.form.data("ui-form-reset-instances") || []).length || this.form.on("reset.ui-form-reset", this._formResetHandler), t.push(this), this.form.data("ui-form-reset-instances", t))
      },
      _unbindFormResetHandler: function () {
        var t;
        this.form.length && ((t = this.form.data("ui-form-reset-instances")).splice(x.inArray(this, t), 1), t.length ? this.form.data("ui-form-reset-instances", t) : this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset"))
      }
    }, "1.7" === x.fn.jquery.substring(0, 3) && (x.each(["Width", "Height"], function (t, i) {
      var n = "Width" === i ? ["Left", "Right"] : ["Top", "Bottom"],
        s = i.toLowerCase(),
        a = {
          innerWidth: x.fn.innerWidth,
          innerHeight: x.fn.innerHeight,
          outerWidth: x.fn.outerWidth,
          outerHeight: x.fn.outerHeight
        };

      function o(t, e, i, s) {
        return x.each(n, function () {
          e -= parseFloat(x.css(t, "padding" + this)) || 0, i && (e -= parseFloat(x.css(t, "border" + this + "Width")) || 0), s && (e -= parseFloat(x.css(t, "margin" + this)) || 0)
        }), e
      }
      x.fn["inner" + i] = function (t) {
        return void 0 === t ? a["inner" + i].call(this) : this.each(function () {
          x(this).css(s, o(this, t) + "px")
        })
      }, x.fn["outer" + i] = function (t, e) {
        return "number" != typeof t ? a["outer" + i].call(this, t) : this.each(function () {
          x(this).css(s, o(this, t, !0, e) + "px")
        })
      }
    }), x.fn.addBack = function (t) {
      return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
    }), x.ui.keyCode = {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    }, x.ui.escapeSelector = (N = /([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g, function (t) {
      return t.replace(N, "\\$1")
    }), x.fn.labels = function () {
      var t, e, i;
      return this[0].labels && this[0].labels.length ? this.pushStack(this[0].labels) : (e = this.eq(0).parents("label"), (t = this.attr("id")) && (i = (i = this.eq(0).parents().last()).add((i.length ? i : this).siblings()), t = "label[for='" + x.ui.escapeSelector(t) + "']", e = e.add(i.find(t).addBack(t))), this.pushStack(e))
    }, x.fn.scrollParent = function (t) {
      var e = this.css("position"),
        i = "absolute" === e,
        s = t ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
        t = this.parents().filter(function () {
          var t = x(this);
          return (!i || "static" !== t.css("position")) && s.test(t.css("overflow") + t.css("overflow-y") + t.css("overflow-x"))
        }).eq(0);
      return "fixed" !== e && t.length ? t : x(this[0].ownerDocument || document)
    }, x.extend(x.expr[":"], {
      tabbable: function (t) {
        var e = x.attr(t, "tabindex"),
          i = null != e;
        return (!i || 0 <= e) && x.ui.focusable(t, i)
      }
    }), x.fn.extend({
      uniqueId: (H = 0, function () {
        return this.each(function () {
          this.id || (this.id = "ui-id-" + ++H)
        })
      }),
      removeUniqueId: function () {
        return this.each(function () {
          /^ui-id-\d+$/.test(this.id) && x(this).removeAttr("id")
        })
      }
    }), x.widget("ui.accordion", {
      version: "1.12.1",
      options: {
        active: 0,
        animate: {},
        classes: {
          "ui-accordion-header": "ui-corner-top",
          "ui-accordion-header-collapsed": "ui-corner-all",
          "ui-accordion-content": "ui-corner-bottom"
        },
        collapsible: !1,
        event: "click",
        header: "> li > :first-child, > :not(li):even",
        heightStyle: "auto",
        icons: {
          activeHeader: "ui-icon-triangle-1-s",
          header: "ui-icon-triangle-1-e"
        },
        activate: null,
        beforeActivate: null
      },
      hideProps: {
        borderTopWidth: "hide",
        borderBottomWidth: "hide",
        paddingTop: "hide",
        paddingBottom: "hide",
        height: "hide"
      },
      showProps: {
        borderTopWidth: "show",
        borderBottomWidth: "show",
        paddingTop: "show",
        paddingBottom: "show",
        height: "show"
      },
      _create: function () {
        var t = this.options;
        this.prevShow = this.prevHide = x(), this._addClass("ui-accordion", "ui-widget ui-helper-reset"), this.element.attr("role", "tablist"), t.collapsible || !1 !== t.active && null != t.active || (t.active = 0), this._processPanels(), t.active < 0 && (t.active += this.headers.length), this._refresh()
      },
      _getCreateEventData: function () {
        return {
          header: this.active,
          panel: this.active.length ? this.active.next() : x()
        }
      },
      _createIcons: function () {
        var t, e = this.options.icons;
        e && (t = x("<span>"), this._addClass(t, "ui-accordion-header-icon", "ui-icon " + e.header), t.prependTo(this.headers), t = this.active.children(".ui-accordion-header-icon"), this._removeClass(t, e.header)._addClass(t, null, e.activeHeader)._addClass(this.headers, "ui-accordion-icons"))
      },
      _destroyIcons: function () {
        this._removeClass(this.headers, "ui-accordion-icons"), this.headers.children(".ui-accordion-header-icon").remove()
      },
      _destroy: function () {
        var t;
        this.element.removeAttr("role"), this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(), this._destroyIcons(), t = this.headers.next().css("display", "").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(), "content" !== this.options.heightStyle && t.css("height", "")
      },
      _setOption: function (t, e) {
        "active" !== t ? ("event" === t && (this.options.event && this._off(this.headers, this.options.event), this._setupEvents(e)), this._super(t, e), "collapsible" !== t || e || !1 !== this.options.active || this._activate(0), "icons" === t && (this._destroyIcons(), e && this._createIcons())) : this._activate(e)
      },
      _setOptionDisabled: function (t) {
        this._super(t), this.element.attr("aria-disabled", t), this._toggleClass(null, "ui-state-disabled", !!t), this._toggleClass(this.headers.add(this.headers.next()), null, "ui-state-disabled", !!t)
      },
      _keydown: function (t) {
        if (!t.altKey && !t.ctrlKey) {
          var e = x.ui.keyCode,
            i = this.headers.length,
            s = this.headers.index(t.target),
            n = !1;
          switch (t.keyCode) {
            case e.RIGHT:
            case e.DOWN:
              n = this.headers[(s + 1) % i];
              break;
            case e.LEFT:
            case e.UP:
              n = this.headers[(s - 1 + i) % i];
              break;
            case e.SPACE:
            case e.ENTER:
              this._eventHandler(t);
              break;
            case e.HOME:
              n = this.headers[0];
              break;
            case e.END:
              n = this.headers[i - 1]
          }
          n && (x(t.target).attr("tabIndex", -1), x(n).attr("tabIndex", 0), x(n).trigger("focus"), t.preventDefault())
        }
      },
      _panelKeyDown: function (t) {
        t.keyCode === x.ui.keyCode.UP && t.ctrlKey && x(t.currentTarget).prev().trigger("focus")
      },
      refresh: function () {
        var t = this.options;
        this._processPanels(), !1 === t.active && !0 === t.collapsible || !this.headers.length ? (t.active = !1, this.active = x()) : !1 === t.active ? this._activate(0) : this.active.length && !x.contains(this.element[0], this.active[0]) ? this.headers.length === this.headers.find(".ui-state-disabled").length ? (t.active = !1, this.active = x()) : this._activate(Math.max(0, t.active - 1)) : t.active = this.headers.index(this.active), this._destroyIcons(), this._refresh()
      },
      _processPanels: function () {
        var t = this.headers,
          e = this.panels;
        this.headers = this.element.find(this.options.header), this._addClass(this.headers, "ui-accordion-header ui-accordion-header-collapsed", "ui-state-default"), this.panels = this.headers.next().filter(":not(.ui-accordion-content-active)").hide(), this._addClass(this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content"), e && (this._off(t.not(this.headers)), this._off(e.not(this.panels)))
      },
      _refresh: function () {
        var i, t = this.options,
          e = t.heightStyle,
          s = this.element.parent();
        this.active = this._findActive(t.active), this._addClass(this.active, "ui-accordion-header-active", "ui-state-active")._removeClass(this.active, "ui-accordion-header-collapsed"), this._addClass(this.active.next(), "ui-accordion-content-active"), this.active.next().show(), this.headers.attr("role", "tab").each(function () {
          var t = x(this),
            e = t.uniqueId().attr("id"),
            i = t.next(),
            s = i.uniqueId().attr("id");
          t.attr("aria-controls", s), i.attr("aria-labelledby", e)
        }).next().attr("role", "tabpanel"), this.headers.not(this.active).attr({
          "aria-selected": "false",
          "aria-expanded": "false",
          tabIndex: -1
        }).next().attr({
          "aria-hidden": "true"
        }).hide(), this.active.length ? this.active.attr({
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        }).next().attr({
          "aria-hidden": "false"
        }) : this.headers.eq(0).attr("tabIndex", 0), this._createIcons(), this._setupEvents(t.event), "fill" === e ? (i = s.height(), this.element.siblings(":visible").each(function () {
          var t = x(this),
            e = t.css("position");
          "absolute" !== e && "fixed" !== e && (i -= t.outerHeight(!0))
        }), this.headers.each(function () {
          i -= x(this).outerHeight(!0)
        }), this.headers.next().each(function () {
          x(this).height(Math.max(0, i - x(this).innerHeight() + x(this).height()))
        }).css("overflow", "auto")) : "auto" === e && (i = 0, this.headers.next().each(function () {
          var t = x(this).is(":visible");
          t || x(this).show(), i = Math.max(i, x(this).css("height", "").height()), t || x(this).hide()
        }).height(i))
      },
      _activate: function (t) {
        t = this._findActive(t)[0];
        t !== this.active[0] && (t = t || this.active[0], this._eventHandler({
          target: t,
          currentTarget: t,
          preventDefault: x.noop
        }))
      },
      _findActive: function (t) {
        return "number" == typeof t ? this.headers.eq(t) : x()
      },
      _setupEvents: function (t) {
        var i = {
          keydown: "_keydown"
        };
        t && x.each(t.split(" "), function (t, e) {
          i[e] = "_eventHandler"
        }), this._off(this.headers.add(this.headers.next())), this._on(this.headers, i), this._on(this.headers.next(), {
          keydown: "_panelKeyDown"
        }), this._hoverable(this.headers), this._focusable(this.headers)
      },
      _eventHandler: function (t) {
        var e = this.options,
          i = this.active,
          s = x(t.currentTarget),
          n = s[0] === i[0],
          a = n && e.collapsible,
          o = a ? x() : s.next(),
          r = i.next(),
          o = {
            oldHeader: i,
            oldPanel: r,
            newHeader: a ? x() : s,
            newPanel: o
          };
        t.preventDefault(), n && !e.collapsible || !1 === this._trigger("beforeActivate", t, o) || (e.active = !a && this.headers.index(s), this.active = n ? x() : s, this._toggle(o), this._removeClass(i, "ui-accordion-header-active", "ui-state-active"), e.icons && (i = i.children(".ui-accordion-header-icon"), this._removeClass(i, null, e.icons.activeHeader)._addClass(i, null, e.icons.header)), n || (this._removeClass(s, "ui-accordion-header-collapsed")._addClass(s, "ui-accordion-header-active", "ui-state-active"), e.icons && (n = s.children(".ui-accordion-header-icon"), this._removeClass(n, null, e.icons.header)._addClass(n, null, e.icons.activeHeader)), this._addClass(s.next(), "ui-accordion-content-active")))
      },
      _toggle: function (t) {
        var e = t.newPanel,
          i = this.prevShow.length ? this.prevShow : t.oldPanel;
        this.prevShow.add(this.prevHide).stop(!0, !0), this.prevShow = e, this.prevHide = i, this.options.animate ? this._animate(e, i, t) : (i.hide(), e.show(), this._toggleComplete(t)), i.attr({
          "aria-hidden": "true"
        }), i.prev().attr({
          "aria-selected": "false",
          "aria-expanded": "false"
        }), e.length && i.length ? i.prev().attr({
          tabIndex: -1,
          "aria-expanded": "false"
        }) : e.length && this.headers.filter(function () {
          return 0 === parseInt(x(this).attr("tabIndex"), 10)
        }).attr("tabIndex", -1), e.attr("aria-hidden", "false").prev().attr({
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        })
      },
      _animate: function (t, i, e) {
        var s, n = this,
          a = 0,
          o = t.css("box-sizing"),
          r = t.length && (!i.length || t.index() < i.index()),
          l = this.options.animate || {},
          c = r && l.down || l,
          r = function () {
            n._toggleComplete(e)
          },
          d = (d = "string" == typeof c ? c : d) || c.easing || l.easing,
          h = (h = "number" == typeof c ? c : h) || c.duration || l.duration;
        return i.length ? t.length ? (s = t.show().outerHeight(), i.animate(this.hideProps, {
          duration: h,
          easing: d,
          step: function (t, e) {
            e.now = Math.round(t)
          }
        }), void t.hide().animate(this.showProps, {
          duration: h,
          easing: d,
          complete: r,
          step: function (t, e) {
            e.now = Math.round(t), "height" !== e.prop ? "content-box" === o && (a += e.now) : "content" !== n.options.heightStyle && (e.now = Math.round(s - i.outerHeight() - a), a = 0)
          }
        })) : i.animate(this.hideProps, h, d, r) : t.animate(this.showProps, h, d, r)
      },
      _toggleComplete: function (t) {
        var e = t.oldPanel,
          i = e.prev();
        this._removeClass(e, "ui-accordion-content-active"), this._removeClass(i, "ui-accordion-header-active")._addClass(i, "ui-accordion-header-collapsed"), e.length && (e.parent()[0].className = e.parent()[0].className), this._trigger("activate", null, t)
      }
    }), x.ui.safeActiveElement = function (e) {
      var i;
      try {
        i = e.activeElement
      } catch (t) {
        i = e.body
      }
      return i = !(i = i || e.body).nodeName ? e.body : i
    }, x.widget("ui.menu", {
      version: "1.12.1",
      defaultElement: "<ul>",
      delay: 300,
      options: {
        icons: {
          submenu: "ui-icon-caret-1-e"
        },
        items: "> *",
        menus: "ul",
        position: {
          my: "left top",
          at: "right top"
        },
        role: "menu",
        blur: null,
        focus: null,
        select: null
      },
      _create: function () {
        this.activeMenu = this.element, this.mouseHandled = !1, this.element.uniqueId().attr({
          role: this.options.role,
          tabIndex: 0
        }), this._addClass("ui-menu", "ui-widget ui-widget-content"), this._on({
          "mousedown .ui-menu-item": function (t) {
            t.preventDefault()
          },
          "click .ui-menu-item": function (t) {
            var e = x(t.target),
              i = x(x.ui.safeActiveElement(this.document[0]));
            !this.mouseHandled && e.not(".ui-state-disabled").length && (this.select(t), t.isPropagationStopped() || (this.mouseHandled = !0), e.has(".ui-menu").length ? this.expand(t) : !this.element.is(":focus") && i.closest(".ui-menu").length && (this.element.trigger("focus", [!0]), this.active && 1 === this.active.parents(".ui-menu").length && clearTimeout(this.timer)))
          },
          "mouseenter .ui-menu-item": function (t) {
            var e, i;
            this.previousFilter || (e = x(t.target).closest(".ui-menu-item"), i = x(t.currentTarget), e[0] === i[0] && (this._removeClass(i.siblings().children(".ui-state-active"), null, "ui-state-active"), this.focus(t, i)))
          },
          mouseleave: "collapseAll",
          "mouseleave .ui-menu": "collapseAll",
          focus: function (t, e) {
            var i = this.active || this.element.find(this.options.items).eq(0);
            e || this.focus(t, i)
          },
          blur: function (t) {
            this._delay(function () {
              x.contains(this.element[0], x.ui.safeActiveElement(this.document[0])) || this.collapseAll(t)
            })
          },
          keydown: "_keydown"
        }), this.refresh(), this._on(this.document, {
          click: function (t) {
            this._closeOnDocumentClick(t) && this.collapseAll(t), this.mouseHandled = !1
          }
        })
      },
      _destroy: function () {
        var t = this.element.find(".ui-menu-item").removeAttr("role aria-disabled").children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");
        this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(), t.children().each(function () {
          var t = x(this);
          t.data("ui-menu-submenu-caret") && t.remove()
        })
      },
      _keydown: function (t) {
        var e, i, s, n = !0;
        switch (t.keyCode) {
          case x.ui.keyCode.PAGE_UP:
            this.previousPage(t);
            break;
          case x.ui.keyCode.PAGE_DOWN:
            this.nextPage(t);
            break;
          case x.ui.keyCode.HOME:
            this._move("first", "first", t);
            break;
          case x.ui.keyCode.END:
            this._move("last", "last", t);
            break;
          case x.ui.keyCode.UP:
            this.previous(t);
            break;
          case x.ui.keyCode.DOWN:
            this.next(t);
            break;
          case x.ui.keyCode.LEFT:
            this.collapse(t);
            break;
          case x.ui.keyCode.RIGHT:
            this.active && !this.active.is(".ui-state-disabled") && this.expand(t);
            break;
          case x.ui.keyCode.ENTER:
          case x.ui.keyCode.SPACE:
            this._activate(t);
            break;
          case x.ui.keyCode.ESCAPE:
            this.collapse(t);
            break;
          default:
            e = this.previousFilter || "", s = n = !1, i = 96 <= t.keyCode && t.keyCode <= 105 ? (t.keyCode - 96).toString() : String.fromCharCode(t.keyCode), clearTimeout(this.filterTimer), i === e ? s = !0 : i = e + i, e = this._filterMenuItems(i), (e = s && -1 !== e.index(this.active.next()) ? this.active.nextAll(".ui-menu-item") : e).length || (i = String.fromCharCode(t.keyCode), e = this._filterMenuItems(i)), e.length ? (this.focus(t, e), this.previousFilter = i, this.filterTimer = this._delay(function () {
              delete this.previousFilter
            }, 1e3)) : delete this.previousFilter
        }
        n && t.preventDefault()
      },
      _activate: function (t) {
        this.active && !this.active.is(".ui-state-disabled") && (this.active.children("[aria-haspopup='true']").length ? this.expand(t) : this.select(t))
      },
      refresh: function () {
        var t, e, s = this,
          n = this.options.icons.submenu,
          i = this.element.find(this.options.menus);
        this._toggleClass("ui-menu-icons", null, !!this.element.find(".ui-icon").length), e = i.filter(":not(.ui-menu)").hide().attr({
          role: this.options.role,
          "aria-hidden": "true",
          "aria-expanded": "false"
        }).each(function () {
          var t = x(this),
            e = t.prev(),
            i = x("<span>").data("ui-menu-submenu-caret", !0);
          s._addClass(i, "ui-menu-icon", "ui-icon " + n), e.attr("aria-haspopup", "true").prepend(i), t.attr("aria-labelledby", e.attr("id"))
        }), this._addClass(e, "ui-menu", "ui-widget ui-widget-content ui-front"), (t = i.add(this.element).find(this.options.items)).not(".ui-menu-item").each(function () {
          var t = x(this);
          s._isDivider(t) && s._addClass(t, "ui-menu-divider", "ui-widget-content")
        }), i = (e = t.not(".ui-menu-item, .ui-menu-divider")).children().not(".ui-menu").uniqueId().attr({
          tabIndex: -1,
          role: this._itemRole()
        }), this._addClass(e, "ui-menu-item")._addClass(i, "ui-menu-item-wrapper"), t.filter(".ui-state-disabled").attr("aria-disabled", "true"), this.active && !x.contains(this.element[0], this.active[0]) && this.blur()
      },
      _itemRole: function () {
        return {
          menu: "menuitem",
          listbox: "option"
        } [this.options.role]
      },
      _setOption: function (t, e) {
        var i;
        "icons" === t && (i = this.element.find(".ui-menu-icon"), this._removeClass(i, null, this.options.icons.submenu)._addClass(i, null, e.submenu)), this._super(t, e)
      },
      _setOptionDisabled: function (t) {
        this._super(t), this.element.attr("aria-disabled", String(t)), this._toggleClass(null, "ui-state-disabled", !!t)
      },
      focus: function (t, e) {
        var i;
        this.blur(t, t && "focus" === t.type), this._scrollIntoView(e), this.active = e.first(), i = this.active.children(".ui-menu-item-wrapper"), this._addClass(i, null, "ui-state-active"), this.options.role && this.element.attr("aria-activedescendant", i.attr("id")), i = this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"), this._addClass(i, null, "ui-state-active"), t && "keydown" === t.type ? this._close() : this.timer = this._delay(function () {
          this._close()
        }, this.delay), (i = e.children(".ui-menu")).length && t && /^mouse/.test(t.type) && this._startOpening(i), this.activeMenu = e.parent(), this._trigger("focus", t, {
          item: e
        })
      },
      _scrollIntoView: function (t) {
        var e, i, s;
        this._hasScroll() && (i = parseFloat(x.css(this.activeMenu[0], "borderTopWidth")) || 0, s = parseFloat(x.css(this.activeMenu[0], "paddingTop")) || 0, e = t.offset().top - this.activeMenu.offset().top - i - s, i = this.activeMenu.scrollTop(), s = this.activeMenu.height(), t = t.outerHeight(), e < 0 ? this.activeMenu.scrollTop(i + e) : s < e + t && this.activeMenu.scrollTop(i + e - s + t))
      },
      blur: function (t, e) {
        e || clearTimeout(this.timer), this.active && (this._removeClass(this.active.children(".ui-menu-item-wrapper"), null, "ui-state-active"), this._trigger("blur", t, {
          item: this.active
        }), this.active = null)
      },
      _startOpening: function (t) {
        clearTimeout(this.timer), "true" === t.attr("aria-hidden") && (this.timer = this._delay(function () {
          this._close(), this._open(t)
        }, this.delay))
      },
      _open: function (t) {
        var e = x.extend({
          of: this.active
        }, this.options.position);
        clearTimeout(this.timer), this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden", "true"), t.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(e)
      },
      collapseAll: function (e, i) {
        clearTimeout(this.timer), this.timer = this._delay(function () {
          var t = i ? this.element : x(e && e.target).closest(this.element.find(".ui-menu"));
          t.length || (t = this.element), this._close(t), this.blur(e), this._removeClass(t.find(".ui-state-active"), null, "ui-state-active"), this.activeMenu = t
        }, this.delay)
      },
      _close: function (t) {
        (t = t || (this.active ? this.active.parent() : this.element)).find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false")
      },
      _closeOnDocumentClick: function (t) {
        return !x(t.target).closest(".ui-menu").length
      },
      _isDivider: function (t) {
        return !/[^\-\u2014\u2013\s]/.test(t.text())
      },
      collapse: function (t) {
        var e = this.active && this.active.parent().closest(".ui-menu-item", this.element);
        e && e.length && (this._close(), this.focus(t, e))
      },
      expand: function (t) {
        var e = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
        e && e.length && (this._open(e.parent()), this._delay(function () {
          this.focus(t, e)
        }))
      },
      next: function (t) {
        this._move("next", "first", t)
      },
      previous: function (t) {
        this._move("prev", "last", t)
      },
      isFirstItem: function () {
        return this.active && !this.active.prevAll(".ui-menu-item").length
      },
      isLastItem: function () {
        return this.active && !this.active.nextAll(".ui-menu-item").length
      },
      _move: function (t, e, i) {
        var s;
        (s = this.active ? "first" === t || "last" === t ? this.active["first" === t ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1) : this.active[t + "All"](".ui-menu-item").eq(0) : s) && s.length && this.active || (s = this.activeMenu.find(this.options.items)[e]()), this.focus(i, s)
      },
      nextPage: function (t) {
        var e, i, s;
        this.active ? this.isLastItem() || (this._hasScroll() ? (i = this.active.offset().top, s = this.element.height(), this.active.nextAll(".ui-menu-item").each(function () {
          return (e = x(this)).offset().top - i - s < 0
        }), this.focus(t, e)) : this.focus(t, this.activeMenu.find(this.options.items)[this.active ? "last" : "first"]())) : this.next(t)
      },
      previousPage: function (t) {
        var e, i, s;
        this.active ? this.isFirstItem() || (this._hasScroll() ? (i = this.active.offset().top, s = this.element.height(), this.active.prevAll(".ui-menu-item").each(function () {
          return 0 < (e = x(this)).offset().top - i + s
        }), this.focus(t, e)) : this.focus(t, this.activeMenu.find(this.options.items).first())) : this.next(t)
      },
      _hasScroll: function () {
        return this.element.outerHeight() < this.element.prop("scrollHeight")
      },
      select: function (t) {
        this.active = this.active || x(t.target).closest(".ui-menu-item");
        var e = {
          item: this.active
        };
        this.active.has(".ui-menu").length || this.collapseAll(t, !0), this._trigger("select", t, e)
      },
      _filterMenuItems: function (t) {
        var t = t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&"),
          e = new RegExp("^" + t, "i");
        return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function () {
          return e.test(x.trim(x(this).children(".ui-menu-item-wrapper").text()))
        })
      }
    }), x.widget("ui.autocomplete", {
      version: "1.12.1",
      defaultElement: "<input>",
      options: {
        appendTo: null,
        autoFocus: !1,
        delay: 300,
        minLength: 1,
        position: {
          my: "left top",
          at: "left bottom",
          collision: "none"
        },
        source: null,
        change: null,
        close: null,
        focus: null,
        open: null,
        response: null,
        search: null,
        select: null
      },
      requestIndex: 0,
      pending: 0,
      _create: function () {
        var i, s, n, t = this.element[0].nodeName.toLowerCase(),
          e = "textarea" === t,
          t = "input" === t;
        this.isMultiLine = e || !t && this._isContentEditable(this.element), this.valueMethod = this.element[e || t ? "val" : "text"], this.isNewMenu = !0, this._addClass("ui-autocomplete-input"), this.element.attr("autocomplete", "off"), this._on(this.element, {
          keydown: function (t) {
            if (this.element.prop("readOnly")) s = n = i = !0;
            else {
              s = n = i = !1;
              var e = x.ui.keyCode;
              switch (t.keyCode) {
                case e.PAGE_UP:
                  i = !0, this._move("previousPage", t);
                  break;
                case e.PAGE_DOWN:
                  i = !0, this._move("nextPage", t);
                  break;
                case e.UP:
                  i = !0, this._keyEvent("previous", t);
                  break;
                case e.DOWN:
                  i = !0, this._keyEvent("next", t);
                  break;
                case e.ENTER:
                  this.menu.active && (i = !0, t.preventDefault(), this.menu.select(t));
                  break;
                case e.TAB:
                  this.menu.active && this.menu.select(t);
                  break;
                case e.ESCAPE:
                  this.menu.element.is(":visible") && (this.isMultiLine || this._value(this.term), this.close(t), t.preventDefault());
                  break;
                default:
                  s = !0, this._searchTimeout(t)
              }
            }
          },
          keypress: function (t) {
            if (i) return i = !1, void(this.isMultiLine && !this.menu.element.is(":visible") || t.preventDefault());
            if (!s) {
              var e = x.ui.keyCode;
              switch (t.keyCode) {
                case e.PAGE_UP:
                  this._move("previousPage", t);
                  break;
                case e.PAGE_DOWN:
                  this._move("nextPage", t);
                  break;
                case e.UP:
                  this._keyEvent("previous", t);
                  break;
                case e.DOWN:
                  this._keyEvent("next", t)
              }
            }
          },
          input: function (t) {
            if (n) return n = !1, void t.preventDefault();
            this._searchTimeout(t)
          },
          focus: function () {
            this.selectedItem = null, this.previous = this._value()
          },
          blur: function (t) {
            this.cancelBlur ? delete this.cancelBlur : (clearTimeout(this.searching), this.close(t), this._change(t))
          }
        }), this._initSource(), this.menu = x("<ul>").appendTo(this._appendTo()).menu({
          role: null
        }).hide().menu("instance"), this._addClass(this.menu.element, "ui-autocomplete", "ui-front"), this._on(this.menu.element, {
          mousedown: function (t) {
            t.preventDefault(), this.cancelBlur = !0, this._delay(function () {
              delete this.cancelBlur, this.element[0] !== x.ui.safeActiveElement(this.document[0]) && this.element.trigger("focus")
            })
          },
          menufocus: function (t, e) {
            var i;
            if (this.isNewMenu && (this.isNewMenu = !1, t.originalEvent && /^mouse/.test(t.originalEvent.type))) return this.menu.blur(), void this.document.one("mousemove", function () {
              x(t.target).trigger(t.originalEvent)
            });
            i = e.item.data("ui-autocomplete-item"), !1 !== this._trigger("focus", t, {
              item: i
            }) && t.originalEvent && /^key/.test(t.originalEvent.type) && this._value(i.value), (i = e.item.attr("aria-label") || i.value) && x.trim(i).length && (this.liveRegion.children().hide(), x("<div>").text(i).appendTo(this.liveRegion))
          },
          menuselect: function (t, e) {
            var i = e.item.data("ui-autocomplete-item"),
              s = this.previous;
            this.element[0] !== x.ui.safeActiveElement(this.document[0]) && (this.element.trigger("focus"), this.previous = s, this._delay(function () {
              this.previous = s, this.selectedItem = i
            })), !1 !== this._trigger("select", t, {
              item: i
            }) && this._value(i.value), this.term = this._value(), this.close(t), this.selectedItem = i
          }
        }), this.liveRegion = x("<div>", {
          role: "status",
          "aria-live": "assertive",
          "aria-relevant": "additions"
        }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this._on(this.window, {
          beforeunload: function () {
            this.element.removeAttr("autocomplete")
          }
        })
      },
      _destroy: function () {
        clearTimeout(this.searching), this.element.removeAttr("autocomplete"), this.menu.element.remove(), this.liveRegion.remove()
      },
      _setOption: function (t, e) {
        this._super(t, e), "source" === t && this._initSource(), "appendTo" === t && this.menu.element.appendTo(this._appendTo()), "disabled" === t && e && this.xhr && this.xhr.abort()
      },
      _isEventTargetInWidget: function (t) {
        var e = this.menu.element[0];
        return t.target === this.element[0] || t.target === e || x.contains(e, t.target)
      },
      _closeOnClickOutside: function (t) {
        this._isEventTargetInWidget(t) || this.close()
      },
      _appendTo: function () {
        var t = this.options.appendTo;
        return t = !(t = !(t = t && (t.jquery || t.nodeType ? x(t) : this.document.find(t).eq(0))) || !t[0] ? this.element.closest(".ui-front, dialog") : t).length ? this.document[0].body : t
      },
      _initSource: function () {
        var i, s, n = this;
        x.isArray(this.options.source) ? (i = this.options.source, this.source = function (t, e) {
          e(x.ui.autocomplete.filter(i, t.term))
        }) : "string" == typeof this.options.source ? (s = this.options.source, this.source = function (t, e) {
          n.xhr && n.xhr.abort(), n.xhr = x.ajax({
            url: s,
            data: t,
            dataType: "json",
            success: function (t) {
              e(t)
            },
            error: function () {
              e([])
            }
          })
        }) : this.source = this.options.source
      },
      _searchTimeout: function (s) {
        clearTimeout(this.searching), this.searching = this._delay(function () {
          var t = this.term === this._value(),
            e = this.menu.element.is(":visible"),
            i = s.altKey || s.ctrlKey || s.metaKey || s.shiftKey;
          t && (!t || e || i) || (this.selectedItem = null, this.search(null, s))
        }, this.options.delay)
      },
      search: function (t, e) {
        return t = null != t ? t : this._value(), this.term = this._value(), t.length < this.options.minLength ? this.close(e) : !1 !== this._trigger("search", e) ? this._search(t) : void 0
      },
      _search: function (t) {
        this.pending++, this._addClass("ui-autocomplete-loading"), this.cancelSearch = !1, this.source({
          term: t
        }, this._response())
      },
      _response: function () {
        var e = ++this.requestIndex;
        return x.proxy(function (t) {
          e === this.requestIndex && this.__response(t), this.pending--, this.pending || this._removeClass("ui-autocomplete-loading")
        }, this)
      },
      __response: function (t) {
        t = t && this._normalize(t), this._trigger("response", null, {
          content: t
        }), !this.options.disabled && t && t.length && !this.cancelSearch ? (this._suggest(t), this._trigger("open")) : this._close()
      },
      close: function (t) {
        this.cancelSearch = !0, this._close(t)
      },
      _close: function (t) {
        this._off(this.document, "mousedown"), this.menu.element.is(":visible") && (this.menu.element.hide(), this.menu.blur(), this.isNewMenu = !0, this._trigger("close", t))
      },
      _change: function (t) {
        this.previous !== this._value() && this._trigger("change", t, {
          item: this.selectedItem
        })
      },
      _normalize: function (t) {
        return t.length && t[0].label && t[0].value ? t : x.map(t, function (t) {
          return "string" == typeof t ? {
            label: t,
            value: t
          } : x.extend({}, t, {
            label: t.label || t.value,
            value: t.value || t.label
          })
        })
      },
      _suggest: function (t) {
        var e = this.menu.element.empty();
        this._renderMenu(e, t), this.isNewMenu = !0, this.menu.refresh(), e.show(), this._resizeMenu(), e.position(x.extend({
          of: this.element
        }, this.options.position)), this.options.autoFocus && this.menu.next(), this._on(this.document, {
          mousedown: "_closeOnClickOutside"
        })
      },
      _resizeMenu: function () {
        var t = this.menu.element;
        t.outerWidth(Math.max(t.width("").outerWidth() + 1, this.element.outerWidth()))
      },
      _renderMenu: function (i, t) {
        var s = this;
        x.each(t, function (t, e) {
          s._renderItemData(i, e)
        })
      },
      _renderItemData: function (t, e) {
        return this._renderItem(t, e).data("ui-autocomplete-item", e)
      },
      _renderItem: function (t, e) {
        return x("<li>").append(x("<div>").text(e.label)).appendTo(t)
      },
      _move: function (t, e) {
        if (this.menu.element.is(":visible")) return this.menu.isFirstItem() && /^previous/.test(t) || this.menu.isLastItem() && /^next/.test(t) ? (this.isMultiLine || this._value(this.term), void this.menu.blur()) : void this.menu[t](e);
        this.search(null, e)
      },
      widget: function () {
        return this.menu.element
      },
      _value: function () {
        return this.valueMethod.apply(this.element, arguments)
      },
      _keyEvent: function (t, e) {
        this.isMultiLine && !this.menu.element.is(":visible") || (this._move(t, e), e.preventDefault())
      },
      _isContentEditable: function (t) {
        if (!t.length) return !1;
        var e = t.prop("contentEditable");
        return "inherit" === e ? this._isContentEditable(t.parent()) : "true" === e
      }
    }), x.extend(x.ui.autocomplete, {
      escapeRegex: function (t) {
        return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&")
      },
      filter: function (t, e) {
        var i = new RegExp(x.ui.autocomplete.escapeRegex(e), "i");
        return x.grep(t, function (t) {
          return i.test(t.label || t.value || t)
        })
      }
    }), x.widget("ui.autocomplete", x.ui.autocomplete, {
      options: {
        messages: {
          noResults: "No search results.",
          results: function (t) {
            return t + (1 < t ? " results are" : " result is") + " available, use up and down arrow keys to navigate."
          }
        }
      },
      __response: function (t) {
        var e;
        this._superApply(arguments), this.options.disabled || this.cancelSearch || (e = t && t.length ? this.options.messages.results(t.length) : this.options.messages.noResults, this.liveRegion.children().hide(), x("<div>").text(e).appendTo(this.liveRegion))
      }
    }), x.ui.autocomplete;
    var U, X, G = /ui-corner-([a-z]){2,6}/g;

    function K() {
      this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = {
        closeText: "Done",
        prevText: "Prev",
        nextText: "Next",
        currentText: "Today",
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        weekHeader: "Wk",
        dateFormat: "mm/dd/yy",
        firstDay: 0,
        isRTL: !1,
        showMonthAfterYear: !1,
        yearSuffix: ""
      }, this._defaults = {
        showOn: "focus",
        showAnim: "fadeIn",
        showOptions: {},
        defaultDate: null,
        appendText: "",
        buttonText: "...",
        buttonImage: "",
        buttonImageOnly: !1,
        hideIfNoPrevNext: !1,
        navigationAsDateFormat: !1,
        gotoCurrent: !1,
        changeMonth: !1,
        changeYear: !1,
        yearRange: "c-10:c+10",
        showOtherMonths: !1,
        selectOtherMonths: !1,
        showWeek: !1,
        calculateWeek: this.iso8601Week,
        shortYearCutoff: "+10",
        minDate: null,
        maxDate: null,
        duration: "fast",
        beforeShowDay: null,
        beforeShow: null,
        onSelect: null,
        onChangeMonthYear: null,
        onClose: null,
        numberOfMonths: 1,
        showCurrentAtPos: 0,
        stepMonths: 1,
        stepBigMonths: 12,
        altField: "",
        altFormat: "",
        constrainInput: !0,
        showButtonPanel: !1,
        autoSize: !1,
        disabled: !1
      }, x.extend(this._defaults, this.regional[""]), this.regional.en = x.extend(!0, {}, this.regional[""]), this.regional["en-US"] = x.extend(!0, {}, this.regional.en), this.dpDiv = Q(x("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))
    }

    function Q(t) {
      var e = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
      return t.on("mouseout", e, function () {
        x(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && x(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && x(this).removeClass("ui-datepicker-next-hover")
      }).on("mouseover", e, J)
    }

    function J() {
      x.datepicker._isDisabledDatepicker((X.inline ? X.dpDiv.parent() : X.input)[0]) || (x(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), x(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && x(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && x(this).addClass("ui-datepicker-next-hover"))
    }

    function Z(t, e) {
      for (var i in x.extend(t, e), e) null == e[i] && (t[i] = e[i]);
      return t
    }
    x.widget("ui.controlgroup", {
      version: "1.12.1",
      defaultElement: "<div>",
      options: {
        direction: "horizontal",
        disabled: null,
        onlyVisible: !0,
        items: {
          button: "input[type=button], input[type=submit], input[type=reset], button, a",
          controlgroupLabel: ".ui-controlgroup-label",
          checkboxradio: "input[type='checkbox'], input[type='radio']",
          selectmenu: "select",
          spinner: ".ui-spinner-input"
        }
      },
      _create: function () {
        this._enhance()
      },
      _enhance: function () {
        this.element.attr("role", "toolbar"), this.refresh()
      },
      _destroy: function () {
        this._callChildMethod("destroy"), this.childWidgets.removeData("ui-controlgroup-data"), this.element.removeAttr("role"), this.options.items.controlgroupLabel && this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()
      },
      _initWidgets: function () {
        var a = this,
          o = [];
        x.each(this.options.items, function (s, t) {
          var e, n;
          if (t) return "controlgroupLabel" === s ? ((e = a.element.find(t)).each(function () {
            var t = x(this);
            t.children(".ui-controlgroup-label-contents").length || t.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")
          }), a._addClass(e, null, "ui-widget ui-widget-content ui-state-default"), void(o = o.concat(e.get()))) : void(x.fn[s] && (n = a["_" + s + "Options"] ? a["_" + s + "Options"]("middle") : {
            classes: {}
          }, a.element.find(t).each(function () {
            var t = x(this),
              e = t[s]("instance"),
              i = x.widget.extend({}, n);
            "button" === s && t.parent(".ui-spinner").length || ((e = e || t[s]()[s]("instance")) && (i.classes = a._resolveClassesValues(i.classes, e)), t[s](i), i = t[s]("widget"), x.data(i[0], "ui-controlgroup-data", e || t[s]("instance")), o.push(i[0]))
          })))
        }), this.childWidgets = x(x.unique(o)), this._addClass(this.childWidgets, "ui-controlgroup-item")
      },
      _callChildMethod: function (e) {
        this.childWidgets.each(function () {
          var t = x(this).data("ui-controlgroup-data");
          t && t[e] && t[e]()
        })
      },
      _updateCornerClass: function (t, e) {
        e = this._buildSimpleOptions(e, "label").classes.label;
        this._removeClass(t, null, "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all"), this._addClass(t, null, e)
      },
      _buildSimpleOptions: function (t, e) {
        var i = "vertical" === this.options.direction,
          s = {
            classes: {}
          };
        return s.classes[e] = {
          middle: "",
          first: "ui-corner-" + (i ? "top" : "left"),
          last: "ui-corner-" + (i ? "bottom" : "right"),
          only: "ui-corner-all"
        } [t], s
      },
      _spinnerOptions: function (t) {
        t = this._buildSimpleOptions(t, "ui-spinner");
        return t.classes["ui-spinner-up"] = "", t.classes["ui-spinner-down"] = "", t
      },
      _buttonOptions: function (t) {
        return this._buildSimpleOptions(t, "ui-button")
      },
      _checkboxradioOptions: function (t) {
        return this._buildSimpleOptions(t, "ui-checkboxradio-label")
      },
      _selectmenuOptions: function (t) {
        var e = "vertical" === this.options.direction;
        return {
          width: !!e && "auto",
          classes: {
            middle: {
              "ui-selectmenu-button-open": "",
              "ui-selectmenu-button-closed": ""
            },
            first: {
              "ui-selectmenu-button-open": "ui-corner-" + (e ? "top" : "tl"),
              "ui-selectmenu-button-closed": "ui-corner-" + (e ? "top" : "left")
            },
            last: {
              "ui-selectmenu-button-open": e ? "" : "ui-corner-tr",
              "ui-selectmenu-button-closed": "ui-corner-" + (e ? "bottom" : "right")
            },
            only: {
              "ui-selectmenu-button-open": "ui-corner-top",
              "ui-selectmenu-button-closed": "ui-corner-all"
            }
          } [t]
        }
      },
      _resolveClassesValues: function (i, s) {
        var n = {};
        return x.each(i, function (t) {
          var e = s.options.classes[t] || "",
            e = x.trim(e.replace(G, ""));
          n[t] = (e + " " + i[t]).replace(/\s+/g, " ")
        }), n
      },
      _setOption: function (t, e) {
        "direction" === t && this._removeClass("ui-controlgroup-" + this.options.direction), this._super(t, e), "disabled" !== t ? this.refresh() : this._callChildMethod(e ? "disable" : "enable")
      },
      refresh: function () {
        var n, a = this;
        this._addClass("ui-controlgroup ui-controlgroup-" + this.options.direction), "horizontal" === this.options.direction && this._addClass(null, "ui-helper-clearfix"), this._initWidgets(), n = this.childWidgets, (n = this.options.onlyVisible ? n.filter(":visible") : n).length && (x.each(["first", "last"], function (t, e) {
          var i, s = n[e]().data("ui-controlgroup-data");
          s && a["_" + s.widgetName + "Options"] ? ((i = a["_" + s.widgetName + "Options"](1 === n.length ? "only" : e)).classes = a._resolveClassesValues(i.classes, s), s.element[s.widgetName](i)) : a._updateCornerClass(n[e](), e)
        }), this._callChildMethod("refresh"))
      }
    }), x.widget("ui.checkboxradio", [x.ui.formResetMixin, {
      version: "1.12.1",
      options: {
        disabled: null,
        label: null,
        icon: !0,
        classes: {
          "ui-checkboxradio-label": "ui-corner-all",
          "ui-checkboxradio-icon": "ui-corner-all"
        }
      },
      _getCreateOptions: function () {
        var t, e = this,
          i = this._super() || {};
        return this._readType(), t = this.element.labels(), this.label = x(t[t.length - 1]), this.label.length || x.error("No label found for checkboxradio widget"), this.originalLabel = "", this.label.contents().not(this.element[0]).each(function () {
          e.originalLabel += 3 === this.nodeType ? x(this).text() : this.outerHTML
        }), this.originalLabel && (i.label = this.originalLabel), null != (t = this.element[0].disabled) && (i.disabled = t), i
      },
      _create: function () {
        var t = this.element[0].checked;
        this._bindFormResetHandler(), null == this.options.disabled && (this.options.disabled = this.element[0].disabled), this._setOption("disabled", this.options.disabled), this._addClass("ui-checkboxradio", "ui-helper-hidden-accessible"), this._addClass(this.label, "ui-checkboxradio-label", "ui-button ui-widget"), "radio" === this.type && this._addClass(this.label, "ui-checkboxradio-radio-label"), this.options.label && this.options.label !== this.originalLabel ? this._updateLabel() : this.originalLabel && (this.options.label = this.originalLabel), this._enhance(), t && (this._addClass(this.label, "ui-checkboxradio-checked", "ui-state-active"), this.icon && this._addClass(this.icon, null, "ui-state-hover")), this._on({
          change: "_toggleClasses",
          focus: function () {
            this._addClass(this.label, null, "ui-state-focus ui-visual-focus")
          },
          blur: function () {
            this._removeClass(this.label, null, "ui-state-focus ui-visual-focus")
          }
        })
      },
      _readType: function () {
        var t = this.element[0].nodeName.toLowerCase();
        this.type = this.element[0].type, "input" === t && /radio|checkbox/.test(this.type) || x.error("Can't create checkboxradio on element.nodeName=" + t + " and element.type=" + this.type)
      },
      _enhance: function () {
        this._updateIcon(this.element[0].checked)
      },
      widget: function () {
        return this.label
      },
      _getRadioGroup: function () {
        var t = this.element[0].name,
          e = "input[name='" + x.ui.escapeSelector(t) + "']";
        return t ? (this.form.length ? x(this.form[0].elements).filter(e) : x(e).filter(function () {
          return 0 === x(this).form().length
        })).not(this.element) : x([])
      },
      _toggleClasses: function () {
        var t = this.element[0].checked;
        this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t), this.options.icon && "checkbox" === this.type && this._toggleClass(this.icon, null, "ui-icon-check ui-state-checked", t)._toggleClass(this.icon, null, "ui-icon-blank", !t), "radio" === this.type && this._getRadioGroup().each(function () {
          var t = x(this).checkboxradio("instance");
          t && t._removeClass(t.label, "ui-checkboxradio-checked", "ui-state-active")
        })
      },
      _destroy: function () {
        this._unbindFormResetHandler(), this.icon && (this.icon.remove(), this.iconSpace.remove())
      },
      _setOption: function (t, e) {
        if ("label" !== t || e) {
          if (this._super(t, e), "disabled" === t) return this._toggleClass(this.label, null, "ui-state-disabled", e), void(this.element[0].disabled = e);
          this.refresh()
        }
      },
      _updateIcon: function (t) {
        var e = "ui-icon ui-icon-background ";
        this.options.icon ? (this.icon || (this.icon = x("<span>"), this.iconSpace = x("<span> </span>"), this._addClass(this.iconSpace, "ui-checkboxradio-icon-space")), "checkbox" === this.type ? (e += t ? "ui-icon-check ui-state-checked" : "ui-icon-blank", this._removeClass(this.icon, null, t ? "ui-icon-blank" : "ui-icon-check")) : e += "ui-icon-blank", this._addClass(this.icon, "ui-checkboxradio-icon", e), t || this._removeClass(this.icon, null, "ui-icon-check ui-state-checked"), this.icon.prependTo(this.label).after(this.iconSpace)) : void 0 !== this.icon && (this.icon.remove(), this.iconSpace.remove(), delete this.icon)
      },
      _updateLabel: function () {
        var t = this.label.contents().not(this.element[0]);
        this.icon && (t = t.not(this.icon[0])), (t = this.iconSpace ? t.not(this.iconSpace[0]) : t).remove(), this.label.append(this.options.label)
      },
      refresh: function () {
        var t = this.element[0].checked,
          e = this.element[0].disabled;
        this._updateIcon(t), this._toggleClass(this.label, "ui-checkboxradio-checked", "ui-state-active", t), null !== this.options.label && this._updateLabel(), e !== this.options.disabled && this._setOptions({
          disabled: e
        })
      }
    }]), x.ui.checkboxradio, x.widget("ui.button", {
      version: "1.12.1",
      defaultElement: "<button>",
      options: {
        classes: {
          "ui-button": "ui-corner-all"
        },
        disabled: null,
        icon: null,
        iconPosition: "beginning",
        label: null,
        showLabel: !0
      },
      _getCreateOptions: function () {
        var t, e = this._super() || {};
        return this.isInput = this.element.is("input"), null != (t = this.element[0].disabled) && (e.disabled = t), this.originalLabel = this.isInput ? this.element.val() : this.element.html(), this.originalLabel && (e.label = this.originalLabel), e
      },
      _create: function () {
        !this.option.showLabel & !this.options.icon && (this.options.showLabel = !0), null == this.options.disabled && (this.options.disabled = this.element[0].disabled || !1), this.hasTitle = !!this.element.attr("title"), this.options.label && this.options.label !== this.originalLabel && (this.isInput ? this.element.val(this.options.label) : this.element.html(this.options.label)), this._addClass("ui-button", "ui-widget"), this._setOption("disabled", this.options.disabled), this._enhance(), this.element.is("a") && this._on({
          keyup: function (t) {
            t.keyCode === x.ui.keyCode.SPACE && (t.preventDefault(), this.element[0].click ? this.element[0].click() : this.element.trigger("click"))
          }
        })
      },
      _enhance: function () {
        this.element.is("button") || this.element.attr("role", "button"), this.options.icon && (this._updateIcon("icon", this.options.icon), this._updateTooltip())
      },
      _updateTooltip: function () {
        this.title = this.element.attr("title"), this.options.showLabel || this.title || this.element.attr("title", this.options.label)
      },
      _updateIcon: function (t, e) {
        var i = "iconPosition" !== t,
          s = i ? this.options.iconPosition : e,
          t = "top" === s || "bottom" === s;
        this.icon ? i && this._removeClass(this.icon, null, this.options.icon) : (this.icon = x("<span>"), this._addClass(this.icon, "ui-button-icon", "ui-icon"), this.options.showLabel || this._addClass("ui-button-icon-only")), i && this._addClass(this.icon, null, e), this._attachIcon(s), t ? (this._addClass(this.icon, null, "ui-widget-icon-block"), this.iconSpace && this.iconSpace.remove()) : (this.iconSpace || (this.iconSpace = x("<span> </span>"), this._addClass(this.iconSpace, "ui-button-icon-space")), this._removeClass(this.icon, null, "ui-wiget-icon-block"), this._attachIconSpace(s))
      },
      _destroy: function () {
        this.element.removeAttr("role"), this.icon && this.icon.remove(), this.iconSpace && this.iconSpace.remove(), this.hasTitle || this.element.removeAttr("title")
      },
      _attachIconSpace: function (t) {
        this.icon[/^(?:end|bottom)/.test(t) ? "before" : "after"](this.iconSpace)
      },
      _attachIcon: function (t) {
        this.element[/^(?:end|bottom)/.test(t) ? "append" : "prepend"](this.icon)
      },
      _setOptions: function (t) {
        var e = (void 0 === t.showLabel ? this.options : t).showLabel,
          i = (void 0 === t.icon ? this.options : t).icon;
        e || i || (t.showLabel = !0), this._super(t)
      },
      _setOption: function (t, e) {
        "icon" === t && (e ? this._updateIcon(t, e) : this.icon && (this.icon.remove(), this.iconSpace && this.iconSpace.remove())), "iconPosition" === t && this._updateIcon(t, e), "showLabel" === t && (this._toggleClass("ui-button-icon-only", null, !e), this._updateTooltip()), "label" === t && (this.isInput ? this.element.val(e) : (this.element.html(e), this.icon && (this._attachIcon(this.options.iconPosition), this._attachIconSpace(this.options.iconPosition)))), this._super(t, e), "disabled" === t && (this._toggleClass(null, "ui-state-disabled", e), (this.element[0].disabled = e) && this.element.blur())
      },
      refresh: function () {
        var t = this.element.is("input, button") ? this.element[0].disabled : this.element.hasClass("ui-button-disabled");
        t !== this.options.disabled && this._setOptions({
          disabled: t
        }), this._updateTooltip()
      }
    }), !1 !== x.uiBackCompat && (x.widget("ui.button", x.ui.button, {
      options: {
        text: !0,
        icons: {
          primary: null,
          secondary: null
        }
      },
      _create: function () {
        this.options.showLabel && !this.options.text && (this.options.showLabel = this.options.text), !this.options.showLabel && this.options.text && (this.options.text = this.options.showLabel), this.options.icon || !this.options.icons.primary && !this.options.icons.secondary ? this.options.icon && (this.options.icons.primary = this.options.icon) : this.options.icons.primary ? this.options.icon = this.options.icons.primary : (this.options.icon = this.options.icons.secondary, this.options.iconPosition = "end"), this._super()
      },
      _setOption: function (t, e) {
        "text" !== t ? ("showLabel" === t && (this.options.text = e), "icon" === t && (this.options.icons.primary = e), "icons" === t && (e.primary ? (this._super("icon", e.primary), this._super("iconPosition", "beginning")) : e.secondary && (this._super("icon", e.secondary), this._super("iconPosition", "end"))), this._superApply(arguments)) : this._super("showLabel", e)
      }
    }), x.fn.button = (U = x.fn.button, function () {
      return !this.length || this.length && "INPUT" !== this[0].tagName || this.length && "INPUT" === this[0].tagName && "checkbox" !== this.attr("type") && "radio" !== this.attr("type") ? U.apply(this, arguments) : (x.ui.checkboxradio || x.error("Checkboxradio widget missing"), 0 === arguments.length ? this.checkboxradio({
        icon: !1
      }) : this.checkboxradio.apply(this, arguments))
    }), x.fn.buttonset = function () {
      return x.ui.controlgroup || x.error("Controlgroup widget missing"), "option" === arguments[0] && "items" === arguments[1] && arguments[2] ? this.controlgroup.apply(this, [arguments[0], "items.button", arguments[2]]) : "option" === arguments[0] && "items" === arguments[1] ? this.controlgroup.apply(this, [arguments[0], "items.button"]) : ("object" == typeof arguments[0] && arguments[0].items && (arguments[0].items = {
        button: arguments[0].items
      }), this.controlgroup.apply(this, arguments))
    }), x.ui.button, x.extend(x.ui, {
      datepicker: {
        version: "1.12.1"
      }
    }), x.extend(K.prototype, {
      markerClassName: "hasDatepicker",
      maxRows: 4,
      _widgetDatepicker: function () {
        return this.dpDiv
      },
      setDefaults: function (t) {
        return Z(this._defaults, t || {}), this
      },
      _attachDatepicker: function (t, e) {
        var i, s, n = "div" === (i = t.nodeName.toLowerCase()) || "span" === i;
        t.id || (this.uuid += 1, t.id = "dp" + this.uuid), (s = this._newInst(x(t), n)).settings = x.extend({}, e || {}), "input" === i ? this._connectDatepicker(t, s) : n && this._inlineDatepicker(t, s)
      },
      _newInst: function (t, e) {
        return {
          id: t[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"),
          input: t,
          selectedDay: 0,
          selectedMonth: 0,
          selectedYear: 0,
          drawMonth: 0,
          drawYear: 0,
          inline: e,
          dpDiv: e ? Q(x("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv
        }
      },
      _connectDatepicker: function (t, e) {
        var i = x(t);
        e.append = x([]), e.trigger = x([]), i.hasClass(this.markerClassName) || (this._attachments(i, e), i.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp), this._autoSize(e), x.data(t, "datepicker", e), e.settings.disabled && this._disableDatepicker(t))
      },
      _attachments: function (t, e) {
        var i, s = this._get(e, "appendText"),
          n = this._get(e, "isRTL");
        e.append && e.append.remove(), s && (e.append = x("<span class='" + this._appendClass + "'>" + s + "</span>"), t[n ? "before" : "after"](e.append)), t.off("focus", this._showDatepicker), e.trigger && e.trigger.remove(), "focus" !== (i = this._get(e, "showOn")) && "both" !== i || t.on("focus", this._showDatepicker), "button" !== i && "both" !== i || (s = this._get(e, "buttonText"), i = this._get(e, "buttonImage"), e.trigger = x(this._get(e, "buttonImageOnly") ? x("<img/>").addClass(this._triggerClass).attr({
          src: i,
          alt: s,
          title: s
        }) : x("<button type='button'></button>").addClass(this._triggerClass).html(i ? x("<img/>").attr({
          src: i,
          alt: s,
          title: s
        }) : s)), t[n ? "before" : "after"](e.trigger), e.trigger.on("click", function () {
          return x.datepicker._datepickerShowing && x.datepicker._lastInput === t[0] ? x.datepicker._hideDatepicker() : (x.datepicker._datepickerShowing && x.datepicker._lastInput !== t[0] && x.datepicker._hideDatepicker(), x.datepicker._showDatepicker(t[0])), !1
        }))
      },
      _autoSize: function (t) {
        var e, i, s, n, a, o;
        this._get(t, "autoSize") && !t.inline && (a = new Date(2009, 11, 20), (o = this._get(t, "dateFormat")).match(/[DM]/) && (e = function (t) {
          for (n = s = i = 0; n < t.length; n++) t[n].length > i && (i = t[n].length, s = n);
          return s
        }, a.setMonth(e(this._get(t, o.match(/MM/) ? "monthNames" : "monthNamesShort"))), a.setDate(e(this._get(t, o.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - a.getDay())), t.input.attr("size", this._formatDate(t, a).length))
      },
      _inlineDatepicker: function (t, e) {
        var i = x(t);
        i.hasClass(this.markerClassName) || (i.addClass(this.markerClassName).append(e.dpDiv), x.data(t, "datepicker", e), this._setDate(e, this._getDefaultDate(e), !0), this._updateDatepicker(e), this._updateAlternate(e), e.settings.disabled && this._disableDatepicker(t), e.dpDiv.css("display", "block"))
      },
      _dialogDatepicker: function (t, e, i, s, n) {
        var a, o = this._dialogInst;
        return o || (this.uuid += 1, a = "dp" + this.uuid, this._dialogInput = x("<input type='text' id='" + a + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.on("keydown", this._doKeyDown), x("body").append(this._dialogInput), (o = this._dialogInst = this._newInst(this._dialogInput, !1)).settings = {}, x.data(this._dialogInput[0], "datepicker", o)), Z(o.settings, s || {}), e = e && e.constructor === Date ? this._formatDate(o, e) : e, this._dialogInput.val(e), this._pos = n ? n.length ? n : [n.pageX, n.pageY] : null, this._pos || (a = document.documentElement.clientWidth, s = document.documentElement.clientHeight, e = document.documentElement.scrollLeft || document.body.scrollLeft, n = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [a / 2 - 100 + e, s / 2 - 150 + n]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), o.settings.onSelect = i, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), x.blockUI && x.blockUI(this.dpDiv), x.data(this._dialogInput[0], "datepicker", o), this
      },
      _destroyDatepicker: function (t) {
        var e, i = x(t),
          s = x.data(t, "datepicker");
        i.hasClass(this.markerClassName) && (e = t.nodeName.toLowerCase(), x.removeData(t, "datepicker"), "input" === e ? (s.append.remove(), s.trigger.remove(), i.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp)) : "div" !== e && "span" !== e || i.removeClass(this.markerClassName).empty(), X === s && (X = null))
      },
      _enableDatepicker: function (e) {
        var t, i = x(e),
          s = x.data(e, "datepicker");
        i.hasClass(this.markerClassName) && ("input" === (t = e.nodeName.toLowerCase()) ? (e.disabled = !1, s.trigger.filter("button").each(function () {
          this.disabled = !1
        }).end().filter("img").css({
          opacity: "1.0",
          cursor: ""
        })) : "div" !== t && "span" !== t || ((i = i.children("." + this._inlineClass)).children().removeClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), this._disabledInputs = x.map(this._disabledInputs, function (t) {
          return t === e ? null : t
        }))
      },
      _disableDatepicker: function (e) {
        var t, i = x(e),
          s = x.data(e, "datepicker");
        i.hasClass(this.markerClassName) && ("input" === (t = e.nodeName.toLowerCase()) ? (e.disabled = !0, s.trigger.filter("button").each(function () {
          this.disabled = !0
        }).end().filter("img").css({
          opacity: "0.5",
          cursor: "default"
        })) : "div" !== t && "span" !== t || ((i = i.children("." + this._inlineClass)).children().addClass("ui-state-disabled"), i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), this._disabledInputs = x.map(this._disabledInputs, function (t) {
          return t === e ? null : t
        }), this._disabledInputs[this._disabledInputs.length] = e)
      },
      _isDisabledDatepicker: function (t) {
        if (!t) return !1;
        for (var e = 0; e < this._disabledInputs.length; e++)
          if (this._disabledInputs[e] === t) return !0;
        return !1
      },
      _getInst: function (t) {
        try {
          return x.data(t, "datepicker")
        } catch (t) {
          throw "Missing instance data for this datepicker"
        }
      },
      _optionDatepicker: function (t, e, i) {
        var s, n, a, o, r = this._getInst(t);
        if (2 === arguments.length && "string" == typeof e) return "defaults" === e ? x.extend({}, x.datepicker._defaults) : r ? "all" === e ? x.extend({}, r.settings) : this._get(r, e) : null;
        s = e || {}, "string" == typeof e && ((s = {})[e] = i), r && (this._curInst === r && this._hideDatepicker(), n = this._getDateDatepicker(t, !0), a = this._getMinMaxDate(r, "min"), o = this._getMinMaxDate(r, "max"), Z(r.settings, s), null !== a && void 0 !== s.dateFormat && void 0 === s.minDate && (r.settings.minDate = this._formatDate(r, a)), null !== o && void 0 !== s.dateFormat && void 0 === s.maxDate && (r.settings.maxDate = this._formatDate(r, o)), "disabled" in s && (s.disabled ? this._disableDatepicker(t) : this._enableDatepicker(t)), this._attachments(x(t), r), this._autoSize(r), this._setDate(r, n), this._updateAlternate(r), this._updateDatepicker(r))
      },
      _changeDatepicker: function (t, e, i) {
        this._optionDatepicker(t, e, i)
      },
      _refreshDatepicker: function (t) {
        t = this._getInst(t);
        t && this._updateDatepicker(t)
      },
      _setDateDatepicker: function (t, e) {
        t = this._getInst(t);
        t && (this._setDate(t, e), this._updateDatepicker(t), this._updateAlternate(t))
      },
      _getDateDatepicker: function (t, e) {
        t = this._getInst(t);
        return t && !t.inline && this._setDateFromField(t, e), t ? this._getDate(t) : null
      },
      _doKeyDown: function (t) {
        var e, i, s = x.datepicker._getInst(t.target),
          n = !0,
          a = s.dpDiv.is(".ui-datepicker-rtl");
        if (s._keyEvent = !0, x.datepicker._datepickerShowing) switch (t.keyCode) {
          case 9:
            x.datepicker._hideDatepicker(), n = !1;
            break;
          case 13:
            return (i = x("td." + x.datepicker._dayOverClass + ":not(." + x.datepicker._currentClass + ")", s.dpDiv))[0] && x.datepicker._selectDay(t.target, s.selectedMonth, s.selectedYear, i[0]), (e = x.datepicker._get(s, "onSelect")) ? (i = x.datepicker._formatDate(s), e.apply(s.input ? s.input[0] : null, [i, s])) : x.datepicker._hideDatepicker(), !1;
          case 27:
            x.datepicker._hideDatepicker();
            break;
          case 33:
            x.datepicker._adjustDate(t.target, t.ctrlKey ? -x.datepicker._get(s, "stepBigMonths") : -x.datepicker._get(s, "stepMonths"), "M");
            break;
          case 34:
            x.datepicker._adjustDate(t.target, t.ctrlKey ? +x.datepicker._get(s, "stepBigMonths") : +x.datepicker._get(s, "stepMonths"), "M");
            break;
          case 35:
            (t.ctrlKey || t.metaKey) && x.datepicker._clearDate(t.target), n = t.ctrlKey || t.metaKey;
            break;
          case 36:
            (t.ctrlKey || t.metaKey) && x.datepicker._gotoToday(t.target), n = t.ctrlKey || t.metaKey;
            break;
          case 37:
            (t.ctrlKey || t.metaKey) && x.datepicker._adjustDate(t.target, a ? 1 : -1, "D"), n = t.ctrlKey || t.metaKey, t.originalEvent.altKey && x.datepicker._adjustDate(t.target, t.ctrlKey ? -x.datepicker._get(s, "stepBigMonths") : -x.datepicker._get(s, "stepMonths"), "M");
            break;
          case 38:
            (t.ctrlKey || t.metaKey) && x.datepicker._adjustDate(t.target, -7, "D"), n = t.ctrlKey || t.metaKey;
            break;
          case 39:
            (t.ctrlKey || t.metaKey) && x.datepicker._adjustDate(t.target, a ? -1 : 1, "D"), n = t.ctrlKey || t.metaKey, t.originalEvent.altKey && x.datepicker._adjustDate(t.target, t.ctrlKey ? +x.datepicker._get(s, "stepBigMonths") : +x.datepicker._get(s, "stepMonths"), "M");
            break;
          case 40:
            (t.ctrlKey || t.metaKey) && x.datepicker._adjustDate(t.target, 7, "D"), n = t.ctrlKey || t.metaKey;
            break;
          default:
            n = !1
        } else 36 === t.keyCode && t.ctrlKey ? x.datepicker._showDatepicker(this) : n = !1;
        n && (t.preventDefault(), t.stopPropagation())
      },
      _doKeyPress: function (t) {
        var e, i = x.datepicker._getInst(t.target);
        if (x.datepicker._get(i, "constrainInput")) return e = x.datepicker._possibleChars(x.datepicker._get(i, "dateFormat")), i = String.fromCharCode(null == t.charCode ? t.keyCode : t.charCode), t.ctrlKey || t.metaKey || i < " " || !e || -1 < e.indexOf(i)
      },
      _doKeyUp: function (t) {
        t = x.datepicker._getInst(t.target);
        if (t.input.val() !== t.lastVal) try {
          x.datepicker.parseDate(x.datepicker._get(t, "dateFormat"), t.input ? t.input.val() : null, x.datepicker._getFormatConfig(t)) && (x.datepicker._setDateFromField(t), x.datepicker._updateAlternate(t), x.datepicker._updateDatepicker(t))
        } catch (t) {}
        return !0
      },
      _showDatepicker: function (t) {
        var e, i, s, n;
        "input" !== (t = t.target || t).nodeName.toLowerCase() && (t = x("input", t.parentNode)[0]), x.datepicker._isDisabledDatepicker(t) || x.datepicker._lastInput === t || (e = x.datepicker._getInst(t), x.datepicker._curInst && x.datepicker._curInst !== e && (x.datepicker._curInst.dpDiv.stop(!0, !0), e && x.datepicker._datepickerShowing && x.datepicker._hideDatepicker(x.datepicker._curInst.input[0])), !1 !== (s = (n = x.datepicker._get(e, "beforeShow")) ? n.apply(t, [t, e]) : {}) && (Z(e.settings, s), e.lastVal = null, x.datepicker._lastInput = t, x.datepicker._setDateFromField(e), x.datepicker._inDialog && (t.value = ""), x.datepicker._pos || (x.datepicker._pos = x.datepicker._findPos(t), x.datepicker._pos[1] += t.offsetHeight), i = !1, x(t).parents().each(function () {
          return !(i |= "fixed" === x(this).css("position"))
        }), n = {
          left: x.datepicker._pos[0],
          top: x.datepicker._pos[1]
        }, x.datepicker._pos = null, e.dpDiv.empty(), e.dpDiv.css({
          position: "absolute",
          display: "block",
          top: "-1000px"
        }), x.datepicker._updateDatepicker(e), n = x.datepicker._checkOffset(e, n, i), e.dpDiv.css({
          position: x.datepicker._inDialog && x.blockUI ? "static" : i ? "fixed" : "absolute",
          display: "none",
          left: n.left + "px",
          top: n.top + "px"
        }), e.inline || (s = x.datepicker._get(e, "showAnim"), n = x.datepicker._get(e, "duration"), e.dpDiv.css("z-index", function (t) {
          for (var e, i; t.length && t[0] !== document;) {
            if (("absolute" === (e = t.css("position")) || "relative" === e || "fixed" === e) && (i = parseInt(t.css("zIndex"), 10), !isNaN(i) && 0 !== i)) return i;
            t = t.parent()
          }
          return 0
        }(x(t)) + 1), x.datepicker._datepickerShowing = !0, x.effects && x.effects.effect[s] ? e.dpDiv.show(s, x.datepicker._get(e, "showOptions"), n) : e.dpDiv[s || "show"](s ? n : null), x.datepicker._shouldFocusInput(e) && e.input.trigger("focus"), x.datepicker._curInst = e)))
      },
      _updateDatepicker: function (t) {
        this.maxRows = 4, (X = t).dpDiv.empty().append(this._generateHTML(t)), this._attachHandlers(t);
        var e, i = this._getNumberOfMonths(t),
          s = i[1],
          n = t.dpDiv.find("." + this._dayOverClass + " a");
        0 < n.length && J.apply(n.get(0)), t.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), 1 < s && t.dpDiv.addClass("ui-datepicker-multi-" + s).css("width", 17 * s + "em"), t.dpDiv[(1 !== i[0] || 1 !== i[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), t.dpDiv[(this._get(t, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), t === x.datepicker._curInst && x.datepicker._datepickerShowing && x.datepicker._shouldFocusInput(t) && t.input.trigger("focus"), t.yearshtml && (e = t.yearshtml, setTimeout(function () {
          e === t.yearshtml && t.yearshtml && t.dpDiv.find("select.ui-datepicker-year:first").replaceWith(t.yearshtml), e = t.yearshtml = null
        }, 0))
      },
      _shouldFocusInput: function (t) {
        return t.input && t.input.is(":visible") && !t.input.is(":disabled") && !t.input.is(":focus")
      },
      _checkOffset: function (t, e, i) {
        var s = t.dpDiv.outerWidth(),
          n = t.dpDiv.outerHeight(),
          a = t.input ? t.input.outerWidth() : 0,
          o = t.input ? t.input.outerHeight() : 0,
          r = document.documentElement.clientWidth + (i ? 0 : x(document).scrollLeft()),
          l = document.documentElement.clientHeight + (i ? 0 : x(document).scrollTop());
        return e.left -= this._get(t, "isRTL") ? s - a : 0, e.left -= i && e.left === t.input.offset().left ? x(document).scrollLeft() : 0, e.top -= i && e.top === t.input.offset().top + o ? x(document).scrollTop() : 0, e.left -= Math.min(e.left, e.left + s > r && s < r ? Math.abs(e.left + s - r) : 0), e.top -= Math.min(e.top, e.top + n > l && n < l ? Math.abs(n + o) : 0), e
      },
      _findPos: function (t) {
        for (var e = this._getInst(t), i = this._get(e, "isRTL"); t && ("hidden" === t.type || 1 !== t.nodeType || x.expr.filters.hidden(t));) t = t[i ? "previousSibling" : "nextSibling"];
        return [(e = x(t).offset()).left, e.top]
      },
      _hideDatepicker: function (t) {
        var e, i, s = this._curInst;
        !s || t && s !== x.data(t, "datepicker") || this._datepickerShowing && (e = this._get(s, "showAnim"), i = this._get(s, "duration"), t = function () {
          x.datepicker._tidyDialog(s)
        }, x.effects && (x.effects.effect[e] || x.effects[e]) ? s.dpDiv.hide(e, x.datepicker._get(s, "showOptions"), i, t) : s.dpDiv["slideDown" === e ? "slideUp" : "fadeIn" === e ? "fadeOut" : "hide"](e ? i : null, t), e || t(), this._datepickerShowing = !1, (t = this._get(s, "onClose")) && t.apply(s.input ? s.input[0] : null, [s.input ? s.input.val() : "", s]), this._lastInput = null, this._inDialog && (this._dialogInput.css({
          position: "absolute",
          left: "0",
          top: "-100px"
        }), x.blockUI && (x.unblockUI(), x("body").append(this.dpDiv))), this._inDialog = !1)
      },
      _tidyDialog: function (t) {
        t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")
      },
      _checkExternalClick: function (t) {
        var e;
        x.datepicker._curInst && (e = x(t.target), t = x.datepicker._getInst(e[0]), (e[0].id === x.datepicker._mainDivId || 0 !== e.parents("#" + x.datepicker._mainDivId).length || e.hasClass(x.datepicker.markerClassName) || e.closest("." + x.datepicker._triggerClass).length || !x.datepicker._datepickerShowing || x.datepicker._inDialog && x.blockUI) && (!e.hasClass(x.datepicker.markerClassName) || x.datepicker._curInst === t) || x.datepicker._hideDatepicker())
      },
      _adjustDate: function (t, e, i) {
        var s = x(t),
          t = this._getInst(s[0]);
        this._isDisabledDatepicker(s[0]) || (this._adjustInstDate(t, e + ("M" === i ? this._get(t, "showCurrentAtPos") : 0), i), this._updateDatepicker(t))
      },
      _gotoToday: function (t) {
        var e = x(t),
          i = this._getInst(e[0]);
        this._get(i, "gotoCurrent") && i.currentDay ? (i.selectedDay = i.currentDay, i.drawMonth = i.selectedMonth = i.currentMonth, i.drawYear = i.selectedYear = i.currentYear) : (t = new Date, i.selectedDay = t.getDate(), i.drawMonth = i.selectedMonth = t.getMonth(), i.drawYear = i.selectedYear = t.getFullYear()), this._notifyChange(i), this._adjustDate(e)
      },
      _selectMonthYear: function (t, e, i) {
        var s = x(t),
          t = this._getInst(s[0]);
        t["selected" + ("M" === i ? "Month" : "Year")] = t["draw" + ("M" === i ? "Month" : "Year")] = parseInt(e.options[e.selectedIndex].value, 10), this._notifyChange(t), this._adjustDate(s)
      },
      _selectDay: function (t, e, i, s) {
        var n = x(t);
        x(s).hasClass(this._unselectableClass) || this._isDisabledDatepicker(n[0]) || ((n = this._getInst(n[0])).selectedDay = n.currentDay = x("a", s).html(), n.selectedMonth = n.currentMonth = e, n.selectedYear = n.currentYear = i, this._selectDate(t, this._formatDate(n, n.currentDay, n.currentMonth, n.currentYear)))
      },
      _clearDate: function (t) {
        t = x(t);
        this._selectDate(t, "")
      },
      _selectDate: function (t, e) {
        var i = x(t),
          t = this._getInst(i[0]);
        e = null != e ? e : this._formatDate(t), t.input && t.input.val(e), this._updateAlternate(t), (i = this._get(t, "onSelect")) ? i.apply(t.input ? t.input[0] : null, [e, t]) : t.input && t.input.trigger("change"), t.inline ? this._updateDatepicker(t) : (this._hideDatepicker(), this._lastInput = t.input[0], "object" != typeof t.input[0] && t.input.trigger("focus"), this._lastInput = null)
      },
      _updateAlternate: function (t) {
        var e, i, s = this._get(t, "altField");
        s && (e = this._get(t, "altFormat") || this._get(t, "dateFormat"), i = this._getDate(t), t = this.formatDate(e, i, this._getFormatConfig(t)), x(s).val(t))
      },
      noWeekends: function (t) {
        t = t.getDay();
        return [0 < t && t < 6, ""]
      },
      iso8601Week: function (t) {
        var e = new Date(t.getTime());
        return e.setDate(e.getDate() + 4 - (e.getDay() || 7)), t = e.getTime(), e.setMonth(0), e.setDate(1), Math.floor(Math.round((t - e) / 864e5) / 7) + 1
      },
      parseDate: function (e, n, t) {
        if (null == e || null == n) throw "Invalid arguments";
        if ("" === (n = "object" == typeof n ? n.toString() : n + "")) return null;

        function a(t) {
          return (t = w + 1 < e.length && e.charAt(w + 1) === t) && w++, t
        }

        function i(t) {
          var e = a(t),
            e = "@" === t ? 14 : "!" === t ? 20 : "y" === t && e ? 4 : "o" === t ? 3 : 2,
            e = new RegExp("^\\d{" + ("y" === t ? e : 1) + "," + e + "}");
          if (!(e = n.substring(d).match(e))) throw "Missing number at position " + d;
          return d += e[0].length, parseInt(e[0], 10)
        }

        function s(t, e, i) {
          var s = -1,
            e = x.map(a(t) ? i : e, function (t, e) {
              return [
                [e, t]
              ]
            }).sort(function (t, e) {
              return -(t[1].length - e[1].length)
            });
          if (x.each(e, function (t, e) {
              var i = e[1];
              if (n.substr(d, i.length).toLowerCase() === i.toLowerCase()) return s = e[0], d += i.length, !1
            }), -1 !== s) return s + 1;
          throw "Unknown name at position " + d
        }

        function o() {
          if (n.charAt(d) !== e.charAt(w)) throw "Unexpected literal at position " + d;
          d++
        }
        for (var r, l, c, d = 0, h = (t ? t.shortYearCutoff : null) || this._defaults.shortYearCutoff, h = "string" != typeof h ? h : (new Date).getFullYear() % 100 + parseInt(h, 10), u = (t ? t.dayNamesShort : null) || this._defaults.dayNamesShort, p = (t ? t.dayNames : null) || this._defaults.dayNames, f = (t ? t.monthNamesShort : null) || this._defaults.monthNamesShort, m = (t ? t.monthNames : null) || this._defaults.monthNames, g = -1, v = -1, b = -1, _ = -1, y = !1, w = 0; w < e.length; w++)
          if (y) "'" !== e.charAt(w) || a("'") ? o() : y = !1;
          else switch (e.charAt(w)) {
            case "d":
              b = i("d");
              break;
            case "D":
              s("D", u, p);
              break;
            case "o":
              _ = i("o");
              break;
            case "m":
              v = i("m");
              break;
            case "M":
              v = s("M", f, m);
              break;
            case "y":
              g = i("y");
              break;
            case "@":
              g = (c = new Date(i("@"))).getFullYear(), v = c.getMonth() + 1, b = c.getDate();
              break;
            case "!":
              g = (c = new Date((i("!") - this._ticksTo1970) / 1e4)).getFullYear(), v = c.getMonth() + 1, b = c.getDate();
              break;
            case "'":
              a("'") ? o() : y = !0;
              break;
            default:
              o()
          }
        if (d < n.length && (l = n.substr(d), !/^\s+/.test(l))) throw "Extra/unparsed characters found in date: " + l;
        if (-1 === g ? g = (new Date).getFullYear() : g < 100 && (g += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (g <= h ? 0 : -100)), -1 < _)
          for (v = 1, b = _; !(b <= (r = this._getDaysInMonth(g, v - 1)));) v++, b -= r;
        if ((c = this._daylightSavingAdjust(new Date(g, v - 1, b))).getFullYear() !== g || c.getMonth() + 1 !== v || c.getDate() !== b) throw "Invalid date";
        return c
      },
      ATOM: "yy-mm-dd",
      COOKIE: "D, dd M yy",
      ISO_8601: "yy-mm-dd",
      RFC_822: "D, d M y",
      RFC_850: "DD, dd-M-y",
      RFC_1036: "D, d M y",
      RFC_1123: "D, d M yy",
      RFC_2822: "D, d M yy",
      RSS: "D, d M y",
      TICKS: "!",
      TIMESTAMP: "@",
      W3C: "yy-mm-dd",
      _ticksTo1970: 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 60 * 60 * 1e7,
      formatDate: function (e, t, i) {
        if (!t) return "";

        function n(t) {
          return (t = o + 1 < e.length && e.charAt(o + 1) === t) && o++, t
        }

        function s(t, e, i) {
          var s = "" + e;
          if (n(t))
            for (; s.length < i;) s = "0" + s;
          return s
        }

        function a(t, e, i, s) {
          return (n(t) ? s : i)[e]
        }
        var o, r = (i ? i.dayNamesShort : null) || this._defaults.dayNamesShort,
          l = (i ? i.dayNames : null) || this._defaults.dayNames,
          c = (i ? i.monthNamesShort : null) || this._defaults.monthNamesShort,
          d = (i ? i.monthNames : null) || this._defaults.monthNames,
          h = "",
          u = !1;
        if (t)
          for (o = 0; o < e.length; o++)
            if (u) "'" !== e.charAt(o) || n("'") ? h += e.charAt(o) : u = !1;
            else switch (e.charAt(o)) {
              case "d":
                h += s("d", t.getDate(), 2);
                break;
              case "D":
                h += a("D", t.getDay(), r, l);
                break;
              case "o":
                h += s("o", Math.round((new Date(t.getFullYear(), t.getMonth(), t.getDate()).getTime() - new Date(t.getFullYear(), 0, 0).getTime()) / 864e5), 3);
                break;
              case "m":
                h += s("m", t.getMonth() + 1, 2);
                break;
              case "M":
                h += a("M", t.getMonth(), c, d);
                break;
              case "y":
                h += n("y") ? t.getFullYear() : (t.getFullYear() % 100 < 10 ? "0" : "") + t.getFullYear() % 100;
                break;
              case "@":
                h += t.getTime();
                break;
              case "!":
                h += 1e4 * t.getTime() + this._ticksTo1970;
                break;
              case "'":
                n("'") ? h += "'" : u = !0;
                break;
              default:
                h += e.charAt(o)
            }
        return h
      },
      _possibleChars: function (e) {
        function t(t) {
          return (t = n + 1 < e.length && e.charAt(n + 1) === t) && n++, t
        }
        for (var i = "", s = !1, n = 0; n < e.length; n++)
          if (s) "'" !== e.charAt(n) || t("'") ? i += e.charAt(n) : s = !1;
          else switch (e.charAt(n)) {
            case "d":
            case "m":
            case "y":
            case "@":
              i += "0123456789";
              break;
            case "D":
            case "M":
              return null;
            case "'":
              t("'") ? i += "'" : s = !0;
              break;
            default:
              i += e.charAt(n)
          }
        return i
      },
      _get: function (t, e) {
        return (void 0 !== t.settings[e] ? t.settings : this._defaults)[e]
      },
      _setDateFromField: function (t, e) {
        if (t.input.val() !== t.lastVal) {
          var i = this._get(t, "dateFormat"),
            s = t.lastVal = t.input ? t.input.val() : null,
            n = this._getDefaultDate(t),
            a = n,
            o = this._getFormatConfig(t);
          try {
            a = this.parseDate(i, s, o) || n
          } catch (t) {
            s = e ? "" : s
          }
          t.selectedDay = a.getDate(), t.drawMonth = t.selectedMonth = a.getMonth(), t.drawYear = t.selectedYear = a.getFullYear(), t.currentDay = s ? a.getDate() : 0, t.currentMonth = s ? a.getMonth() : 0, t.currentYear = s ? a.getFullYear() : 0, this._adjustInstDate(t)
        }
      },
      _getDefaultDate: function (t) {
        return this._restrictMinMax(t, this._determineDate(t, this._get(t, "defaultDate"), new Date))
      },
      _determineDate: function (r, t, e) {
        var i, s, t = null == t || "" === t ? e : "string" == typeof t ? function (t) {
          try {
            return x.datepicker.parseDate(x.datepicker._get(r, "dateFormat"), t, x.datepicker._getFormatConfig(r))
          } catch (t) {}
          for (var e = (t.toLowerCase().match(/^c/) ? x.datepicker._getDate(r) : null) || new Date, i = e.getFullYear(), s = e.getMonth(), n = e.getDate(), a = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, o = a.exec(t); o;) {
            switch (o[2] || "d") {
              case "d":
              case "D":
                n += parseInt(o[1], 10);
                break;
              case "w":
              case "W":
                n += 7 * parseInt(o[1], 10);
                break;
              case "m":
              case "M":
                s += parseInt(o[1], 10), n = Math.min(n, x.datepicker._getDaysInMonth(i, s));
                break;
              case "y":
              case "Y":
                i += parseInt(o[1], 10), n = Math.min(n, x.datepicker._getDaysInMonth(i, s))
            }
            o = a.exec(t)
          }
          return new Date(i, s, n)
        }(t) : "number" == typeof t ? isNaN(t) ? e : (i = t, (s = new Date).setDate(s.getDate() + i), s) : new Date(t.getTime());
        return (t = t && "Invalid Date" === t.toString() ? e : t) && (t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)), this._daylightSavingAdjust(t)
      },
      _daylightSavingAdjust: function (t) {
        return t ? (t.setHours(12 < t.getHours() ? t.getHours() + 2 : 0), t) : null
      },
      _setDate: function (t, e, i) {
        var s = !e,
          n = t.selectedMonth,
          a = t.selectedYear,
          e = this._restrictMinMax(t, this._determineDate(t, e, new Date));
        t.selectedDay = t.currentDay = e.getDate(), t.drawMonth = t.selectedMonth = t.currentMonth = e.getMonth(), t.drawYear = t.selectedYear = t.currentYear = e.getFullYear(), n === t.selectedMonth && a === t.selectedYear || i || this._notifyChange(t), this._adjustInstDate(t), t.input && t.input.val(s ? "" : this._formatDate(t))
      },
      _getDate: function (t) {
        return !t.currentYear || t.input && "" === t.input.val() ? null : this._daylightSavingAdjust(new Date(t.currentYear, t.currentMonth, t.currentDay))
      },
      _attachHandlers: function (t) {
        var e = this._get(t, "stepMonths"),
          i = "#" + t.id.replace(/\\\\/g, "\\");
        t.dpDiv.find("[data-handler]").map(function () {
          var t = {
            prev: function () {
              x.datepicker._adjustDate(i, -e, "M")
            },
            next: function () {
              x.datepicker._adjustDate(i, +e, "M")
            },
            hide: function () {
              x.datepicker._hideDatepicker()
            },
            today: function () {
              x.datepicker._gotoToday(i)
            },
            selectDay: function () {
              return x.datepicker._selectDay(i, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1
            },
            selectMonth: function () {
              return x.datepicker._selectMonthYear(i, this, "M"), !1
            },
            selectYear: function () {
              return x.datepicker._selectMonthYear(i, this, "Y"), !1
            }
          };
          x(this).on(this.getAttribute("data-event"), t[this.getAttribute("data-handler")])
        })
      },
      _generateHTML: function (t) {
        var e, i, s, n, a, o, r, l, c, d, h, u, p, f, m, g, v, b, _, y, w, x, C, k, T, D, S, M, E, A, P, I, O = new Date,
          $ = this._daylightSavingAdjust(new Date(O.getFullYear(), O.getMonth(), O.getDate())),
          L = this._get(t, "isRTL"),
          N = this._get(t, "showButtonPanel"),
          H = this._get(t, "hideIfNoPrevNext"),
          F = this._get(t, "navigationAsDateFormat"),
          z = this._getNumberOfMonths(t),
          R = this._get(t, "showCurrentAtPos"),
          O = this._get(t, "stepMonths"),
          B = 1 !== z[0] || 1 !== z[1],
          j = this._daylightSavingAdjust(t.currentDay ? new Date(t.currentYear, t.currentMonth, t.currentDay) : new Date(9999, 9, 9)),
          W = this._getMinMaxDate(t, "min"),
          V = this._getMinMaxDate(t, "max"),
          q = t.drawMonth - R,
          Y = t.drawYear;
        if (q < 0 && (q += 12, Y--), V)
          for (e = this._daylightSavingAdjust(new Date(V.getFullYear(), V.getMonth() - z[0] * z[1] + 1, V.getDate())), e = W && e < W ? W : e; this._daylightSavingAdjust(new Date(Y, q, 1)) > e;) --q < 0 && (q = 11, Y--);
        for (t.drawMonth = q, t.drawYear = Y, R = this._get(t, "prevText"), R = F ? this.formatDate(R, this._daylightSavingAdjust(new Date(Y, q - O, 1)), this._getFormatConfig(t)) : R, i = this._canAdjustMonth(t, -1, Y, q) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='" + R + "'><span class='ui-icon ui-icon-circle-triangle-" + (L ? "e" : "w") + "'>" + R + "</span></a>" : H ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + R + "'><span class='ui-icon ui-icon-circle-triangle-" + (L ? "e" : "w") + "'>" + R + "</span></a>", R = this._get(t, "nextText"), R = F ? this.formatDate(R, this._daylightSavingAdjust(new Date(Y, q + O, 1)), this._getFormatConfig(t)) : R, s = this._canAdjustMonth(t, 1, Y, q) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='" + R + "'><span class='ui-icon ui-icon-circle-triangle-" + (L ? "w" : "e") + "'>" + R + "</span></a>" : H ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + R + "'><span class='ui-icon ui-icon-circle-triangle-" + (L ? "w" : "e") + "'>" + R + "</span></a>", H = this._get(t, "currentText"), R = this._get(t, "gotoCurrent") && t.currentDay ? j : $, H = F ? this.formatDate(H, R, this._getFormatConfig(t)) : H, F = t.inline ? "" : "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(t, "closeText") + "</button>", F = N ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (L ? F : "") + (this._isInRange(t, R) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>" + H + "</button>" : "") + (L ? "" : F) + "</div>" : "", n = parseInt(this._get(t, "firstDay"), 10), n = isNaN(n) ? 0 : n, a = this._get(t, "showWeek"), o = this._get(t, "dayNames"), r = this._get(t, "dayNamesMin"), l = this._get(t, "monthNames"), c = this._get(t, "monthNamesShort"), d = this._get(t, "beforeShowDay"), h = this._get(t, "showOtherMonths"), u = this._get(t, "selectOtherMonths"), p = this._getDefaultDate(t), f = "", g = 0; g < z[0]; g++) {
          for (v = "", this.maxRows = 4, b = 0; b < z[1]; b++) {
            if (_ = this._daylightSavingAdjust(new Date(Y, q, t.selectedDay)), y = " ui-corner-all", w = "", B) {
              if (w += "<div class='ui-datepicker-group", 1 < z[1]) switch (b) {
                case 0:
                  w += " ui-datepicker-group-first", y = " ui-corner-" + (L ? "right" : "left");
                  break;
                case z[1] - 1:
                  w += " ui-datepicker-group-last", y = " ui-corner-" + (L ? "left" : "right");
                  break;
                default:
                  w += " ui-datepicker-group-middle", y = ""
              }
              w += "'>"
            }
            for (w += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + y + "'>" + (/all|left/.test(y) && 0 === g ? L ? s : i : "") + (/all|right/.test(y) && 0 === g ? L ? i : s : "") + this._generateMonthYearHeader(t, q, Y, W, V, 0 < g || 0 < b, l, c) + "</div><table class='ui-datepicker-calendar'><thead><tr>", x = a ? "<th class='ui-datepicker-week-col'>" + this._get(t, "weekHeader") + "</th>" : "", m = 0; m < 7; m++) x += "<th scope='col'" + (5 <= (m + n + 6) % 7 ? " class='ui-datepicker-week-end'" : "") + "><span title='" + o[C = (m + n) % 7] + "'>" + r[C] + "</span></th>";
            for (w += x + "</tr></thead><tbody>", T = this._getDaysInMonth(Y, q), Y === t.selectedYear && q === t.selectedMonth && (t.selectedDay = Math.min(t.selectedDay, T)), k = (this._getFirstDayOfMonth(Y, q) - n + 7) % 7, T = Math.ceil((k + T) / 7), D = B && this.maxRows > T ? this.maxRows : T, this.maxRows = D, S = this._daylightSavingAdjust(new Date(Y, q, 1 - k)), M = 0; M < D; M++) {
              for (w += "<tr>", E = a ? "<td class='ui-datepicker-week-col'>" + this._get(t, "calculateWeek")(S) + "</td>" : "", m = 0; m < 7; m++) A = d ? d.apply(t.input ? t.input[0] : null, [S]) : [!0, ""], I = (P = S.getMonth() !== q) && !u || !A[0] || W && S < W || V && V < S, E += "<td class='" + (5 <= (m + n + 6) % 7 ? " ui-datepicker-week-end" : "") + (P ? " ui-datepicker-other-month" : "") + (S.getTime() === _.getTime() && q === t.selectedMonth && t._keyEvent || p.getTime() === S.getTime() && p.getTime() === _.getTime() ? " " + this._dayOverClass : "") + (I ? " " + this._unselectableClass + " ui-state-disabled" : "") + (P && !h ? "" : " " + A[1] + (S.getTime() === j.getTime() ? " " + this._currentClass : "") + (S.getTime() === $.getTime() ? " ui-datepicker-today" : "")) + "'" + (P && !h || !A[2] ? "" : " title='" + A[2].replace(/'/g, "&#39;") + "'") + (I ? "" : " data-handler='selectDay' data-event='click' data-month='" + S.getMonth() + "' data-year='" + S.getFullYear() + "'") + ">" + (P && !h ? "&#xa0;" : I ? "<span class='ui-state-default'>" + S.getDate() + "</span>" : "<a class='ui-state-default" + (S.getTime() === $.getTime() ? " ui-state-highlight" : "") + (S.getTime() === j.getTime() ? " ui-state-active" : "") + (P ? " ui-priority-secondary" : "") + "' href='#'>" + S.getDate() + "</a>") + "</td>", S.setDate(S.getDate() + 1), S = this._daylightSavingAdjust(S);
              w += E + "</tr>"
            }
            11 < ++q && (q = 0, Y++), v += w += "</tbody></table>" + (B ? "</div>" + (0 < z[0] && b === z[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "")
          }
          f += v
        }
        return f += F, t._keyEvent = !1, f
      },
      _generateMonthYearHeader: function (t, e, i, s, n, a, o, r) {
        var l, c, d, h, u, p, f, m = this._get(t, "changeMonth"),
          g = this._get(t, "changeYear"),
          v = this._get(t, "showMonthAfterYear"),
          b = "<div class='ui-datepicker-title'>",
          _ = "";
        if (a || !m) _ += "<span class='ui-datepicker-month'>" + o[e] + "</span>";
        else {
          for (l = s && s.getFullYear() === i, c = n && n.getFullYear() === i, _ += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>", d = 0; d < 12; d++)(!l || d >= s.getMonth()) && (!c || d <= n.getMonth()) && (_ += "<option value='" + d + "'" + (d === e ? " selected='selected'" : "") + ">" + r[d] + "</option>");
          _ += "</select>"
        }
        if (v || (b += _ + (!a && m && g ? "" : "&#xa0;")), !t.yearshtml)
          if (t.yearshtml = "", a || !g) b += "<span class='ui-datepicker-year'>" + i + "</span>";
          else {
            for (h = this._get(t, "yearRange").split(":"), u = (new Date).getFullYear(), p = (o = function (t) {
                t = t.match(/c[+\-].*/) ? i + parseInt(t.substring(1), 10) : t.match(/[+\-].*/) ? u + parseInt(t, 10) : parseInt(t, 10);
                return isNaN(t) ? u : t
              })(h[0]), f = Math.max(p, o(h[1] || "")), p = s ? Math.max(p, s.getFullYear()) : p, f = n ? Math.min(f, n.getFullYear()) : f, t.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>"; p <= f; p++) t.yearshtml += "<option value='" + p + "'" + (p === i ? " selected='selected'" : "") + ">" + p + "</option>";
            t.yearshtml += "</select>", b += t.yearshtml, t.yearshtml = null
          } return b += this._get(t, "yearSuffix"), v && (b += (!a && m && g ? "" : "&#xa0;") + _), b + "</div>"
      },
      _adjustInstDate: function (t, e, i) {
        var s = t.selectedYear + ("Y" === i ? e : 0),
          n = t.selectedMonth + ("M" === i ? e : 0),
          e = Math.min(t.selectedDay, this._getDaysInMonth(s, n)) + ("D" === i ? e : 0),
          e = this._restrictMinMax(t, this._daylightSavingAdjust(new Date(s, n, e)));
        t.selectedDay = e.getDate(), t.drawMonth = t.selectedMonth = e.getMonth(), t.drawYear = t.selectedYear = e.getFullYear(), "M" !== i && "Y" !== i || this._notifyChange(t)
      },
      _restrictMinMax: function (t, e) {
        var i = this._getMinMaxDate(t, "min"),
          t = this._getMinMaxDate(t, "max"),
          e = i && e < i ? i : e;
        return t && t < e ? t : e
      },
      _notifyChange: function (t) {
        var e = this._get(t, "onChangeMonthYear");
        e && e.apply(t.input ? t.input[0] : null, [t.selectedYear, t.selectedMonth + 1, t])
      },
      _getNumberOfMonths: function (t) {
        t = this._get(t, "numberOfMonths");
        return null == t ? [1, 1] : "number" == typeof t ? [1, t] : t
      },
      _getMinMaxDate: function (t, e) {
        return this._determineDate(t, this._get(t, e + "Date"), null)
      },
      _getDaysInMonth: function (t, e) {
        return 32 - this._daylightSavingAdjust(new Date(t, e, 32)).getDate()
      },
      _getFirstDayOfMonth: function (t, e) {
        return new Date(t, e, 1).getDay()
      },
      _canAdjustMonth: function (t, e, i, s) {
        var n = this._getNumberOfMonths(t),
          n = this._daylightSavingAdjust(new Date(i, s + (e < 0 ? e : n[0] * n[1]), 1));
        return e < 0 && n.setDate(this._getDaysInMonth(n.getFullYear(), n.getMonth())), this._isInRange(t, n)
      },
      _isInRange: function (t, e) {
        var i = this._getMinMaxDate(t, "min"),
          s = this._getMinMaxDate(t, "max"),
          n = null,
          a = null,
          o = this._get(t, "yearRange");
        return o && (t = o.split(":"), o = (new Date).getFullYear(), n = parseInt(t[0], 10), a = parseInt(t[1], 10), t[0].match(/[+\-].*/) && (n += o), t[1].match(/[+\-].*/) && (a += o)), (!i || e.getTime() >= i.getTime()) && (!s || e.getTime() <= s.getTime()) && (!n || e.getFullYear() >= n) && (!a || e.getFullYear() <= a)
      },
      _getFormatConfig: function (t) {
        var e = this._get(t, "shortYearCutoff");
        return {
          shortYearCutoff: e = "string" != typeof e ? e : (new Date).getFullYear() % 100 + parseInt(e, 10),
          dayNamesShort: this._get(t, "dayNamesShort"),
          dayNames: this._get(t, "dayNames"),
          monthNamesShort: this._get(t, "monthNamesShort"),
          monthNames: this._get(t, "monthNames")
        }
      },
      _formatDate: function (t, e, i, s) {
        e || (t.currentDay = t.selectedDay, t.currentMonth = t.selectedMonth, t.currentYear = t.selectedYear);
        e = e ? "object" == typeof e ? e : this._daylightSavingAdjust(new Date(s, i, e)) : this._daylightSavingAdjust(new Date(t.currentYear, t.currentMonth, t.currentDay));
        return this.formatDate(this._get(t, "dateFormat"), e, this._getFormatConfig(t))
      }
    }), x.fn.datepicker = function (t) {
      if (!this.length) return this;
      x.datepicker.initialized || (x(document).on("mousedown", x.datepicker._checkExternalClick), x.datepicker.initialized = !0), 0 === x("#" + x.datepicker._mainDivId).length && x("body").append(x.datepicker.dpDiv);
      var e = Array.prototype.slice.call(arguments, 1);
      return "string" == typeof t && ("isDisabled" === t || "getDate" === t || "widget" === t) || "option" === t && 2 === arguments.length && "string" == typeof arguments[1] ? x.datepicker["_" + t + "Datepicker"].apply(x.datepicker, [this[0]].concat(e)) : this.each(function () {
        "string" == typeof t ? x.datepicker["_" + t + "Datepicker"].apply(x.datepicker, [this].concat(e)) : x.datepicker._attachDatepicker(this, t)
      })
    }, x.datepicker = new K, x.datepicker.initialized = !1, x.datepicker.uuid = (new Date).getTime(), x.datepicker.version = "1.12.1", x.datepicker, x.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    var tt = !1;
    x(document).on("mouseup", function () {
      tt = !1
    }), x.widget("ui.mouse", {
      version: "1.12.1",
      options: {
        cancel: "input, textarea, button, select, option",
        distance: 1,
        delay: 0
      },
      _mouseInit: function () {
        var e = this;
        this.element.on("mousedown." + this.widgetName, function (t) {
          return e._mouseDown(t)
        }).on("click." + this.widgetName, function (t) {
          if (!0 === x.data(t.target, e.widgetName + ".preventClickEvent")) return x.removeData(t.target, e.widgetName + ".preventClickEvent"), t.stopImmediatePropagation(), !1
        }), this.started = !1
      },
      _mouseDestroy: function () {
        this.element.off("." + this.widgetName), this._mouseMoveDelegate && this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate)
      },
      _mouseDown: function (t) {
        if (!tt) {
          this._mouseMoved = !1, this._mouseStarted && this._mouseUp(t), this._mouseDownEvent = t;
          var e = this,
            i = 1 === t.which,
            s = !("string" != typeof this.options.cancel || !t.target.nodeName) && x(t.target).closest(this.options.cancel).length;
          return !(i && !s && this._mouseCapture(t) && (this.mouseDelayMet = !this.options.delay, this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function () {
            e.mouseDelayMet = !0
          }, this.options.delay)), this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(t), !this._mouseStarted) ? t.preventDefault() : (!0 === x.data(t.target, this.widgetName + ".preventClickEvent") && x.removeData(t.target, this.widgetName + ".preventClickEvent"), this._mouseMoveDelegate = function (t) {
            return e._mouseMove(t)
          }, this._mouseUpDelegate = function (t) {
            return e._mouseUp(t)
          }, this.document.on("mousemove." + this.widgetName, this._mouseMoveDelegate).on("mouseup." + this.widgetName, this._mouseUpDelegate), t.preventDefault(), tt = !0), 0))
        }
      },
      _mouseMove: function (t) {
        if (this._mouseMoved) {
          if (x.ui.ie && (!document.documentMode || document.documentMode < 9) && !t.button) return this._mouseUp(t);
          if (!t.which)
            if (t.originalEvent.altKey || t.originalEvent.ctrlKey || t.originalEvent.metaKey || t.originalEvent.shiftKey) this.ignoreMissingWhich = !0;
            else if (!this.ignoreMissingWhich) return this._mouseUp(t)
        }
        return (t.which || t.button) && (this._mouseMoved = !0), this._mouseStarted ? (this._mouseDrag(t), t.preventDefault()) : (this._mouseDistanceMet(t) && this._mouseDelayMet(t) && (this._mouseStarted = !1 !== this._mouseStart(this._mouseDownEvent, t), this._mouseStarted ? this._mouseDrag(t) : this._mouseUp(t)), !this._mouseStarted)
      },
      _mouseUp: function (t) {
        this.document.off("mousemove." + this.widgetName, this._mouseMoveDelegate).off("mouseup." + this.widgetName, this._mouseUpDelegate), this._mouseStarted && (this._mouseStarted = !1, t.target === this._mouseDownEvent.target && x.data(t.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(t)), this._mouseDelayTimer && (clearTimeout(this._mouseDelayTimer), delete this._mouseDelayTimer), this.ignoreMissingWhich = !1, tt = !1, t.preventDefault()
      },
      _mouseDistanceMet: function (t) {
        return Math.max(Math.abs(this._mouseDownEvent.pageX - t.pageX), Math.abs(this._mouseDownEvent.pageY - t.pageY)) >= this.options.distance
      },
      _mouseDelayMet: function () {
        return this.mouseDelayMet
      },
      _mouseStart: function () {},
      _mouseDrag: function () {},
      _mouseStop: function () {},
      _mouseCapture: function () {
        return !0
      }
    }), x.ui.plugin = {
      add: function (t, e, i) {
        var s, n = x.ui[t].prototype;
        for (s in i) n.plugins[s] = n.plugins[s] || [], n.plugins[s].push([e, i[s]])
      },
      call: function (t, e, i, s) {
        var n, a = t.plugins[e];
        if (a && (s || t.element[0].parentNode && 11 !== t.element[0].parentNode.nodeType))
          for (n = 0; n < a.length; n++) t.options[a[n][0]] && a[n][1].apply(t.element, i)
      }
    }, x.ui.safeBlur = function (t) {
      t && "body" !== t.nodeName.toLowerCase() && x(t).trigger("blur")
    }, x.widget("ui.draggable", x.ui.mouse, {
      version: "1.12.1",
      widgetEventPrefix: "drag",
      options: {
        addClasses: !0,
        appendTo: "parent",
        axis: !1,
        connectToSortable: !1,
        containment: !1,
        cursor: "auto",
        cursorAt: !1,
        grid: !1,
        handle: !1,
        helper: "original",
        iframeFix: !1,
        opacity: !1,
        refreshPositions: !1,
        revert: !1,
        revertDuration: 500,
        scope: "default",
        scroll: !0,
        scrollSensitivity: 20,
        scrollSpeed: 20,
        snap: !1,
        snapMode: "both",
        snapTolerance: 20,
        stack: !1,
        zIndex: !1,
        drag: null,
        start: null,
        stop: null
      },
      _create: function () {
        "original" === this.options.helper && this._setPositionRelative(), this.options.addClasses && this._addClass("ui-draggable"), this._setHandleClassName(), this._mouseInit()
      },
      _setOption: function (t, e) {
        this._super(t, e), "handle" === t && (this._removeHandleClassName(), this._setHandleClassName())
      },
      _destroy: function () {
        (this.helper || this.element).is(".ui-draggable-dragging") ? this.destroyOnClear = !0 : (this._removeHandleClassName(), this._mouseDestroy())
      },
      _mouseCapture: function (t) {
        var e = this.options;
        return !(this.helper || e.disabled || 0 < x(t.target).closest(".ui-resizable-handle").length || (this.handle = this._getHandle(t), !this.handle || (this._blurActiveElement(t), this._blockFrames(!0 === e.iframeFix ? "iframe" : e.iframeFix), 0)))
      },
      _blockFrames: function (t) {
        this.iframeBlocks = this.document.find(t).map(function () {
          var t = x(this);
          return x("<div>").css("position", "absolute").appendTo(t.parent()).outerWidth(t.outerWidth()).outerHeight(t.outerHeight()).offset(t.offset())[0]
        })
      },
      _unblockFrames: function () {
        this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
      },
      _blurActiveElement: function (t) {
        var e = x.ui.safeActiveElement(this.document[0]);
        x(t.target).closest(e).length || x.ui.safeBlur(e)
      },
      _mouseStart: function (t) {
        var e = this.options;
        return this.helper = this._createHelper(t), this._addClass(this.helper, "ui-draggable-dragging"), this._cacheHelperProportions(), x.ui.ddmanager && (x.ui.ddmanager.current = this), this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(!0), this.offsetParent = this.helper.offsetParent(), this.hasFixedAncestor = 0 < this.helper.parents().filter(function () {
          return "fixed" === x(this).css("position")
        }).length, this.positionAbs = this.element.offset(), this._refreshOffsets(t), this.originalPosition = this.position = this._generatePosition(t, !1), this.originalPageX = t.pageX, this.originalPageY = t.pageY, e.cursorAt && this._adjustOffsetFromHelper(e.cursorAt), this._setContainment(), !1 === this._trigger("start", t) ? (this._clear(), !1) : (this._cacheHelperProportions(), x.ui.ddmanager && !e.dropBehaviour && x.ui.ddmanager.prepareOffsets(this, t), this._mouseDrag(t, !0), x.ui.ddmanager && x.ui.ddmanager.dragStart(this, t), !0)
      },
      _refreshOffsets: function (t) {
        this.offset = {
          top: this.positionAbs.top - this.margins.top,
          left: this.positionAbs.left - this.margins.left,
          scroll: !1,
          parent: this._getParentOffset(),
          relative: this._getRelativeOffset()
        }, this.offset.click = {
          left: t.pageX - this.offset.left,
          top: t.pageY - this.offset.top
        }
      },
      _mouseDrag: function (t, e) {
        if (this.hasFixedAncestor && (this.offset.parent = this._getParentOffset()), this.position = this._generatePosition(t, !0), this.positionAbs = this._convertPositionTo("absolute"), !e) {
          e = this._uiHash();
          if (!1 === this._trigger("drag", t, e)) return this._mouseUp(new x.Event("mouseup", t)), !1;
          this.position = e.position
        }
        return this.helper[0].style.left = this.position.left + "px", this.helper[0].style.top = this.position.top + "px", x.ui.ddmanager && x.ui.ddmanager.drag(this, t), !1
      },
      _mouseStop: function (t) {
        var e = this,
          i = !1;
        return x.ui.ddmanager && !this.options.dropBehaviour && (i = x.ui.ddmanager.drop(this, t)), this.dropped && (i = this.dropped, this.dropped = !1), "invalid" === this.options.revert && !i || "valid" === this.options.revert && i || !0 === this.options.revert || x.isFunction(this.options.revert) && this.options.revert.call(this.element, i) ? x(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
          !1 !== e._trigger("stop", t) && e._clear()
        }) : !1 !== this._trigger("stop", t) && this._clear(), !1
      },
      _mouseUp: function (t) {
        return this._unblockFrames(), x.ui.ddmanager && x.ui.ddmanager.dragStop(this, t), this.handleElement.is(t.target) && this.element.trigger("focus"), x.ui.mouse.prototype._mouseUp.call(this, t)
      },
      cancel: function () {
        return this.helper.is(".ui-draggable-dragging") ? this._mouseUp(new x.Event("mouseup", {
          target: this.element[0]
        })) : this._clear(), this
      },
      _getHandle: function (t) {
        return !this.options.handle || !!x(t.target).closest(this.element.find(this.options.handle)).length
      },
      _setHandleClassName: function () {
        this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element, this._addClass(this.handleElement, "ui-draggable-handle")
      },
      _removeHandleClassName: function () {
        this._removeClass(this.handleElement, "ui-draggable-handle")
      },
      _createHelper: function (t) {
        var e = this.options,
          i = x.isFunction(e.helper),
          t = i ? x(e.helper.apply(this.element[0], [t])) : "clone" === e.helper ? this.element.clone().removeAttr("id") : this.element;
        return t.parents("body").length || t.appendTo("parent" === e.appendTo ? this.element[0].parentNode : e.appendTo), i && t[0] === this.element[0] && this._setPositionRelative(), t[0] === this.element[0] || /(fixed|absolute)/.test(t.css("position")) || t.css("position", "absolute"), t
      },
      _setPositionRelative: function () {
        /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative")
      },
      _adjustOffsetFromHelper: function (t) {
        "string" == typeof t && (t = t.split(" ")), "left" in (t = x.isArray(t) ? {
          left: +t[0],
          top: +t[1] || 0
        } : t) && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
      },
      _isRootNode: function (t) {
        return /(html|body)/i.test(t.tagName) || t === this.document[0]
      },
      _getParentOffset: function () {
        var t = this.offsetParent.offset(),
          e = this.document[0];
        return "absolute" === this.cssPosition && this.scrollParent[0] !== e && x.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()), {
          top: (t = this._isRootNode(this.offsetParent[0]) ? {
            top: 0,
            left: 0
          } : t).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
          left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
        }
      },
      _getRelativeOffset: function () {
        if ("relative" !== this.cssPosition) return {
          top: 0,
          left: 0
        };
        var t = this.element.position(),
          e = this._isRootNode(this.scrollParent[0]);
        return {
          top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + (e ? 0 : this.scrollParent.scrollTop()),
          left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + (e ? 0 : this.scrollParent.scrollLeft())
        }
      },
      _cacheMargins: function () {
        this.margins = {
          left: parseInt(this.element.css("marginLeft"), 10) || 0,
          top: parseInt(this.element.css("marginTop"), 10) || 0,
          right: parseInt(this.element.css("marginRight"), 10) || 0,
          bottom: parseInt(this.element.css("marginBottom"), 10) || 0
        }
      },
      _cacheHelperProportions: function () {
        this.helperProportions = {
          width: this.helper.outerWidth(),
          height: this.helper.outerHeight()
        }
      },
      _setContainment: function () {
        var t, e, i, s = this.options,
          n = this.document[0];
        this.relativeContainer = null, s.containment ? "window" !== s.containment ? "document" !== s.containment ? s.containment.constructor !== Array ? ("parent" === s.containment && (s.containment = this.helper[0].parentNode), (i = (e = x(s.containment))[0]) && (t = /(scroll|auto)/.test(e.css("overflow")), this.containment = [(parseInt(e.css("borderLeftWidth"), 10) || 0) + (parseInt(e.css("paddingLeft"), 10) || 0), (parseInt(e.css("borderTopWidth"), 10) || 0) + (parseInt(e.css("paddingTop"), 10) || 0), (t ? Math.max(i.scrollWidth, i.offsetWidth) : i.offsetWidth) - (parseInt(e.css("borderRightWidth"), 10) || 0) - (parseInt(e.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (t ? Math.max(i.scrollHeight, i.offsetHeight) : i.offsetHeight) - (parseInt(e.css("borderBottomWidth"), 10) || 0) - (parseInt(e.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom], this.relativeContainer = e)) : this.containment = s.containment : this.containment = [0, 0, x(n).width() - this.helperProportions.width - this.margins.left, (x(n).height() || n.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top] : this.containment = [x(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, x(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, x(window).scrollLeft() + x(window).width() - this.helperProportions.width - this.margins.left, x(window).scrollTop() + (x(window).height() || n.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top] : this.containment = null
      },
      _convertPositionTo: function (t, e) {
        e = e || this.position;
        var i = "absolute" === t ? 1 : -1,
          t = this._isRootNode(this.scrollParent[0]);
        return {
          top: e.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.offset.scroll.top : t ? 0 : this.offset.scroll.top) * i,
          left: e.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.offset.scroll.left : t ? 0 : this.offset.scroll.left) * i
        }
      },
      _generatePosition: function (t, e) {
        var i, s = this.options,
          n = this._isRootNode(this.scrollParent[0]),
          a = t.pageX,
          o = t.pageY;
        return n && this.offset.scroll || (this.offset.scroll = {
          top: this.scrollParent.scrollTop(),
          left: this.scrollParent.scrollLeft()
        }), e && (this.containment && (i = this.relativeContainer ? (i = this.relativeContainer.offset(), [this.containment[0] + i.left, this.containment[1] + i.top, this.containment[2] + i.left, this.containment[3] + i.top]) : this.containment, t.pageX - this.offset.click.left < i[0] && (a = i[0] + this.offset.click.left), t.pageY - this.offset.click.top < i[1] && (o = i[1] + this.offset.click.top), t.pageX - this.offset.click.left > i[2] && (a = i[2] + this.offset.click.left), t.pageY - this.offset.click.top > i[3] && (o = i[3] + this.offset.click.top)), s.grid && (t = s.grid[1] ? this.originalPageY + Math.round((o - this.originalPageY) / s.grid[1]) * s.grid[1] : this.originalPageY, o = !i || t - this.offset.click.top >= i[1] || t - this.offset.click.top > i[3] ? t : t - this.offset.click.top >= i[1] ? t - s.grid[1] : t + s.grid[1], t = s.grid[0] ? this.originalPageX + Math.round((a - this.originalPageX) / s.grid[0]) * s.grid[0] : this.originalPageX, a = !i || t - this.offset.click.left >= i[0] || t - this.offset.click.left > i[2] ? t : t - this.offset.click.left >= i[0] ? t - s.grid[0] : t + s.grid[0]), "y" === s.axis && (a = this.originalPageX), "x" === s.axis && (o = this.originalPageY)), {
          top: o - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.offset.scroll.top : n ? 0 : this.offset.scroll.top),
          left: a - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.offset.scroll.left : n ? 0 : this.offset.scroll.left)
        }
      },
      _clear: function () {
        this._removeClass(this.helper, "ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), this.helper = null, this.cancelHelperRemoval = !1, this.destroyOnClear && this.destroy()
      },
      _trigger: function (t, e, i) {
        return i = i || this._uiHash(), x.ui.plugin.call(this, t, [e, i, this], !0), /^(drag|start|stop)/.test(t) && (this.positionAbs = this._convertPositionTo("absolute"), i.offset = this.positionAbs), x.Widget.prototype._trigger.call(this, t, e, i)
      },
      plugins: {},
      _uiHash: function () {
        return {
          helper: this.helper,
          position: this.position,
          originalPosition: this.originalPosition,
          offset: this.positionAbs
        }
      }
    }), x.ui.plugin.add("draggable", "connectToSortable", {
      start: function (e, t, i) {
        var s = x.extend({}, t, {
          item: i.element
        });
        i.sortables = [], x(i.options.connectToSortable).each(function () {
          var t = x(this).sortable("instance");
          t && !t.options.disabled && (i.sortables.push(t), t.refreshPositions(), t._trigger("activate", e, s))
        })
      },
      stop: function (t, e, i) {
        var s = x.extend({}, e, {
          item: i.element
        });
        i.cancelHelperRemoval = !1, x.each(i.sortables, function () {
          this.isOver ? (this.isOver = 0, i.cancelHelperRemoval = !0, this.cancelHelperRemoval = !1, this._storedCSS = {
            position: this.placeholder.css("position"),
            top: this.placeholder.css("top"),
            left: this.placeholder.css("left")
          }, this._mouseStop(t), this.options.helper = this.options._helper) : (this.cancelHelperRemoval = !0, this._trigger("deactivate", t, s))
        })
      },
      drag: function (i, s, n) {
        x.each(n.sortables, function () {
          var t = !1,
            e = this;
          e.positionAbs = n.positionAbs, e.helperProportions = n.helperProportions, e.offset.click = n.offset.click, e._intersectsWith(e.containerCache) && (t = !0, x.each(n.sortables, function () {
            return this.positionAbs = n.positionAbs, this.helperProportions = n.helperProportions, this.offset.click = n.offset.click, t = this !== e && this._intersectsWith(this.containerCache) && x.contains(e.element[0], this.element[0]) ? !1 : t
          })), t ? (e.isOver || (e.isOver = 1, n._parent = s.helper.parent(), e.currentItem = s.helper.appendTo(e.element).data("ui-sortable-item", !0), e.options._helper = e.options.helper, e.options.helper = function () {
            return s.helper[0]
          }, i.target = e.currentItem[0], e._mouseCapture(i, !0), e._mouseStart(i, !0, !0), e.offset.click.top = n.offset.click.top, e.offset.click.left = n.offset.click.left, e.offset.parent.left -= n.offset.parent.left - e.offset.parent.left, e.offset.parent.top -= n.offset.parent.top - e.offset.parent.top, n._trigger("toSortable", i), n.dropped = e.element, x.each(n.sortables, function () {
            this.refreshPositions()
          }), n.currentItem = n.element, e.fromOutside = n), e.currentItem && (e._mouseDrag(i), s.position = e.position)) : e.isOver && (e.isOver = 0, e.cancelHelperRemoval = !0, e.options._revert = e.options.revert, e.options.revert = !1, e._trigger("out", i, e._uiHash(e)), e._mouseStop(i, !0), e.options.revert = e.options._revert, e.options.helper = e.options._helper, e.placeholder && e.placeholder.remove(), s.helper.appendTo(n._parent), n._refreshOffsets(i), s.position = n._generatePosition(i, !0), n._trigger("fromSortable", i), n.dropped = !1, x.each(n.sortables, function () {
            this.refreshPositions()
          }))
        })
      }
    }), x.ui.plugin.add("draggable", "cursor", {
      start: function (t, e, i) {
        var s = x("body"),
          i = i.options;
        s.css("cursor") && (i._cursor = s.css("cursor")), s.css("cursor", i.cursor)
      },
      stop: function (t, e, i) {
        i = i.options;
        i._cursor && x("body").css("cursor", i._cursor)
      }
    }), x.ui.plugin.add("draggable", "opacity", {
      start: function (t, e, i) {
        e = x(e.helper), i = i.options;
        e.css("opacity") && (i._opacity = e.css("opacity")), e.css("opacity", i.opacity)
      },
      stop: function (t, e, i) {
        i = i.options;
        i._opacity && x(e.helper).css("opacity", i._opacity)
      }
    }), x.ui.plugin.add("draggable", "scroll", {
      start: function (t, e, i) {
        i.scrollParentNotHidden || (i.scrollParentNotHidden = i.helper.scrollParent(!1)), i.scrollParentNotHidden[0] !== i.document[0] && "HTML" !== i.scrollParentNotHidden[0].tagName && (i.overflowOffset = i.scrollParentNotHidden.offset())
      },
      drag: function (t, e, i) {
        var s = i.options,
          n = !1,
          a = i.scrollParentNotHidden[0],
          o = i.document[0];
        a !== o && "HTML" !== a.tagName ? (s.axis && "x" === s.axis || (i.overflowOffset.top + a.offsetHeight - t.pageY < s.scrollSensitivity ? a.scrollTop = n = a.scrollTop + s.scrollSpeed : t.pageY - i.overflowOffset.top < s.scrollSensitivity && (a.scrollTop = n = a.scrollTop - s.scrollSpeed)), s.axis && "y" === s.axis || (i.overflowOffset.left + a.offsetWidth - t.pageX < s.scrollSensitivity ? a.scrollLeft = n = a.scrollLeft + s.scrollSpeed : t.pageX - i.overflowOffset.left < s.scrollSensitivity && (a.scrollLeft = n = a.scrollLeft - s.scrollSpeed))) : (s.axis && "x" === s.axis || (t.pageY - x(o).scrollTop() < s.scrollSensitivity ? n = x(o).scrollTop(x(o).scrollTop() - s.scrollSpeed) : x(window).height() - (t.pageY - x(o).scrollTop()) < s.scrollSensitivity && (n = x(o).scrollTop(x(o).scrollTop() + s.scrollSpeed))), s.axis && "y" === s.axis || (t.pageX - x(o).scrollLeft() < s.scrollSensitivity ? n = x(o).scrollLeft(x(o).scrollLeft() - s.scrollSpeed) : x(window).width() - (t.pageX - x(o).scrollLeft()) < s.scrollSensitivity && (n = x(o).scrollLeft(x(o).scrollLeft() + s.scrollSpeed)))), !1 !== n && x.ui.ddmanager && !s.dropBehaviour && x.ui.ddmanager.prepareOffsets(i, t)
      }
    }), x.ui.plugin.add("draggable", "snap", {
      start: function (t, e, i) {
        var s = i.options;
        i.snapElements = [], x(s.snap.constructor !== String ? s.snap.items || ":data(ui-draggable)" : s.snap).each(function () {
          var t = x(this),
            e = t.offset();
          this !== i.element[0] && i.snapElements.push({
            item: this,
            width: t.outerWidth(),
            height: t.outerHeight(),
            top: e.top,
            left: e.left
          })
        })
      },
      drag: function (t, e, i) {
        for (var s, n, a, o, r, l, c, d, h, u = i.options, p = u.snapTolerance, f = e.offset.left, m = f + i.helperProportions.width, g = e.offset.top, v = g + i.helperProportions.height, b = i.snapElements.length - 1; 0 <= b; b--) l = (r = i.snapElements[b].left - i.margins.left) + i.snapElements[b].width, d = (c = i.snapElements[b].top - i.margins.top) + i.snapElements[b].height, m < r - p || l + p < f || v < c - p || d + p < g || !x.contains(i.snapElements[b].item.ownerDocument, i.snapElements[b].item) ? (i.snapElements[b].snapping && i.options.snap.release && i.options.snap.release.call(i.element, t, x.extend(i._uiHash(), {
          snapItem: i.snapElements[b].item
        })), i.snapElements[b].snapping = !1) : ("inner" !== u.snapMode && (s = Math.abs(c - v) <= p, n = Math.abs(d - g) <= p, a = Math.abs(r - m) <= p, o = Math.abs(l - f) <= p, s && (e.position.top = i._convertPositionTo("relative", {
          top: c - i.helperProportions.height,
          left: 0
        }).top), n && (e.position.top = i._convertPositionTo("relative", {
          top: d,
          left: 0
        }).top), a && (e.position.left = i._convertPositionTo("relative", {
          top: 0,
          left: r - i.helperProportions.width
        }).left), o && (e.position.left = i._convertPositionTo("relative", {
          top: 0,
          left: l
        }).left)), h = s || n || a || o, "outer" !== u.snapMode && (s = Math.abs(c - g) <= p, n = Math.abs(d - v) <= p, a = Math.abs(r - f) <= p, o = Math.abs(l - m) <= p, s && (e.position.top = i._convertPositionTo("relative", {
          top: c,
          left: 0
        }).top), n && (e.position.top = i._convertPositionTo("relative", {
          top: d - i.helperProportions.height,
          left: 0
        }).top), a && (e.position.left = i._convertPositionTo("relative", {
          top: 0,
          left: r
        }).left), o && (e.position.left = i._convertPositionTo("relative", {
          top: 0,
          left: l - i.helperProportions.width
        }).left)), !i.snapElements[b].snapping && (s || n || a || o || h) && i.options.snap.snap && i.options.snap.snap.call(i.element, t, x.extend(i._uiHash(), {
          snapItem: i.snapElements[b].item
        })), i.snapElements[b].snapping = s || n || a || o || h)
      }
    }), x.ui.plugin.add("draggable", "stack", {
      start: function (t, e, i) {
        var s, i = i.options,
          i = x.makeArray(x(i.stack)).sort(function (t, e) {
            return (parseInt(x(t).css("zIndex"), 10) || 0) - (parseInt(x(e).css("zIndex"), 10) || 0)
          });
        i.length && (s = parseInt(x(i[0]).css("zIndex"), 10) || 0, x(i).each(function (t) {
          x(this).css("zIndex", s + t)
        }), this.css("zIndex", s + i.length))
      }
    }), x.ui.plugin.add("draggable", "zIndex", {
      start: function (t, e, i) {
        e = x(e.helper), i = i.options;
        e.css("zIndex") && (i._zIndex = e.css("zIndex")), e.css("zIndex", i.zIndex)
      },
      stop: function (t, e, i) {
        i = i.options;
        i._zIndex && x(e.helper).css("zIndex", i._zIndex)
      }
    }), x.ui.draggable, x.widget("ui.resizable", x.ui.mouse, {
      version: "1.12.1",
      widgetEventPrefix: "resize",
      options: {
        alsoResize: !1,
        animate: !1,
        animateDuration: "slow",
        animateEasing: "swing",
        aspectRatio: !1,
        autoHide: !1,
        classes: {
          "ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
        },
        containment: !1,
        ghost: !1,
        grid: !1,
        handles: "e,s,se",
        helper: !1,
        maxHeight: null,
        maxWidth: null,
        minHeight: 10,
        minWidth: 10,
        zIndex: 90,
        resize: null,
        start: null,
        stop: null
      },
      _num: function (t) {
        return parseFloat(t) || 0
      },
      _isNumber: function (t) {
        return !isNaN(parseFloat(t))
      },
      _hasScroll: function (t, e) {
        if ("hidden" === x(t).css("overflow")) return !1;
        var i = e && "left" === e ? "scrollLeft" : "scrollTop";
        return 0 < t[i] || (t[i] = 1, e = 0 < t[i], t[i] = 0, e)
      },
      _create: function () {
        var t, e = this.options,
          i = this;
        this._addClass("ui-resizable"), x.extend(this, {
          _aspectRatio: !!e.aspectRatio,
          aspectRatio: e.aspectRatio,
          originalElement: this.element,
          _proportionallyResizeElements: [],
          _helper: e.helper || e.ghost || e.animate ? e.helper || "ui-resizable-helper" : null
        }), this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i) && (this.element.wrap(x("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
          position: this.element.css("position"),
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          top: this.element.css("top"),
          left: this.element.css("left")
        })), this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance")), this.elementIsWrapper = !0, t = {
          marginTop: this.originalElement.css("marginTop"),
          marginRight: this.originalElement.css("marginRight"),
          marginBottom: this.originalElement.css("marginBottom"),
          marginLeft: this.originalElement.css("marginLeft")
        }, this.element.css(t), this.originalElement.css("margin", 0), this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), this._proportionallyResizeElements.push(this.originalElement.css({
          position: "static",
          zoom: 1,
          display: "block"
        })), this.originalElement.css(t), this._proportionallyResize()), this._setupHandles(), e.autoHide && x(this.element).on("mouseenter", function () {
          e.disabled || (i._removeClass("ui-resizable-autohide"), i._handles.show())
        }).on("mouseleave", function () {
          e.disabled || i.resizing || (i._addClass("ui-resizable-autohide"), i._handles.hide())
        }), this._mouseInit()
      },
      _destroy: function () {
        this._mouseDestroy();

        function t(t) {
          x(t).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()
        }
        var e;
        return this.elementIsWrapper && (t(this.element), e = this.element, this.originalElement.css({
          position: e.css("position"),
          width: e.outerWidth(),
          height: e.outerHeight(),
          top: e.css("top"),
          left: e.css("left")
        }).insertAfter(e), e.remove()), this.originalElement.css("resize", this.originalResizeStyle), t(this.originalElement), this
      },
      _setOption: function (t, e) {
        "handles" === (this._super(t, e), t) && (this._removeHandles(), this._setupHandles())
      },
      _setupHandles: function () {
        var t, e, i, s, n, a = this.options,
          o = this;
        if (this.handles = a.handles || (x(".ui-resizable-handle", this.element).length ? {
            n: ".ui-resizable-n",
            e: ".ui-resizable-e",
            s: ".ui-resizable-s",
            w: ".ui-resizable-w",
            se: ".ui-resizable-se",
            sw: ".ui-resizable-sw",
            ne: ".ui-resizable-ne",
            nw: ".ui-resizable-nw"
          } : "e,s,se"), this._handles = x(), this.handles.constructor === String)
          for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), i = this.handles.split(","), this.handles = {}, e = 0; e < i.length; e++) s = "ui-resizable-" + (t = x.trim(i[e])), n = x("<div>"), this._addClass(n, "ui-resizable-handle " + s), n.css({
            zIndex: a.zIndex
          }), this.handles[t] = ".ui-resizable-" + t, this.element.append(n);
        this._renderAxis = function (t) {
          var e, i, s;
          for (e in t = t || this.element, this.handles) this.handles[e].constructor === String ? this.handles[e] = this.element.children(this.handles[e]).first().show() : (this.handles[e].jquery || this.handles[e].nodeType) && (this.handles[e] = x(this.handles[e]), this._on(this.handles[e], {
            mousedown: o._mouseDown
          })), this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i) && (i = x(this.handles[e], this.element), s = /sw|ne|nw|se|n|s/.test(e) ? i.outerHeight() : i.outerWidth(), i = ["padding", /ne|nw|n/.test(e) ? "Top" : /se|sw|s/.test(e) ? "Bottom" : /^e$/.test(e) ? "Right" : "Left"].join(""), t.css(i, s), this._proportionallyResize()), this._handles = this._handles.add(this.handles[e])
        }, this._renderAxis(this.element), this._handles = this._handles.add(this.element.find(".ui-resizable-handle")), this._handles.disableSelection(), this._handles.on("mouseover", function () {
          o.resizing || (this.className && (n = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), o.axis = n && n[1] ? n[1] : "se")
        }), a.autoHide && (this._handles.hide(), this._addClass("ui-resizable-autohide"))
      },
      _removeHandles: function () {
        this._handles.remove()
      },
      _mouseCapture: function (t) {
        var e, i, s = !1;
        for (e in this.handles)(i = x(this.handles[e])[0]) !== t.target && !x.contains(i, t.target) || (s = !0);
        return !this.options.disabled && s
      },
      _mouseStart: function (t) {
        var e, i, s = this.options,
          n = this.element;
        return this.resizing = !0, this._renderProxy(), e = this._num(this.helper.css("left")), i = this._num(this.helper.css("top")), s.containment && (e += x(s.containment).scrollLeft() || 0, i += x(s.containment).scrollTop() || 0), this.offset = this.helper.offset(), this.position = {
          left: e,
          top: i
        }, this.size = this._helper ? {
          width: this.helper.width(),
          height: this.helper.height()
        } : {
          width: n.width(),
          height: n.height()
        }, this.originalSize = this._helper ? {
          width: n.outerWidth(),
          height: n.outerHeight()
        } : {
          width: n.width(),
          height: n.height()
        }, this.sizeDiff = {
          width: n.outerWidth() - n.width(),
          height: n.outerHeight() - n.height()
        }, this.originalPosition = {
          left: e,
          top: i
        }, this.originalMousePosition = {
          left: t.pageX,
          top: t.pageY
        }, this.aspectRatio = "number" == typeof s.aspectRatio ? s.aspectRatio : this.originalSize.width / this.originalSize.height || 1, s = x(".ui-resizable-" + this.axis).css("cursor"), x("body").css("cursor", "auto" === s ? this.axis + "-resize" : s), this._addClass("ui-resizable-resizing"), this._propagate("start", t), !0
      },
      _mouseDrag: function (t) {
        var e = this.originalMousePosition,
          i = this.axis,
          s = t.pageX - e.left || 0,
          e = t.pageY - e.top || 0,
          i = this._change[i];
        return this._updatePrevProperties(), !!i && (e = i.apply(this, [t, s, e]), this._updateVirtualBoundaries(t.shiftKey), (this._aspectRatio || t.shiftKey) && (e = this._updateRatio(e, t)), e = this._respectSize(e, t), this._updateCache(e), this._propagate("resize", t), e = this._applyChanges(), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), x.isEmptyObject(e) || (this._updatePrevProperties(), this._trigger("resize", t, this.ui()), this._applyChanges()), !1)
      },
      _mouseStop: function (t) {
        this.resizing = !1;
        var e, i, s, n = this.options;
        return this._helper && (s = (e = (i = this._proportionallyResizeElements).length && /textarea/i.test(i[0].nodeName)) && this._hasScroll(i[0], "left") ? 0 : this.sizeDiff.height, i = e ? 0 : this.sizeDiff.width, e = {
          width: this.helper.width() - i,
          height: this.helper.height() - s
        }, i = parseFloat(this.element.css("left")) + (this.position.left - this.originalPosition.left) || null, s = parseFloat(this.element.css("top")) + (this.position.top - this.originalPosition.top) || null, n.animate || this.element.css(x.extend(e, {
          top: s,
          left: i
        })), this.helper.height(this.size.height), this.helper.width(this.size.width), this._helper && !n.animate && this._proportionallyResize()), x("body").css("cursor", "auto"), this._removeClass("ui-resizable-resizing"), this._propagate("stop", t), this._helper && this.helper.remove(), !1
      },
      _updatePrevProperties: function () {
        this.prevPosition = {
          top: this.position.top,
          left: this.position.left
        }, this.prevSize = {
          width: this.size.width,
          height: this.size.height
        }
      },
      _applyChanges: function () {
        var t = {};
        return this.position.top !== this.prevPosition.top && (t.top = this.position.top + "px"), this.position.left !== this.prevPosition.left && (t.left = this.position.left + "px"), this.size.width !== this.prevSize.width && (t.width = this.size.width + "px"), this.size.height !== this.prevSize.height && (t.height = this.size.height + "px"), this.helper.css(t), t
      },
      _updateVirtualBoundaries: function (t) {
        var e, i, s = this.options,
          n = {
            minWidth: this._isNumber(s.minWidth) ? s.minWidth : 0,
            maxWidth: this._isNumber(s.maxWidth) ? s.maxWidth : 1 / 0,
            minHeight: this._isNumber(s.minHeight) ? s.minHeight : 0,
            maxHeight: this._isNumber(s.maxHeight) ? s.maxHeight : 1 / 0
          };
        (this._aspectRatio || t) && (e = n.minHeight * this.aspectRatio, i = n.minWidth / this.aspectRatio, s = n.maxHeight * this.aspectRatio, t = n.maxWidth / this.aspectRatio, e > n.minWidth && (n.minWidth = e), i > n.minHeight && (n.minHeight = i), s < n.maxWidth && (n.maxWidth = s), t < n.maxHeight && (n.maxHeight = t)), this._vBoundaries = n
      },
      _updateCache: function (t) {
        this.offset = this.helper.offset(), this._isNumber(t.left) && (this.position.left = t.left), this._isNumber(t.top) && (this.position.top = t.top), this._isNumber(t.height) && (this.size.height = t.height), this._isNumber(t.width) && (this.size.width = t.width)
      },
      _updateRatio: function (t) {
        var e = this.position,
          i = this.size,
          s = this.axis;
        return this._isNumber(t.height) ? t.width = t.height * this.aspectRatio : this._isNumber(t.width) && (t.height = t.width / this.aspectRatio), "sw" === s && (t.left = e.left + (i.width - t.width), t.top = null), "nw" === s && (t.top = e.top + (i.height - t.height), t.left = e.left + (i.width - t.width)), t
      },
      _respectSize: function (t) {
        var e = this._vBoundaries,
          i = this.axis,
          s = this._isNumber(t.width) && e.maxWidth && e.maxWidth < t.width,
          n = this._isNumber(t.height) && e.maxHeight && e.maxHeight < t.height,
          a = this._isNumber(t.width) && e.minWidth && e.minWidth > t.width,
          o = this._isNumber(t.height) && e.minHeight && e.minHeight > t.height,
          r = this.originalPosition.left + this.originalSize.width,
          l = this.originalPosition.top + this.originalSize.height,
          c = /sw|nw|w/.test(i),
          i = /nw|ne|n/.test(i);
        return a && (t.width = e.minWidth), o && (t.height = e.minHeight), s && (t.width = e.maxWidth), n && (t.height = e.maxHeight), a && c && (t.left = r - e.minWidth), s && c && (t.left = r - e.maxWidth), o && i && (t.top = l - e.minHeight), n && i && (t.top = l - e.maxHeight), t.width || t.height || t.left || !t.top ? t.width || t.height || t.top || !t.left || (t.left = null) : t.top = null, t
      },
      _getPaddingPlusBorderDimensions: function (t) {
        for (var e = 0, i = [], s = [t.css("borderTopWidth"), t.css("borderRightWidth"), t.css("borderBottomWidth"), t.css("borderLeftWidth")], n = [t.css("paddingTop"), t.css("paddingRight"), t.css("paddingBottom"), t.css("paddingLeft")]; e < 4; e++) i[e] = parseFloat(s[e]) || 0, i[e] += parseFloat(n[e]) || 0;
        return {
          height: i[0] + i[2],
          width: i[1] + i[3]
        }
      },
      _proportionallyResize: function () {
        if (this._proportionallyResizeElements.length)
          for (var t, e = 0, i = this.helper || this.element; e < this._proportionallyResizeElements.length; e++) t = this._proportionallyResizeElements[e], this.outerDimensions || (this.outerDimensions = this._getPaddingPlusBorderDimensions(t)), t.css({
            height: i.height() - this.outerDimensions.height || 0,
            width: i.width() - this.outerDimensions.width || 0
          })
      },
      _renderProxy: function () {
        var t = this.element,
          e = this.options;
        this.elementOffset = t.offset(), this._helper ? (this.helper = this.helper || x("<div style='overflow:hidden;'></div>"), this._addClass(this.helper, this._helper), this.helper.css({
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          position: "absolute",
          left: this.elementOffset.left + "px",
          top: this.elementOffset.top + "px",
          zIndex: ++e.zIndex
        }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element
      },
      _change: {
        e: function (t, e) {
          return {
            width: this.originalSize.width + e
          }
        },
        w: function (t, e) {
          var i = this.originalSize;
          return {
            left: this.originalPosition.left + e,
            width: i.width - e
          }
        },
        n: function (t, e, i) {
          var s = this.originalSize;
          return {
            top: this.originalPosition.top + i,
            height: s.height - i
          }
        },
        s: function (t, e, i) {
          return {
            height: this.originalSize.height + i
          }
        },
        se: function (t, e, i) {
          return x.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [t, e, i]))
        },
        sw: function (t, e, i) {
          return x.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [t, e, i]))
        },
        ne: function (t, e, i) {
          return x.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [t, e, i]))
        },
        nw: function (t, e, i) {
          return x.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [t, e, i]))
        }
      },
      _propagate: function (t, e) {
        x.ui.plugin.call(this, t, [e, this.ui()]), "resize" !== t && this._trigger(t, e, this.ui())
      },
      plugins: {},
      ui: function () {
        return {
          originalElement: this.originalElement,
          element: this.element,
          helper: this.helper,
          position: this.position,
          size: this.size,
          originalSize: this.originalSize,
          originalPosition: this.originalPosition
        }
      }
    }), x.ui.plugin.add("resizable", "animate", {
      stop: function (e) {
        var i = x(this).resizable("instance"),
          t = i.options,
          s = i._proportionallyResizeElements,
          n = s.length && /textarea/i.test(s[0].nodeName),
          a = n && i._hasScroll(s[0], "left") ? 0 : i.sizeDiff.height,
          o = n ? 0 : i.sizeDiff.width,
          n = {
            width: i.size.width - o,
            height: i.size.height - a
          },
          o = parseFloat(i.element.css("left")) + (i.position.left - i.originalPosition.left) || null,
          a = parseFloat(i.element.css("top")) + (i.position.top - i.originalPosition.top) || null;
        i.element.animate(x.extend(n, a && o ? {
          top: a,
          left: o
        } : {}), {
          duration: t.animateDuration,
          easing: t.animateEasing,
          step: function () {
            var t = {
              width: parseFloat(i.element.css("width")),
              height: parseFloat(i.element.css("height")),
              top: parseFloat(i.element.css("top")),
              left: parseFloat(i.element.css("left"))
            };
            s && s.length && x(s[0]).css({
              width: t.width,
              height: t.height
            }), i._updateCache(t), i._propagate("resize", e)
          }
        })
      }
    }), x.ui.plugin.add("resizable", "containment", {
      start: function () {
        var i, s, n = x(this).resizable("instance"),
          t = n.options,
          e = n.element,
          a = t.containment,
          o = a instanceof x ? a.get(0) : /parent/.test(a) ? e.parent().get(0) : a;
        o && (n.containerElement = x(o), /document/.test(a) || a === document ? (n.containerOffset = {
          left: 0,
          top: 0
        }, n.containerPosition = {
          left: 0,
          top: 0
        }, n.parentData = {
          element: x(document),
          left: 0,
          top: 0,
          width: x(document).width(),
          height: x(document).height() || document.body.parentNode.scrollHeight
        }) : (i = x(o), s = [], x(["Top", "Right", "Left", "Bottom"]).each(function (t, e) {
          s[t] = n._num(i.css("padding" + e))
        }), n.containerOffset = i.offset(), n.containerPosition = i.position(), n.containerSize = {
          height: i.innerHeight() - s[3],
          width: i.innerWidth() - s[1]
        }, t = n.containerOffset, e = n.containerSize.height, a = n.containerSize.width, a = n._hasScroll(o, "left") ? o.scrollWidth : a, e = n._hasScroll(o) ? o.scrollHeight : e, n.parentData = {
          element: o,
          left: t.left,
          top: t.top,
          width: a,
          height: e
        }))
      },
      resize: function (t) {
        var e = x(this).resizable("instance"),
          i = e.options,
          s = e.containerOffset,
          n = e.position,
          a = e._aspectRatio || t.shiftKey,
          o = {
            top: 0,
            left: 0
          },
          r = e.containerElement,
          t = !0;
        r[0] !== document && /static/.test(r.css("position")) && (o = s), n.left < (e._helper ? s.left : 0) && (e.size.width = e.size.width + (e._helper ? e.position.left - s.left : e.position.left - o.left), a && (e.size.height = e.size.width / e.aspectRatio, t = !1), e.position.left = i.helper ? s.left : 0), n.top < (e._helper ? s.top : 0) && (e.size.height = e.size.height + (e._helper ? e.position.top - s.top : e.position.top), a && (e.size.width = e.size.height * e.aspectRatio, t = !1), e.position.top = e._helper ? s.top : 0), i = e.containerElement.get(0) === e.element.parent().get(0), n = /relative|absolute/.test(e.containerElement.css("position")), i && n ? (e.offset.left = e.parentData.left + e.position.left, e.offset.top = e.parentData.top + e.position.top) : (e.offset.left = e.element.offset().left, e.offset.top = e.element.offset().top), n = Math.abs(e.sizeDiff.width + (e._helper ? e.offset.left - o.left : e.offset.left - s.left)), s = Math.abs(e.sizeDiff.height + (e._helper ? e.offset.top - o.top : e.offset.top - s.top)), n + e.size.width >= e.parentData.width && (e.size.width = e.parentData.width - n, a && (e.size.height = e.size.width / e.aspectRatio, t = !1)), s + e.size.height >= e.parentData.height && (e.size.height = e.parentData.height - s, a && (e.size.width = e.size.height * e.aspectRatio, t = !1)), t || (e.position.left = e.prevPosition.left, e.position.top = e.prevPosition.top, e.size.width = e.prevSize.width, e.size.height = e.prevSize.height)
      },
      stop: function () {
        var t = x(this).resizable("instance"),
          e = t.options,
          i = t.containerOffset,
          s = t.containerPosition,
          n = t.containerElement,
          a = x(t.helper),
          o = a.offset(),
          r = a.outerWidth() - t.sizeDiff.width,
          a = a.outerHeight() - t.sizeDiff.height;
        t._helper && !e.animate && /relative/.test(n.css("position")) && x(this).css({
          left: o.left - s.left - i.left,
          width: r,
          height: a
        }), t._helper && !e.animate && /static/.test(n.css("position")) && x(this).css({
          left: o.left - s.left - i.left,
          width: r,
          height: a
        })
      }
    }), x.ui.plugin.add("resizable", "alsoResize", {
      start: function () {
        var t = x(this).resizable("instance").options;
        x(t.alsoResize).each(function () {
          var t = x(this);
          t.data("ui-resizable-alsoresize", {
            width: parseFloat(t.width()),
            height: parseFloat(t.height()),
            left: parseFloat(t.css("left")),
            top: parseFloat(t.css("top"))
          })
        })
      },
      resize: function (t, i) {
        var e = x(this).resizable("instance"),
          s = e.options,
          n = e.originalSize,
          a = e.originalPosition,
          o = {
            height: e.size.height - n.height || 0,
            width: e.size.width - n.width || 0,
            top: e.position.top - a.top || 0,
            left: e.position.left - a.left || 0
          };
        x(s.alsoResize).each(function () {
          var t = x(this),
            s = x(this).data("ui-resizable-alsoresize"),
            n = {},
            e = t.parents(i.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
          x.each(e, function (t, e) {
            var i = (s[e] || 0) + (o[e] || 0);
            i && 0 <= i && (n[e] = i || null)
          }), t.css(n)
        })
      },
      stop: function () {
        x(this).removeData("ui-resizable-alsoresize")
      }
    }), x.ui.plugin.add("resizable", "ghost", {
      start: function () {
        var t = x(this).resizable("instance"),
          e = t.size;
        t.ghost = t.originalElement.clone(), t.ghost.css({
          opacity: .25,
          display: "block",
          position: "relative",
          height: e.height,
          width: e.width,
          margin: 0,
          left: 0,
          top: 0
        }), t._addClass(t.ghost, "ui-resizable-ghost"), !1 !== x.uiBackCompat && "string" == typeof t.options.ghost && t.ghost.addClass(this.options.ghost), t.ghost.appendTo(t.helper)
      },
      resize: function () {
        var t = x(this).resizable("instance");
        t.ghost && t.ghost.css({
          position: "relative",
          height: t.size.height,
          width: t.size.width
        })
      },
      stop: function () {
        var t = x(this).resizable("instance");
        t.ghost && t.helper && t.helper.get(0).removeChild(t.ghost.get(0))
      }
    }), x.ui.plugin.add("resizable", "grid", {
      resize: function () {
        var t, e = x(this).resizable("instance"),
          i = e.options,
          s = e.size,
          n = e.originalSize,
          a = e.originalPosition,
          o = e.axis,
          r = "number" == typeof i.grid ? [i.grid, i.grid] : i.grid,
          l = r[0] || 1,
          c = r[1] || 1,
          d = Math.round((s.width - n.width) / l) * l,
          h = Math.round((s.height - n.height) / c) * c,
          u = n.width + d,
          p = n.height + h,
          f = i.maxWidth && i.maxWidth < u,
          m = i.maxHeight && i.maxHeight < p,
          g = i.minWidth && i.minWidth > u,
          s = i.minHeight && i.minHeight > p;
        i.grid = r, g && (u += l), s && (p += c), f && (u -= l), m && (p -= c), /^(se|s|e)$/.test(o) ? (e.size.width = u, e.size.height = p) : /^(ne)$/.test(o) ? (e.size.width = u, e.size.height = p, e.position.top = a.top - h) : /^(sw)$/.test(o) ? (e.size.width = u, e.size.height = p, e.position.left = a.left - d) : ((p - c <= 0 || u - l <= 0) && (t = e._getPaddingPlusBorderDimensions(this)), 0 < p - c ? (e.size.height = p, e.position.top = a.top - h) : (p = c - t.height, e.size.height = p, e.position.top = a.top + n.height - p), 0 < u - l ? (e.size.width = u, e.position.left = a.left - d) : (u = l - t.width, e.size.width = u, e.position.left = a.left + n.width - u))
      }
    }), x.ui.resizable, x.widget("ui.dialog", {
      version: "1.12.1",
      options: {
        appendTo: "body",
        autoOpen: !0,
        buttons: [],
        classes: {
          "ui-dialog": "ui-corner-all",
          "ui-dialog-titlebar": "ui-corner-all"
        },
        closeOnEscape: !0,
        closeText: "Close",
        draggable: !0,
        hide: null,
        height: "auto",
        maxHeight: null,
        maxWidth: null,
        minHeight: 150,
        minWidth: 150,
        modal: !1,
        position: {
          my: "center",
          at: "center",
          of: window,
          collision: "fit",
          using: function (t) {
            var e = x(this).css(t).offset().top;
            e < 0 && x(this).css("top", t.top - e)
          }
        },
        resizable: !0,
        show: null,
        title: null,
        width: 300,
        beforeClose: null,
        close: null,
        drag: null,
        dragStart: null,
        dragStop: null,
        focus: null,
        open: null,
        resize: null,
        resizeStart: null,
        resizeStop: null
      },
      sizeRelatedOptions: {
        buttons: !0,
        height: !0,
        maxHeight: !0,
        maxWidth: !0,
        minHeight: !0,
        minWidth: !0,
        width: !0
      },
      resizableRelatedOptions: {
        maxHeight: !0,
        maxWidth: !0,
        minHeight: !0,
        minWidth: !0
      },
      _create: function () {
        this.originalCss = {
          display: this.element[0].style.display,
          width: this.element[0].style.width,
          minHeight: this.element[0].style.minHeight,
          maxHeight: this.element[0].style.maxHeight,
          height: this.element[0].style.height
        }, this.originalPosition = {
          parent: this.element.parent(),
          index: this.element.parent().children().index(this.element)
        }, this.originalTitle = this.element.attr("title"), null == this.options.title && null != this.originalTitle && (this.options.title = this.originalTitle), this.options.disabled && (this.options.disabled = !1), this._createWrapper(), this.element.show().removeAttr("title").appendTo(this.uiDialog), this._addClass("ui-dialog-content", "ui-widget-content"), this._createTitlebar(), this._createButtonPane(), this.options.draggable && x.fn.draggable && this._makeDraggable(), this.options.resizable && x.fn.resizable && this._makeResizable(), this._isOpen = !1, this._trackFocus()
      },
      _init: function () {
        this.options.autoOpen && this.open()
      },
      _appendTo: function () {
        var t = this.options.appendTo;
        return t && (t.jquery || t.nodeType) ? x(t) : this.document.find(t || "body").eq(0)
      },
      _destroy: function () {
        var t, e = this.originalPosition;
        this._untrackInstance(), this._destroyOverlay(), this.element.removeUniqueId().css(this.originalCss).detach(), this.uiDialog.remove(), this.originalTitle && this.element.attr("title", this.originalTitle), (t = e.parent.children().eq(e.index)).length && t[0] !== this.element[0] ? t.before(this.element) : e.parent.append(this.element)
      },
      widget: function () {
        return this.uiDialog
      },
      disable: x.noop,
      enable: x.noop,
      close: function (t) {
        var e = this;
        this._isOpen && !1 !== this._trigger("beforeClose", t) && (this._isOpen = !1, this._focusedElement = null, this._destroyOverlay(), this._untrackInstance(), this.opener.filter(":focusable").trigger("focus").length || x.ui.safeBlur(x.ui.safeActiveElement(this.document[0])), this._hide(this.uiDialog, this.options.hide, function () {
          e._trigger("close", t)
        }))
      },
      isOpen: function () {
        return this._isOpen
      },
      moveToTop: function () {
        this._moveToTop()
      },
      _moveToTop: function (t, e) {
        var i = !1,
          s = this.uiDialog.siblings(".ui-front:visible").map(function () {
            return +x(this).css("z-index")
          }).get(),
          s = Math.max.apply(null, s);
        return s >= +this.uiDialog.css("z-index") && (this.uiDialog.css("z-index", s + 1), i = !0), i && !e && this._trigger("focus", t), i
      },
      open: function () {
        var t = this;
        this._isOpen ? this._moveToTop() && this._focusTabbable() : (this._isOpen = !0, this.opener = x(x.ui.safeActiveElement(this.document[0])), this._size(), this._position(), this._createOverlay(), this._moveToTop(null, !0), this.overlay && this.overlay.css("z-index", this.uiDialog.css("z-index") - 1), this._show(this.uiDialog, this.options.show, function () {
          t._focusTabbable(), t._trigger("focus")
        }), this._makeFocusTarget(), this._trigger("open"))
      },
      _focusTabbable: function () {
        var t = this._focusedElement;
        (t = !(t = !(t = !(t = !(t = t || this.element.find("[autofocus]")).length ? this.element.find(":tabbable") : t).length ? this.uiDialogButtonPane.find(":tabbable") : t).length ? this.uiDialogTitlebarClose.filter(":tabbable") : t).length ? this.uiDialog : t).eq(0).trigger("focus")
      },
      _keepFocus: function (t) {
        function e() {
          var t = x.ui.safeActiveElement(this.document[0]);
          this.uiDialog[0] === t || x.contains(this.uiDialog[0], t) || this._focusTabbable()
        }
        t.preventDefault(), e.call(this), this._delay(e)
      },
      _createWrapper: function () {
        this.uiDialog = x("<div>").hide().attr({
          tabIndex: -1,
          role: "dialog"
        }).appendTo(this._appendTo()), this._addClass(this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front"), this._on(this.uiDialog, {
          keydown: function (t) {
            if (this.options.closeOnEscape && !t.isDefaultPrevented() && t.keyCode && t.keyCode === x.ui.keyCode.ESCAPE) return t.preventDefault(), void this.close(t);
            var e, i, s;
            t.keyCode !== x.ui.keyCode.TAB || t.isDefaultPrevented() || (e = this.uiDialog.find(":tabbable"), i = e.filter(":first"), s = e.filter(":last"), t.target !== s[0] && t.target !== this.uiDialog[0] || t.shiftKey ? t.target !== i[0] && t.target !== this.uiDialog[0] || !t.shiftKey || (this._delay(function () {
              s.trigger("focus")
            }), t.preventDefault()) : (this._delay(function () {
              i.trigger("focus")
            }), t.preventDefault()))
          },
          mousedown: function (t) {
            this._moveToTop(t) && this._focusTabbable()
          }
        }), this.element.find("[aria-describedby]").length || this.uiDialog.attr({
          "aria-describedby": this.element.uniqueId().attr("id")
        })
      },
      _createTitlebar: function () {
        var t;
        this.uiDialogTitlebar = x("<div>"), this._addClass(this.uiDialogTitlebar, "ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix"), this._on(this.uiDialogTitlebar, {
          mousedown: function (t) {
            x(t.target).closest(".ui-dialog-titlebar-close") || this.uiDialog.trigger("focus")
          }
        }), this.uiDialogTitlebarClose = x("<button type='button'></button>").button({
          label: x("<a>").text(this.options.closeText).html(),
          icon: "ui-icon-closethick",
          showLabel: !1
        }).appendTo(this.uiDialogTitlebar), this._addClass(this.uiDialogTitlebarClose, "ui-dialog-titlebar-close"), this._on(this.uiDialogTitlebarClose, {
          click: function (t) {
            t.preventDefault(), this.close(t)
          }
        }), t = x("<span>").uniqueId().prependTo(this.uiDialogTitlebar), this._addClass(t, "ui-dialog-title"), this._title(t), this.uiDialogTitlebar.prependTo(this.uiDialog), this.uiDialog.attr({
          "aria-labelledby": t.attr("id")
        })
      },
      _title: function (t) {
        this.options.title ? t.text(this.options.title) : t.html("&#160;")
      },
      _createButtonPane: function () {
        this.uiDialogButtonPane = x("<div>"), this._addClass(this.uiDialogButtonPane, "ui-dialog-buttonpane", "ui-widget-content ui-helper-clearfix"), this.uiButtonSet = x("<div>").appendTo(this.uiDialogButtonPane), this._addClass(this.uiButtonSet, "ui-dialog-buttonset"), this._createButtons()
      },
      _createButtons: function () {
        var s = this,
          t = this.options.buttons;
        this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), x.isEmptyObject(t) || x.isArray(t) && !t.length ? this._removeClass(this.uiDialog, "ui-dialog-buttons") : (x.each(t, function (t, e) {
          var i;
          e = x.isFunction(e) ? {
            click: e,
            text: t
          } : e, e = x.extend({
            type: "button"
          }, e), i = e.click, t = {
            icon: e.icon,
            iconPosition: e.iconPosition,
            showLabel: e.showLabel,
            icons: e.icons,
            text: e.text
          }, delete e.click, delete e.icon, delete e.iconPosition, delete e.showLabel, delete e.icons, "boolean" == typeof e.text && delete e.text, x("<button></button>", e).button(t).appendTo(s.uiButtonSet).on("click", function () {
            i.apply(s.element[0], arguments)
          })
        }), this._addClass(this.uiDialog, "ui-dialog-buttons"), this.uiDialogButtonPane.appendTo(this.uiDialog))
      },
      _makeDraggable: function () {
        var n = this,
          a = this.options;

        function o(t) {
          return {
            position: t.position,
            offset: t.offset
          }
        }
        this.uiDialog.draggable({
          cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
          handle: ".ui-dialog-titlebar",
          containment: "document",
          start: function (t, e) {
            n._addClass(x(this), "ui-dialog-dragging"), n._blockFrames(), n._trigger("dragStart", t, o(e))
          },
          drag: function (t, e) {
            n._trigger("drag", t, o(e))
          },
          stop: function (t, e) {
            var i = e.offset.left - n.document.scrollLeft(),
              s = e.offset.top - n.document.scrollTop();
            a.position = {
              my: "left top",
              at: "left" + (0 <= i ? "+" : "") + i + " top" + (0 <= s ? "+" : "") + s,
              of: n.window
            }, n._removeClass(x(this), "ui-dialog-dragging"), n._unblockFrames(), n._trigger("dragStop", t, o(e))
          }
        })
      },
      _makeResizable: function () {
        var n = this,
          a = this.options,
          t = a.resizable,
          e = this.uiDialog.css("position"),
          t = "string" == typeof t ? t : "n,e,s,w,se,sw,ne,nw";

        function o(t) {
          return {
            originalPosition: t.originalPosition,
            originalSize: t.originalSize,
            position: t.position,
            size: t.size
          }
        }
        this.uiDialog.resizable({
          cancel: ".ui-dialog-content",
          containment: "document",
          alsoResize: this.element,
          maxWidth: a.maxWidth,
          maxHeight: a.maxHeight,
          minWidth: a.minWidth,
          minHeight: this._minHeight(),
          handles: t,
          start: function (t, e) {
            n._addClass(x(this), "ui-dialog-resizing"), n._blockFrames(), n._trigger("resizeStart", t, o(e))
          },
          resize: function (t, e) {
            n._trigger("resize", t, o(e))
          },
          stop: function (t, e) {
            var i = n.uiDialog.offset(),
              s = i.left - n.document.scrollLeft(),
              i = i.top - n.document.scrollTop();
            a.height = n.uiDialog.height(), a.width = n.uiDialog.width(), a.position = {
              my: "left top",
              at: "left" + (0 <= s ? "+" : "") + s + " top" + (0 <= i ? "+" : "") + i,
              of: n.window
            }, n._removeClass(x(this), "ui-dialog-resizing"), n._unblockFrames(), n._trigger("resizeStop", t, o(e))
          }
        }).css("position", e)
      },
      _trackFocus: function () {
        this._on(this.widget(), {
          focusin: function (t) {
            this._makeFocusTarget(), this._focusedElement = x(t.target)
          }
        })
      },
      _makeFocusTarget: function () {
        this._untrackInstance(), this._trackingInstances().unshift(this)
      },
      _untrackInstance: function () {
        var t = this._trackingInstances(),
          e = x.inArray(this, t); - 1 !== e && t.splice(e, 1)
      },
      _trackingInstances: function () {
        var t = this.document.data("ui-dialog-instances");
        return t || this.document.data("ui-dialog-instances", t = []), t
      },
      _minHeight: function () {
        var t = this.options;
        return "auto" === t.height ? t.minHeight : Math.min(t.minHeight, t.height)
      },
      _position: function () {
        var t = this.uiDialog.is(":visible");
        t || this.uiDialog.show(), this.uiDialog.position(this.options.position), t || this.uiDialog.hide()
      },
      _setOptions: function (t) {
        var i = this,
          s = !1,
          n = {};
        x.each(t, function (t, e) {
          i._setOption(t, e), t in i.sizeRelatedOptions && (s = !0), t in i.resizableRelatedOptions && (n[t] = e)
        }), s && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", n)
      },
      _setOption: function (t, e) {
        var i, s = this.uiDialog;
        "disabled" !== t && (this._super(t, e), "appendTo" === t && this.uiDialog.appendTo(this._appendTo()), "buttons" === t && this._createButtons(), "closeText" === t && this.uiDialogTitlebarClose.button({
          label: x("<a>").text("" + this.options.closeText).html()
        }), "draggable" === t && ((i = s.is(":data(ui-draggable)")) && !e && s.draggable("destroy"), !i && e && this._makeDraggable()), "position" === t && this._position(), "resizable" === t && ((i = s.is(":data(ui-resizable)")) && !e && s.resizable("destroy"), i && "string" == typeof e && s.resizable("option", "handles", e), i || !1 === e || this._makeResizable()), "title" === t && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))
      },
      _size: function () {
        var t, e, i, s = this.options;
        this.element.show().css({
          width: "auto",
          minHeight: 0,
          maxHeight: "none",
          height: 0
        }), s.minWidth > s.width && (s.width = s.minWidth), t = this.uiDialog.css({
          height: "auto",
          width: s.width
        }).outerHeight(), e = Math.max(0, s.minHeight - t), i = "number" == typeof s.maxHeight ? Math.max(0, s.maxHeight - t) : "none", "auto" === s.height ? this.element.css({
          minHeight: e,
          maxHeight: i,
          height: "auto"
        }) : this.element.height(Math.max(0, s.height - t)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight())
      },
      _blockFrames: function () {
        this.iframeBlocks = this.document.find("iframe").map(function () {
          var t = x(this);
          return x("<div>").css({
            position: "absolute",
            width: t.outerWidth(),
            height: t.outerHeight()
          }).appendTo(t.parent()).offset(t.offset())[0]
        })
      },
      _unblockFrames: function () {
        this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks)
      },
      _allowInteraction: function (t) {
        return !!x(t.target).closest(".ui-dialog").length || !!x(t.target).closest(".ui-datepicker").length
      },
      _createOverlay: function () {
        var e;
        this.options.modal && (e = !0, this._delay(function () {
          e = !1
        }), this.document.data("ui-dialog-overlays") || this._on(this.document, {
          focusin: function (t) {
            e || this._allowInteraction(t) || (t.preventDefault(), this._trackingInstances()[0]._focusTabbable())
          }
        }), this.overlay = x("<div>").appendTo(this._appendTo()), this._addClass(this.overlay, null, "ui-widget-overlay ui-front"), this._on(this.overlay, {
          mousedown: "_keepFocus"
        }), this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1))
      },
      _destroyOverlay: function () {
        var t;
        this.options.modal && this.overlay && ((t = this.document.data("ui-dialog-overlays") - 1) ? this.document.data("ui-dialog-overlays", t) : (this._off(this.document, "focusin"), this.document.removeData("ui-dialog-overlays")), this.overlay.remove(), this.overlay = null)
      }
    }), !1 !== x.uiBackCompat && x.widget("ui.dialog", x.ui.dialog, {
      options: {
        dialogClass: ""
      },
      _createWrapper: function () {
        this._super(), this.uiDialog.addClass(this.options.dialogClass)
      },
      _setOption: function (t, e) {
        "dialogClass" === t && this.uiDialog.removeClass(this.options.dialogClass).addClass(e), this._superApply(arguments)
      }
    }), x.ui.dialog, x.widget("ui.droppable", {
      version: "1.12.1",
      widgetEventPrefix: "drop",
      options: {
        accept: "*",
        addClasses: !0,
        greedy: !1,
        scope: "default",
        tolerance: "intersect",
        activate: null,
        deactivate: null,
        drop: null,
        out: null,
        over: null
      },
      _create: function () {
        var t, e = this.options,
          i = e.accept;
        this.isover = !1, this.isout = !0, this.accept = x.isFunction(i) ? i : function (t) {
          return t.is(i)
        }, this.proportions = function () {
          if (!arguments.length) return t = t || {
            width: this.element[0].offsetWidth,
            height: this.element[0].offsetHeight
          };
          t = arguments[0]
        }, this._addToManager(e.scope), e.addClasses && this._addClass("ui-droppable")
      },
      _addToManager: function (t) {
        x.ui.ddmanager.droppables[t] = x.ui.ddmanager.droppables[t] || [], x.ui.ddmanager.droppables[t].push(this)
      },
      _splice: function (t) {
        for (var e = 0; e < t.length; e++) t[e] === this && t.splice(e, 1)
      },
      _destroy: function () {
        var t = x.ui.ddmanager.droppables[this.options.scope];
        this._splice(t)
      },
      _setOption: function (t, e) {
        var i;
        "accept" === t ? this.accept = x.isFunction(e) ? e : function (t) {
          return t.is(e)
        } : "scope" === t && (i = x.ui.ddmanager.droppables[this.options.scope], this._splice(i), this._addToManager(e)), this._super(t, e)
      },
      _activate: function (t) {
        var e = x.ui.ddmanager.current;
        this._addActiveClass(), e && this._trigger("activate", t, this.ui(e))
      },
      _deactivate: function (t) {
        var e = x.ui.ddmanager.current;
        this._removeActiveClass(), e && this._trigger("deactivate", t, this.ui(e))
      },
      _over: function (t) {
        var e = x.ui.ddmanager.current;
        e && (e.currentItem || e.element)[0] !== this.element[0] && this.accept.call(this.element[0], e.currentItem || e.element) && (this._addHoverClass(), this._trigger("over", t, this.ui(e)))
      },
      _out: function (t) {
        var e = x.ui.ddmanager.current;
        e && (e.currentItem || e.element)[0] !== this.element[0] && this.accept.call(this.element[0], e.currentItem || e.element) && (this._removeHoverClass(), this._trigger("out", t, this.ui(e)))
      },
      _drop: function (e, t) {
        var i = t || x.ui.ddmanager.current,
          s = !1;
        return !(!i || (i.currentItem || i.element)[0] === this.element[0]) && (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function () {
          var t = x(this).droppable("instance");
          if (t.options.greedy && !t.options.disabled && t.options.scope === i.options.scope && t.accept.call(t.element[0], i.currentItem || i.element) && it(i, x.extend(t, {
              offset: t.element.offset()
            }), t.options.tolerance, e)) return !(s = !0)
        }), !s && !!this.accept.call(this.element[0], i.currentItem || i.element) && (this._removeActiveClass(), this._removeHoverClass(), this._trigger("drop", e, this.ui(i)), this.element))
      },
      ui: function (t) {
        return {
          draggable: t.currentItem || t.element,
          helper: t.helper,
          position: t.position,
          offset: t.positionAbs
        }
      },
      _addHoverClass: function () {
        this._addClass("ui-droppable-hover")
      },
      _removeHoverClass: function () {
        this._removeClass("ui-droppable-hover")
      },
      _addActiveClass: function () {
        this._addClass("ui-droppable-active")
      },
      _removeActiveClass: function () {
        this._removeClass("ui-droppable-active")
      }
    });
    var et, it = x.ui.intersect = function (t, e, i, s) {
      if (!e.offset) return !1;
      var n = (t.positionAbs || t.position.absolute).left + t.margins.left,
        a = (t.positionAbs || t.position.absolute).top + t.margins.top,
        o = n + t.helperProportions.width,
        r = a + t.helperProportions.height,
        l = e.offset.left,
        c = e.offset.top,
        d = l + e.proportions().width,
        h = c + e.proportions().height;
      switch (i) {
        case "fit":
          return l <= n && o <= d && c <= a && r <= h;
        case "intersect":
          return l < n + t.helperProportions.width / 2 && o - t.helperProportions.width / 2 < d && c < a + t.helperProportions.height / 2 && r - t.helperProportions.height / 2 < h;
        case "pointer":
          return st(s.pageY, c, e.proportions().height) && st(s.pageX, l, e.proportions().width);
        case "touch":
          return (c <= a && a <= h || c <= r && r <= h || a < c && h < r) && (l <= n && n <= d || l <= o && o <= d || n < l && d < o);
        default:
          return !1
      }
    };

    function st(t, e, i) {
      return e <= t && t < e + i
    }

    function nt(e) {
      return function () {
        var t = this.element.val();
        e.apply(this, arguments), this._refresh(), t !== this.element.val() && this._trigger("change")
      }
    }!(x.ui.ddmanager = {
      current: null,
      droppables: {
        default: []
      },
      prepareOffsets: function (t, e) {
        var i, s, n = x.ui.ddmanager.droppables[t.options.scope] || [],
          a = e ? e.type : null,
          o = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
        t: for (i = 0; i < n.length; i++)
          if (!(n[i].options.disabled || t && !n[i].accept.call(n[i].element[0], t.currentItem || t.element))) {
            for (s = 0; s < o.length; s++)
              if (o[s] === n[i].element[0]) {
                n[i].proportions().height = 0;
                continue t
              } n[i].visible = "none" !== n[i].element.css("display"), n[i].visible && ("mousedown" === a && n[i]._activate.call(n[i], e), n[i].offset = n[i].element.offset(), n[i].proportions({
              width: n[i].element[0].offsetWidth,
              height: n[i].element[0].offsetHeight
            }))
          }
      },
      drop: function (t, e) {
        var i = !1;
        return x.each((x.ui.ddmanager.droppables[t.options.scope] || []).slice(), function () {
          this.options && (!this.options.disabled && this.visible && it(t, this, this.options.tolerance, e) && (i = this._drop.call(this, e) || i), !this.options.disabled && this.visible && this.accept.call(this.element[0], t.currentItem || t.element) && (this.isout = !0, this.isover = !1, this._deactivate.call(this, e)))
        }), i
      },
      dragStart: function (t, e) {
        t.element.parentsUntil("body").on("scroll.droppable", function () {
          t.options.refreshPositions || x.ui.ddmanager.prepareOffsets(t, e)
        })
      },
      drag: function (n, a) {
        n.options.refreshPositions && x.ui.ddmanager.prepareOffsets(n, a), x.each(x.ui.ddmanager.droppables[n.options.scope] || [], function () {
          var t, e, i, s;
          this.options.disabled || this.greedyChild || !this.visible || (s = !(i = it(n, this, this.options.tolerance, a)) && this.isover ? "isout" : i && !this.isover ? "isover" : null) && (this.options.greedy && (e = this.options.scope, (i = this.element.parents(":data(ui-droppable)").filter(function () {
            return x(this).droppable("instance").options.scope === e
          })).length && ((t = x(i[0]).droppable("instance")).greedyChild = "isover" === s)), t && "isover" === s && (t.isover = !1, t.isout = !0, t._out.call(t, a)), this[s] = !0, this["isout" === s ? "isover" : "isout"] = !1, this["isover" === s ? "_over" : "_out"].call(this, a), t && "isout" === s && (t.isout = !1, t.isover = !0, t._over.call(t, a)))
        })
      },
      dragStop: function (t, e) {
        t.element.parentsUntil("body").off("scroll.droppable"), t.options.refreshPositions || x.ui.ddmanager.prepareOffsets(t, e)
      }
    }) !== x.uiBackCompat && x.widget("ui.droppable", x.ui.droppable, {
      options: {
        hoverClass: !1,
        activeClass: !1
      },
      _addActiveClass: function () {
        this._super(), this.options.activeClass && this.element.addClass(this.options.activeClass)
      },
      _removeActiveClass: function () {
        this._super(), this.options.activeClass && this.element.removeClass(this.options.activeClass)
      },
      _addHoverClass: function () {
        this._super(), this.options.hoverClass && this.element.addClass(this.options.hoverClass)
      },
      _removeHoverClass: function () {
        this._super(), this.options.hoverClass && this.element.removeClass(this.options.hoverClass)
      }
    }), x.ui.droppable, x.widget("ui.progressbar", {
      version: "1.12.1",
      options: {
        classes: {
          "ui-progressbar": "ui-corner-all",
          "ui-progressbar-value": "ui-corner-left",
          "ui-progressbar-complete": "ui-corner-right"
        },
        max: 100,
        value: 0,
        change: null,
        complete: null
      },
      min: 0,
      _create: function () {
        this.oldValue = this.options.value = this._constrainedValue(), this.element.attr({
          role: "progressbar",
          "aria-valuemin": this.min
        }), this._addClass("ui-progressbar", "ui-widget ui-widget-content"), this.valueDiv = x("<div>").appendTo(this.element), this._addClass(this.valueDiv, "ui-progressbar-value", "ui-widget-header"), this._refreshValue()
      },
      _destroy: function () {
        this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"), this.valueDiv.remove()
      },
      value: function (t) {
        if (void 0 === t) return this.options.value;
        this.options.value = this._constrainedValue(t), this._refreshValue()
      },
      _constrainedValue: function (t) {
        return void 0 === t && (t = this.options.value), this.indeterminate = !1 === t, "number" != typeof t && (t = 0), !this.indeterminate && Math.min(this.options.max, Math.max(this.min, t))
      },
      _setOptions: function (t) {
        var e = t.value;
        delete t.value, this._super(t), this.options.value = this._constrainedValue(e), this._refreshValue()
      },
      _setOption: function (t, e) {
        "max" === t && (e = Math.max(this.min, e)), this._super(t, e)
      },
      _setOptionDisabled: function (t) {
        this._super(t), this.element.attr("aria-disabled", t), this._toggleClass(null, "ui-state-disabled", !!t)
      },
      _percentage: function () {
        return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min)
      },
      _refreshValue: function () {
        var t = this.options.value,
          e = this._percentage();
        this.valueDiv.toggle(this.indeterminate || t > this.min).width(e.toFixed(0) + "%"), this._toggleClass(this.valueDiv, "ui-progressbar-complete", null, t === this.options.max)._toggleClass("ui-progressbar-indeterminate", null, this.indeterminate), this.indeterminate ? (this.element.removeAttr("aria-valuenow"), this.overlayDiv || (this.overlayDiv = x("<div>").appendTo(this.valueDiv), this._addClass(this.overlayDiv, "ui-progressbar-overlay"))) : (this.element.attr({
          "aria-valuemax": this.options.max,
          "aria-valuenow": t
        }), this.overlayDiv && (this.overlayDiv.remove(), this.overlayDiv = null)), this.oldValue !== t && (this.oldValue = t, this._trigger("change")), t === this.options.max && this._trigger("complete")
      }
    }), x.widget("ui.selectable", x.ui.mouse, {
      version: "1.12.1",
      options: {
        appendTo: "body",
        autoRefresh: !0,
        distance: 0,
        filter: "*",
        tolerance: "touch",
        selected: null,
        selecting: null,
        start: null,
        stop: null,
        unselected: null,
        unselecting: null
      },
      _create: function () {
        var i = this;
        this._addClass("ui-selectable"), this.dragged = !1, this.refresh = function () {
          i.elementPos = x(i.element[0]).offset(), i.selectees = x(i.options.filter, i.element[0]), i._addClass(i.selectees, "ui-selectee"), i.selectees.each(function () {
            var t = x(this),
              e = t.offset(),
              e = {
                left: e.left - i.elementPos.left,
                top: e.top - i.elementPos.top
              };
            x.data(this, "selectable-item", {
              element: this,
              $element: t,
              left: e.left,
              top: e.top,
              right: e.left + t.outerWidth(),
              bottom: e.top + t.outerHeight(),
              startselected: !1,
              selected: t.hasClass("ui-selected"),
              selecting: t.hasClass("ui-selecting"),
              unselecting: t.hasClass("ui-unselecting")
            })
          })
        }, this.refresh(), this._mouseInit(), this.helper = x("<div>"), this._addClass(this.helper, "ui-selectable-helper")
      },
      _destroy: function () {
        this.selectees.removeData("selectable-item"), this._mouseDestroy()
      },
      _mouseStart: function (i) {
        var s = this,
          t = this.options;
        this.opos = [i.pageX, i.pageY], this.elementPos = x(this.element[0]).offset(), this.options.disabled || (this.selectees = x(t.filter, this.element[0]), this._trigger("start", i), x(t.appendTo).append(this.helper), this.helper.css({
          left: i.pageX,
          top: i.pageY,
          width: 0,
          height: 0
        }), t.autoRefresh && this.refresh(), this.selectees.filter(".ui-selected").each(function () {
          var t = x.data(this, "selectable-item");
          t.startselected = !0, i.metaKey || i.ctrlKey || (s._removeClass(t.$element, "ui-selected"), t.selected = !1, s._addClass(t.$element, "ui-unselecting"), t.unselecting = !0, s._trigger("unselecting", i, {
            unselecting: t.element
          }))
        }), x(i.target).parents().addBack().each(function () {
          var t, e = x.data(this, "selectable-item");
          if (e) return t = !i.metaKey && !i.ctrlKey || !e.$element.hasClass("ui-selected"), s._removeClass(e.$element, t ? "ui-unselecting" : "ui-selected")._addClass(e.$element, t ? "ui-selecting" : "ui-unselecting"), e.unselecting = !t, e.selecting = t, (e.selected = t) ? s._trigger("selecting", i, {
            selecting: e.element
          }) : s._trigger("unselecting", i, {
            unselecting: e.element
          }), !1
        }))
      },
      _mouseDrag: function (s) {
        if (this.dragged = !0, !this.options.disabled) {
          var t, n = this,
            a = this.options,
            o = this.opos[0],
            r = this.opos[1],
            l = s.pageX,
            c = s.pageY;
          return l < o && (t = l, l = o, o = t), c < r && (t = c, c = r, r = t), this.helper.css({
            left: o,
            top: r,
            width: l - o,
            height: c - r
          }), this.selectees.each(function () {
            var t = x.data(this, "selectable-item"),
              e = !1,
              i = {};
            t && t.element !== n.element[0] && (i.left = t.left + n.elementPos.left, i.right = t.right + n.elementPos.left, i.top = t.top + n.elementPos.top, i.bottom = t.bottom + n.elementPos.top, "touch" === a.tolerance ? e = !(i.left > l || i.right < o || i.top > c || i.bottom < r) : "fit" === a.tolerance && (e = i.left > o && i.right < l && i.top > r && i.bottom < c), e ? (t.selected && (n._removeClass(t.$element, "ui-selected"), t.selected = !1), t.unselecting && (n._removeClass(t.$element, "ui-unselecting"), t.unselecting = !1), t.selecting || (n._addClass(t.$element, "ui-selecting"), t.selecting = !0, n._trigger("selecting", s, {
              selecting: t.element
            }))) : (t.selecting && ((s.metaKey || s.ctrlKey) && t.startselected ? (n._removeClass(t.$element, "ui-selecting"), t.selecting = !1, n._addClass(t.$element, "ui-selected"), t.selected = !0) : (n._removeClass(t.$element, "ui-selecting"), t.selecting = !1, t.startselected && (n._addClass(t.$element, "ui-unselecting"), t.unselecting = !0), n._trigger("unselecting", s, {
              unselecting: t.element
            }))), t.selected && (s.metaKey || s.ctrlKey || t.startselected || (n._removeClass(t.$element, "ui-selected"), t.selected = !1, n._addClass(t.$element, "ui-unselecting"), t.unselecting = !0, n._trigger("unselecting", s, {
              unselecting: t.element
            })))))
          }), !1
        }
      },
      _mouseStop: function (e) {
        var i = this;
        return this.dragged = !1, x(".ui-unselecting", this.element[0]).each(function () {
          var t = x.data(this, "selectable-item");
          i._removeClass(t.$element, "ui-unselecting"), t.unselecting = !1, t.startselected = !1, i._trigger("unselected", e, {
            unselected: t.element
          })
        }), x(".ui-selecting", this.element[0]).each(function () {
          var t = x.data(this, "selectable-item");
          i._removeClass(t.$element, "ui-selecting")._addClass(t.$element, "ui-selected"), t.selecting = !1, t.selected = !0, t.startselected = !0, i._trigger("selected", e, {
            selected: t.element
          })
        }), this._trigger("stop", e), this.helper.remove(), !1
      }
    }), x.widget("ui.selectmenu", [x.ui.formResetMixin, {
      version: "1.12.1",
      defaultElement: "<select>",
      options: {
        appendTo: null,
        classes: {
          "ui-selectmenu-button-open": "ui-corner-top",
          "ui-selectmenu-button-closed": "ui-corner-all"
        },
        disabled: null,
        icons: {
          button: "ui-icon-triangle-1-s"
        },
        position: {
          my: "left top",
          at: "left bottom",
          collision: "none"
        },
        width: !1,
        change: null,
        close: null,
        focus: null,
        open: null,
        select: null
      },
      _create: function () {
        var t = this.element.uniqueId().attr("id");
        this.ids = {
          element: t,
          button: t + "-button",
          menu: t + "-menu"
        }, this._drawButton(), this._drawMenu(), this._bindFormResetHandler(), this._rendered = !1, this.menuItems = x()
      },
      _drawButton: function () {
        var t, e = this,
          i = this._parseOption(this.element.find("option:selected"), this.element[0].selectedIndex);
        this.labels = this.element.labels().attr("for", this.ids.button), this._on(this.labels, {
          click: function (t) {
            this.button.focus(), t.preventDefault()
          }
        }), this.element.hide(), this.button = x("<span>", {
          tabindex: this.options.disabled ? -1 : 0,
          id: this.ids.button,
          role: "combobox",
          "aria-expanded": "false",
          "aria-autocomplete": "list",
          "aria-owns": this.ids.menu,
          "aria-haspopup": "true",
          title: this.element.attr("title")
        }).insertAfter(this.element), this._addClass(this.button, "ui-selectmenu-button ui-selectmenu-button-closed", "ui-button ui-widget"), t = x("<span>").appendTo(this.button), this._addClass(t, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button), this.buttonItem = this._renderButtonItem(i).appendTo(this.button), !1 !== this.options.width && this._resizeButton(), this._on(this.button, this._buttonEvents), this.button.one("focusin", function () {
          e._rendered || e._refreshMenu()
        })
      },
      _drawMenu: function () {
        var i = this;
        this.menu = x("<ul>", {
          "aria-hidden": "true",
          "aria-labelledby": this.ids.button,
          id: this.ids.menu
        }), this.menuWrap = x("<div>").append(this.menu), this._addClass(this.menuWrap, "ui-selectmenu-menu", "ui-front"), this.menuWrap.appendTo(this._appendTo()), this.menuInstance = this.menu.menu({
          classes: {
            "ui-menu": "ui-corner-bottom"
          },
          role: "listbox",
          select: function (t, e) {
            t.preventDefault(), i._setSelection(), i._select(e.item.data("ui-selectmenu-item"), t)
          },
          focus: function (t, e) {
            e = e.item.data("ui-selectmenu-item");
            null != i.focusIndex && e.index !== i.focusIndex && (i._trigger("focus", t, {
              item: e
            }), i.isOpen || i._select(e, t)), i.focusIndex = e.index, i.button.attr("aria-activedescendant", i.menuItems.eq(e.index).attr("id"))
          }
        }).menu("instance"), this.menuInstance._off(this.menu, "mouseleave"), this.menuInstance._closeOnDocumentClick = function () {
          return !1
        }, this.menuInstance._isDivider = function () {
          return !1
        }
      },
      refresh: function () {
        this._refreshMenu(), this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item") || {})), null === this.options.width && this._resizeButton()
      },
      _refreshMenu: function () {
        var t = this.element.find("option");
        this.menu.empty(), this._parseOptions(t), this._renderMenu(this.menu, this.items), this.menuInstance.refresh(), this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"), this._rendered = !0, t.length && (t = this._getSelectedItem(), this.menuInstance.focus(null, t), this._setAria(t.data("ui-selectmenu-item")), this._setOption("disabled", this.element.prop("disabled")))
      },
      open: function (t) {
        this.options.disabled || (this._rendered ? (this._removeClass(this.menu.find(".ui-state-active"), null, "ui-state-active"), this.menuInstance.focus(null, this._getSelectedItem())) : this._refreshMenu(), this.menuItems.length && (this.isOpen = !0, this._toggleAttr(), this._resizeMenu(), this._position(), this._on(this.document, this._documentClick), this._trigger("open", t)))
      },
      _position: function () {
        this.menuWrap.position(x.extend({
          of: this.button
        }, this.options.position))
      },
      close: function (t) {
        this.isOpen && (this.isOpen = !1, this._toggleAttr(), this.range = null, this._off(this.document), this._trigger("close", t))
      },
      widget: function () {
        return this.button
      },
      menuWidget: function () {
        return this.menu
      },
      _renderButtonItem: function (t) {
        var e = x("<span>");
        return this._setText(e, t.label), this._addClass(e, "ui-selectmenu-text"), e
      },
      _renderMenu: function (s, t) {
        var n = this,
          a = "";
        x.each(t, function (t, e) {
          var i;
          e.optgroup !== a && (i = x("<li>", {
            text: e.optgroup
          }), n._addClass(i, "ui-selectmenu-optgroup", "ui-menu-divider" + (e.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : "")), i.appendTo(s), a = e.optgroup), n._renderItemData(s, e)
        })
      },
      _renderItemData: function (t, e) {
        return this._renderItem(t, e).data("ui-selectmenu-item", e)
      },
      _renderItem: function (t, e) {
        var i = x("<li>"),
          s = x("<div>", {
            title: e.element.attr("title")
          });
        return e.disabled && this._addClass(i, null, "ui-state-disabled"), this._setText(s, e.label), i.append(s).appendTo(t)
      },
      _setText: function (t, e) {
        e ? t.text(e) : t.html("&#160;")
      },
      _move: function (t, e) {
        var i, s = ".ui-menu-item";
        this.isOpen ? i = this.menuItems.eq(this.focusIndex).parent("li") : (i = this.menuItems.eq(this.element[0].selectedIndex).parent("li"), s += ":not(.ui-state-disabled)"), (s = "first" === t || "last" === t ? i["first" === t ? "prevAll" : "nextAll"](s).eq(-1) : i[t + "All"](s).eq(0)).length && this.menuInstance.focus(e, s)
      },
      _getSelectedItem: function () {
        return this.menuItems.eq(this.element[0].selectedIndex).parent("li")
      },
      _toggle: function (t) {
        this[this.isOpen ? "close" : "open"](t)
      },
      _setSelection: function () {
        var t;
        this.range && (window.getSelection ? ((t = window.getSelection()).removeAllRanges(), t.addRange(this.range)) : this.range.select(), this.button.focus())
      },
      _documentClick: {
        mousedown: function (t) {
          this.isOpen && (x(t.target).closest(".ui-selectmenu-menu, #" + x.ui.escapeSelector(this.ids.button)).length || this.close(t))
        }
      },
      _buttonEvents: {
        mousedown: function () {
          var t;
          window.getSelection ? (t = window.getSelection()).rangeCount && (this.range = t.getRangeAt(0)) : this.range = document.selection.createRange()
        },
        click: function (t) {
          this._setSelection(), this._toggle(t)
        },
        keydown: function (t) {
          var e = !0;
          switch (t.keyCode) {
            case x.ui.keyCode.TAB:
            case x.ui.keyCode.ESCAPE:
              this.close(t), e = !1;
              break;
            case x.ui.keyCode.ENTER:
              this.isOpen && this._selectFocusedItem(t);
              break;
            case x.ui.keyCode.UP:
              t.altKey ? this._toggle(t) : this._move("prev", t);
              break;
            case x.ui.keyCode.DOWN:
              t.altKey ? this._toggle(t) : this._move("next", t);
              break;
            case x.ui.keyCode.SPACE:
              this.isOpen ? this._selectFocusedItem(t) : this._toggle(t);
              break;
            case x.ui.keyCode.LEFT:
              this._move("prev", t);
              break;
            case x.ui.keyCode.RIGHT:
              this._move("next", t);
              break;
            case x.ui.keyCode.HOME:
            case x.ui.keyCode.PAGE_UP:
              this._move("first", t);
              break;
            case x.ui.keyCode.END:
            case x.ui.keyCode.PAGE_DOWN:
              this._move("last", t);
              break;
            default:
              this.menu.trigger(t), e = !1
          }
          e && t.preventDefault()
        }
      },
      _selectFocusedItem: function (t) {
        var e = this.menuItems.eq(this.focusIndex).parent("li");
        e.hasClass("ui-state-disabled") || this._select(e.data("ui-selectmenu-item"), t)
      },
      _select: function (t, e) {
        var i = this.element[0].selectedIndex;
        this.element[0].selectedIndex = t.index, this.buttonItem.replaceWith(this.buttonItem = this._renderButtonItem(t)), this._setAria(t), this._trigger("select", e, {
          item: t
        }), t.index !== i && this._trigger("change", e, {
          item: t
        }), this.close(e)
      },
      _setAria: function (t) {
        t = this.menuItems.eq(t.index).attr("id");
        this.button.attr({
          "aria-labelledby": t,
          "aria-activedescendant": t
        }), this.menu.attr("aria-activedescendant", t)
      },
      _setOption: function (t, e) {
        var i;
        "icons" === t && (i = this.button.find("span.ui-icon"), this._removeClass(i, null, this.options.icons.button)._addClass(i, null, e.button)), this._super(t, e), "appendTo" === t && this.menuWrap.appendTo(this._appendTo()), "width" === t && this._resizeButton()
      },
      _setOptionDisabled: function (t) {
        this._super(t), this.menuInstance.option("disabled", t), this.button.attr("aria-disabled", t), this._toggleClass(this.button, null, "ui-state-disabled", t), this.element.prop("disabled", t), t ? (this.button.attr("tabindex", -1), this.close()) : this.button.attr("tabindex", 0)
      },
      _appendTo: function () {
        var t = this.options.appendTo;
        return t = !(t = !(t = t && (t.jquery || t.nodeType ? x(t) : this.document.find(t).eq(0))) || !t[0] ? this.element.closest(".ui-front, dialog") : t).length ? this.document[0].body : t
      },
      _toggleAttr: function () {
        this.button.attr("aria-expanded", this.isOpen), this._removeClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "closed" : "open"))._addClass(this.button, "ui-selectmenu-button-" + (this.isOpen ? "open" : "closed"))._toggleClass(this.menuWrap, "ui-selectmenu-open", null, this.isOpen), this.menu.attr("aria-hidden", !this.isOpen)
      },
      _resizeButton: function () {
        var t = this.options.width;
        !1 !== t ? (null === t && (t = this.element.show().outerWidth(), this.element.hide()), this.button.outerWidth(t)) : this.button.css("width", "")
      },
      _resizeMenu: function () {
        this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1))
      },
      _getCreateOptions: function () {
        var t = this._super();
        return t.disabled = this.element.prop("disabled"), t
      },
      _parseOptions: function (t) {
        var i = this,
          s = [];
        t.each(function (t, e) {
          s.push(i._parseOption(x(e), t))
        }), this.items = s
      },
      _parseOption: function (t, e) {
        var i = t.parent("optgroup");
        return {
          element: t,
          index: e,
          value: t.val(),
          label: t.text(),
          optgroup: i.attr("label") || "",
          disabled: i.prop("disabled") || t.prop("disabled")
        }
      },
      _destroy: function () {
        this._unbindFormResetHandler(), this.menuWrap.remove(), this.button.remove(), this.element.show(), this.element.removeUniqueId(), this.labels.attr("for", this.ids.element)
      }
    }]), x.widget("ui.slider", x.ui.mouse, {
      version: "1.12.1",
      widgetEventPrefix: "slide",
      options: {
        animate: !1,
        classes: {
          "ui-slider": "ui-corner-all",
          "ui-slider-handle": "ui-corner-all",
          "ui-slider-range": "ui-corner-all ui-widget-header"
        },
        distance: 0,
        max: 100,
        min: 0,
        orientation: "horizontal",
        range: !1,
        step: 1,
        value: 0,
        values: null,
        change: null,
        slide: null,
        start: null,
        stop: null
      },
      numPages: 5,
      _create: function () {
        this._keySliding = !1, this._mouseSliding = !1, this._animateOff = !0, this._handleIndex = null, this._detectOrientation(), this._mouseInit(), this._calculateNewMax(), this._addClass("ui-slider ui-slider-" + this.orientation, "ui-widget ui-widget-content"), this._refresh(), this._animateOff = !1
      },
      _refresh: function () {
        this._createRange(), this._createHandles(), this._setupEvents(), this._refreshValue()
      },
      _createHandles: function () {
        var t, e = this.options,
          i = this.element.find(".ui-slider-handle"),
          s = [],
          n = e.values && e.values.length || 1;
        for (i.length > n && (i.slice(n).remove(), i = i.slice(0, n)), t = i.length; t < n; t++) s.push("<span tabindex='0'></span>");
        this.handles = i.add(x(s.join("")).appendTo(this.element)), this._addClass(this.handles, "ui-slider-handle", "ui-state-default"), this.handle = this.handles.eq(0), this.handles.each(function (t) {
          x(this).data("ui-slider-handle-index", t).attr("tabIndex", 0)
        })
      },
      _createRange: function () {
        var t = this.options;
        t.range ? (!0 === t.range && (t.values ? t.values.length && 2 !== t.values.length ? t.values = [t.values[0], t.values[0]] : x.isArray(t.values) && (t.values = t.values.slice(0)) : t.values = [this._valueMin(), this._valueMin()]), this.range && this.range.length ? (this._removeClass(this.range, "ui-slider-range-min ui-slider-range-max"), this.range.css({
          left: "",
          bottom: ""
        })) : (this.range = x("<div>").appendTo(this.element), this._addClass(this.range, "ui-slider-range")), "min" !== t.range && "max" !== t.range || this._addClass(this.range, "ui-slider-range-" + t.range)) : (this.range && this.range.remove(), this.range = null)
      },
      _setupEvents: function () {
        this._off(this.handles), this._on(this.handles, this._handleEvents), this._hoverable(this.handles), this._focusable(this.handles)
      },
      _destroy: function () {
        this.handles.remove(), this.range && this.range.remove(), this._mouseDestroy()
      },
      _mouseCapture: function (t) {
        var i, s, n, a, e, o, r = this,
          l = this.options;
        return !l.disabled && (this.elementSize = {
          width: this.element.outerWidth(),
          height: this.element.outerHeight()
        }, this.elementOffset = this.element.offset(), o = {
          x: t.pageX,
          y: t.pageY
        }, i = this._normValueFromMouse(o), s = this._valueMax() - this._valueMin() + 1, this.handles.each(function (t) {
          var e = Math.abs(i - r.values(t));
          (e < s || s === e && (t === r._lastChangedValue || r.values(t) === l.min)) && (s = e, n = x(this), a = t)
        }), !1 !== this._start(t, a) && (this._mouseSliding = !0, this._handleIndex = a, this._addClass(n, null, "ui-state-active"), n.trigger("focus"), e = n.offset(), o = !x(t.target).parents().addBack().is(".ui-slider-handle"), this._clickOffset = o ? {
          left: 0,
          top: 0
        } : {
          left: t.pageX - e.left - n.width() / 2,
          top: t.pageY - e.top - n.height() / 2 - (parseInt(n.css("borderTopWidth"), 10) || 0) - (parseInt(n.css("borderBottomWidth"), 10) || 0) + (parseInt(n.css("marginTop"), 10) || 0)
        }, this.handles.hasClass("ui-state-hover") || this._slide(t, a, i), this._animateOff = !0))
      },
      _mouseStart: function () {
        return !0
      },
      _mouseDrag: function (t) {
        var e = {
            x: t.pageX,
            y: t.pageY
          },
          e = this._normValueFromMouse(e);
        return this._slide(t, this._handleIndex, e), !1
      },
      _mouseStop: function (t) {
        return this._removeClass(this.handles, null, "ui-state-active"), this._mouseSliding = !1, this._stop(t, this._handleIndex), this._change(t, this._handleIndex), this._handleIndex = null, this._clickOffset = null, this._animateOff = !1
      },
      _detectOrientation: function () {
        this.orientation = "vertical" === this.options.orientation ? "vertical" : "horizontal"
      },
      _normValueFromMouse: function (t) {
        var e, t = "horizontal" === this.orientation ? (e = this.elementSize.width, t.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (e = this.elementSize.height, t.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0));
        return (t = 1 < (t = t / e) ? 1 : t) < 0 && (t = 0), "vertical" === this.orientation && (t = 1 - t), e = this._valueMax() - this._valueMin(), e = this._valueMin() + t * e, this._trimAlignValue(e)
      },
      _uiHash: function (t, e, i) {
        var s = {
          handle: this.handles[t],
          handleIndex: t,
          value: void 0 !== e ? e : this.value()
        };
        return this._hasMultipleValues() && (s.value = void 0 !== e ? e : this.values(t), s.values = i || this.values()), s
      },
      _hasMultipleValues: function () {
        return this.options.values && this.options.values.length
      },
      _start: function (t, e) {
        return this._trigger("start", t, this._uiHash(e))
      },
      _slide: function (t, e, i) {
        var s, n = this.value(),
          a = this.values();
        this._hasMultipleValues() && (s = this.values(e ? 0 : 1), n = this.values(e), 2 === this.options.values.length && !0 === this.options.range && (i = 0 === e ? Math.min(s, i) : Math.max(s, i)), a[e] = i), i !== n && !1 !== this._trigger("slide", t, this._uiHash(e, i, a)) && (this._hasMultipleValues() ? this.values(e, i) : this.value(i))
      },
      _stop: function (t, e) {
        this._trigger("stop", t, this._uiHash(e))
      },
      _change: function (t, e) {
        this._keySliding || this._mouseSliding || (this._lastChangedValue = e, this._trigger("change", t, this._uiHash(e)))
      },
      value: function (t) {
        return arguments.length ? (this.options.value = this._trimAlignValue(t), this._refreshValue(), void this._change(null, 0)) : this._value()
      },
      values: function (t, e) {
        var i, s, n;
        if (1 < arguments.length) return this.options.values[t] = this._trimAlignValue(e), this._refreshValue(), void this._change(null, t);
        if (!arguments.length) return this._values();
        if (!x.isArray(t)) return this._hasMultipleValues() ? this._values(t) : this.value();
        for (i = this.options.values, s = t, n = 0; n < i.length; n += 1) i[n] = this._trimAlignValue(s[n]), this._change(null, n);
        this._refreshValue()
      },
      _setOption: function (t, e) {
        var i, s = 0;
        switch ("range" === t && !0 === this.options.range && ("min" === e ? (this.options.value = this._values(0), this.options.values = null) : "max" === e && (this.options.value = this._values(this.options.values.length - 1), this.options.values = null)), x.isArray(this.options.values) && (s = this.options.values.length), this._super(t, e), t) {
          case "orientation":
            this._detectOrientation(), this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-" + this.orientation), this._refreshValue(), this.options.range && this._refreshRange(e), this.handles.css("horizontal" === e ? "bottom" : "left", "");
            break;
          case "value":
            this._animateOff = !0, this._refreshValue(), this._change(null, 0), this._animateOff = !1;
            break;
          case "values":
            for (this._animateOff = !0, this._refreshValue(), i = s - 1; 0 <= i; i--) this._change(null, i);
            this._animateOff = !1;
            break;
          case "step":
          case "min":
          case "max":
            this._animateOff = !0, this._calculateNewMax(), this._refreshValue(), this._animateOff = !1;
            break;
          case "range":
            this._animateOff = !0, this._refresh(), this._animateOff = !1
        }
      },
      _setOptionDisabled: function (t) {
        this._super(t), this._toggleClass(null, "ui-state-disabled", !!t)
      },
      _value: function () {
        var t = this.options.value;
        return this._trimAlignValue(t)
      },
      _values: function (t) {
        var e, i, s;
        if (arguments.length) return e = this.options.values[t], this._trimAlignValue(e);
        if (this._hasMultipleValues()) {
          for (i = this.options.values.slice(), s = 0; s < i.length; s += 1) i[s] = this._trimAlignValue(i[s]);
          return i
        }
        return []
      },
      _trimAlignValue: function (t) {
        if (t <= this._valueMin()) return this._valueMin();
        if (t >= this._valueMax()) return this._valueMax();
        var e = 0 < this.options.step ? this.options.step : 1,
          i = (t - this._valueMin()) % e,
          t = t - i;
        return 2 * Math.abs(i) >= e && (t += 0 < i ? e : -e), parseFloat(t.toFixed(5))
      },
      _calculateNewMax: function () {
        var t = this.options.max,
          e = this._valueMin(),
          i = this.options.step;
        (t = Math.round((t - e) / i) * i + e) > this.options.max && (t -= i), this.max = parseFloat(t.toFixed(this._precision()))
      },
      _precision: function () {
        var t = this._precisionOf(this.options.step);
        return t = null !== this.options.min ? Math.max(t, this._precisionOf(this.options.min)) : t
      },
      _precisionOf: function (t) {
        var e = t.toString(),
          t = e.indexOf(".");
        return -1 === t ? 0 : e.length - t - 1
      },
      _valueMin: function () {
        return this.options.min
      },
      _valueMax: function () {
        return this.max
      },
      _refreshRange: function (t) {
        "vertical" === t && this.range.css({
          width: "",
          left: ""
        }), "horizontal" === t && this.range.css({
          height: "",
          bottom: ""
        })
      },
      _refreshValue: function () {
        var e, i, t, s, n, a = this.options.range,
          o = this.options,
          r = this,
          l = !this._animateOff && o.animate,
          c = {};
        this._hasMultipleValues() ? this.handles.each(function (t) {
          i = (r.values(t) - r._valueMin()) / (r._valueMax() - r._valueMin()) * 100, c["horizontal" === r.orientation ? "left" : "bottom"] = i + "%", x(this).stop(1, 1)[l ? "animate" : "css"](c, o.animate), !0 === r.options.range && ("horizontal" === r.orientation ? (0 === t && r.range.stop(1, 1)[l ? "animate" : "css"]({
            left: i + "%"
          }, o.animate), 1 === t && r.range[l ? "animate" : "css"]({
            width: i - e + "%"
          }, {
            queue: !1,
            duration: o.animate
          })) : (0 === t && r.range.stop(1, 1)[l ? "animate" : "css"]({
            bottom: i + "%"
          }, o.animate), 1 === t && r.range[l ? "animate" : "css"]({
            height: i - e + "%"
          }, {
            queue: !1,
            duration: o.animate
          }))), e = i
        }) : (t = this.value(), s = this._valueMin(), n = this._valueMax(), i = n !== s ? (t - s) / (n - s) * 100 : 0, c["horizontal" === this.orientation ? "left" : "bottom"] = i + "%", this.handle.stop(1, 1)[l ? "animate" : "css"](c, o.animate), "min" === a && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
          width: i + "%"
        }, o.animate), "max" === a && "horizontal" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
          width: 100 - i + "%"
        }, o.animate), "min" === a && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
          height: i + "%"
        }, o.animate), "max" === a && "vertical" === this.orientation && this.range.stop(1, 1)[l ? "animate" : "css"]({
          height: 100 - i + "%"
        }, o.animate))
      },
      _handleEvents: {
        keydown: function (t) {
          var e, i, s, n = x(t.target).data("ui-slider-handle-index");
          switch (t.keyCode) {
            case x.ui.keyCode.HOME:
            case x.ui.keyCode.END:
            case x.ui.keyCode.PAGE_UP:
            case x.ui.keyCode.PAGE_DOWN:
            case x.ui.keyCode.UP:
            case x.ui.keyCode.RIGHT:
            case x.ui.keyCode.DOWN:
            case x.ui.keyCode.LEFT:
              if (t.preventDefault(), !this._keySliding && (this._keySliding = !0, this._addClass(x(t.target), null, "ui-state-active"), !1 === this._start(t, n))) return
          }
          switch (s = this.options.step, e = i = this._hasMultipleValues() ? this.values(n) : this.value(), t.keyCode) {
            case x.ui.keyCode.HOME:
              i = this._valueMin();
              break;
            case x.ui.keyCode.END:
              i = this._valueMax();
              break;
            case x.ui.keyCode.PAGE_UP:
              i = this._trimAlignValue(e + (this._valueMax() - this._valueMin()) / this.numPages);
              break;
            case x.ui.keyCode.PAGE_DOWN:
              i = this._trimAlignValue(e - (this._valueMax() - this._valueMin()) / this.numPages);
              break;
            case x.ui.keyCode.UP:
            case x.ui.keyCode.RIGHT:
              if (e === this._valueMax()) return;
              i = this._trimAlignValue(e + s);
              break;
            case x.ui.keyCode.DOWN:
            case x.ui.keyCode.LEFT:
              if (e === this._valueMin()) return;
              i = this._trimAlignValue(e - s)
          }
          this._slide(t, n, i)
        },
        keyup: function (t) {
          var e = x(t.target).data("ui-slider-handle-index");
          this._keySliding && (this._keySliding = !1, this._stop(t, e), this._change(t, e), this._removeClass(x(t.target), null, "ui-state-active"))
        }
      }
    }), x.widget("ui.sortable", x.ui.mouse, {
      version: "1.12.1",
      widgetEventPrefix: "sort",
      ready: !1,
      options: {
        appendTo: "parent",
        axis: !1,
        connectWith: !1,
        containment: !1,
        cursor: "auto",
        cursorAt: !1,
        dropOnEmpty: !0,
        forcePlaceholderSize: !1,
        forceHelperSize: !1,
        grid: !1,
        handle: !1,
        helper: "original",
        items: "> *",
        opacity: !1,
        placeholder: !1,
        revert: !1,
        scroll: !0,
        scrollSensitivity: 20,
        scrollSpeed: 20,
        scope: "default",
        tolerance: "intersect",
        zIndex: 1e3,
        activate: null,
        beforeStop: null,
        change: null,
        deactivate: null,
        out: null,
        over: null,
        receive: null,
        remove: null,
        sort: null,
        start: null,
        stop: null,
        update: null
      },
      _isOverAxis: function (t, e, i) {
        return e <= t && t < e + i
      },
      _isFloating: function (t) {
        return /left|right/.test(t.css("float")) || /inline|table-cell/.test(t.css("display"))
      },
      _create: function () {
        this.containerCache = {}, this._addClass("ui-sortable"), this.refresh(), this.offset = this.element.offset(), this._mouseInit(), this._setHandleClassName(), this.ready = !0
      },
      _setOption: function (t, e) {
        this._super(t, e), "handle" === t && this._setHandleClassName()
      },
      _setHandleClassName: function () {
        var t = this;
        this._removeClass(this.element.find(".ui-sortable-handle"), "ui-sortable-handle"), x.each(this.items, function () {
          t._addClass(this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item, "ui-sortable-handle")
        })
      },
      _destroy: function () {
        this._mouseDestroy();
        for (var t = this.items.length - 1; 0 <= t; t--) this.items[t].item.removeData(this.widgetName + "-item");
        return this
      },
      _mouseCapture: function (t, e) {
        var i = null,
          s = !1,
          n = this;
        return !(this.reverting || this.options.disabled || "static" === this.options.type || (this._refreshItems(t), x(t.target).parents().each(function () {
          if (x.data(this, n.widgetName + "-item") === n) return i = x(this), !1
        }), !(i = x.data(t.target, n.widgetName + "-item") === n ? x(t.target) : i) || this.options.handle && !e && (x(this.options.handle, i).find("*").addBack().each(function () {
          this === t.target && (s = !0)
        }), !s) || (this.currentItem = i, this._removeCurrentsFromItems(), 0)))
      },
      _mouseStart: function (t, e, i) {
        var s, n, a = this.options;
        if ((this.currentContainer = this).refreshPositions(), this.helper = this._createHelper(t), this._cacheHelperProportions(), this._cacheMargins(), this.scrollParent = this.helper.scrollParent(), this.offset = this.currentItem.offset(), this.offset = {
            top: this.offset.top - this.margins.top,
            left: this.offset.left - this.margins.left
          }, x.extend(this.offset, {
            click: {
              left: t.pageX - this.offset.left,
              top: t.pageY - this.offset.top
            },
            parent: this._getParentOffset(),
            relative: this._getRelativeOffset()
          }), this.helper.css("position", "absolute"), this.cssPosition = this.helper.css("position"), this.originalPosition = this._generatePosition(t), this.originalPageX = t.pageX, this.originalPageY = t.pageY, a.cursorAt && this._adjustOffsetFromHelper(a.cursorAt), this.domPosition = {
            prev: this.currentItem.prev()[0],
            parent: this.currentItem.parent()[0]
          }, this.helper[0] !== this.currentItem[0] && this.currentItem.hide(), this._createPlaceholder(), a.containment && this._setContainment(), a.cursor && "auto" !== a.cursor && (n = this.document.find("body"), this.storedCursor = n.css("cursor"), n.css("cursor", a.cursor), this.storedStylesheet = x("<style>*{ cursor: " + a.cursor + " !important; }</style>").appendTo(n)), a.opacity && (this.helper.css("opacity") && (this._storedOpacity = this.helper.css("opacity")), this.helper.css("opacity", a.opacity)), a.zIndex && (this.helper.css("zIndex") && (this._storedZIndex = this.helper.css("zIndex")), this.helper.css("zIndex", a.zIndex)), this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName && (this.overflowOffset = this.scrollParent.offset()), this._trigger("start", t, this._uiHash()), this._preserveHelperProportions || this._cacheHelperProportions(), !i)
          for (s = this.containers.length - 1; 0 <= s; s--) this.containers[s]._trigger("activate", t, this._uiHash(this));
        return x.ui.ddmanager && (x.ui.ddmanager.current = this), x.ui.ddmanager && !a.dropBehaviour && x.ui.ddmanager.prepareOffsets(this, t), this.dragging = !0, this._addClass(this.helper, "ui-sortable-helper"), this._mouseDrag(t), !0
      },
      _mouseDrag: function (t) {
        var e, i, s, n, a = this.options,
          o = !1;
        for (this.position = this._generatePosition(t), this.positionAbs = this._convertPositionTo("absolute"), this.lastPositionAbs || (this.lastPositionAbs = this.positionAbs), this.options.scroll && (this.scrollParent[0] !== this.document[0] && "HTML" !== this.scrollParent[0].tagName ? (this.overflowOffset.top + this.scrollParent[0].offsetHeight - t.pageY < a.scrollSensitivity ? this.scrollParent[0].scrollTop = o = this.scrollParent[0].scrollTop + a.scrollSpeed : t.pageY - this.overflowOffset.top < a.scrollSensitivity && (this.scrollParent[0].scrollTop = o = this.scrollParent[0].scrollTop - a.scrollSpeed), this.overflowOffset.left + this.scrollParent[0].offsetWidth - t.pageX < a.scrollSensitivity ? this.scrollParent[0].scrollLeft = o = this.scrollParent[0].scrollLeft + a.scrollSpeed : t.pageX - this.overflowOffset.left < a.scrollSensitivity && (this.scrollParent[0].scrollLeft = o = this.scrollParent[0].scrollLeft - a.scrollSpeed)) : (t.pageY - this.document.scrollTop() < a.scrollSensitivity ? o = this.document.scrollTop(this.document.scrollTop() - a.scrollSpeed) : this.window.height() - (t.pageY - this.document.scrollTop()) < a.scrollSensitivity && (o = this.document.scrollTop(this.document.scrollTop() + a.scrollSpeed)), t.pageX - this.document.scrollLeft() < a.scrollSensitivity ? o = this.document.scrollLeft(this.document.scrollLeft() - a.scrollSpeed) : this.window.width() - (t.pageX - this.document.scrollLeft()) < a.scrollSensitivity && (o = this.document.scrollLeft(this.document.scrollLeft() + a.scrollSpeed))), !1 !== o && x.ui.ddmanager && !a.dropBehaviour && x.ui.ddmanager.prepareOffsets(this, t)), this.positionAbs = this._convertPositionTo("absolute"), this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), e = this.items.length - 1; 0 <= e; e--)
          if (s = (i = this.items[e]).item[0], (n = this._intersectsWithPointer(i)) && i.instance === this.currentContainer && !(s === this.currentItem[0] || this.placeholder[1 === n ? "next" : "prev"]()[0] === s || x.contains(this.placeholder[0], s) || "semi-dynamic" === this.options.type && x.contains(this.element[0], s))) {
            if (this.direction = 1 === n ? "down" : "up", "pointer" !== this.options.tolerance && !this._intersectsWithSides(i)) break;
            this._rearrange(t, i), this._trigger("change", t, this._uiHash());
            break
          } return this._contactContainers(t), x.ui.ddmanager && x.ui.ddmanager.drag(this, t), this._trigger("sort", t, this._uiHash()), this.lastPositionAbs = this.positionAbs, !1
      },
      _mouseStop: function (t, e) {
        var i, s, n, a;
        if (t) return x.ui.ddmanager && !this.options.dropBehaviour && x.ui.ddmanager.drop(this, t), this.options.revert ? (s = (i = this).placeholder.offset(), a = {}, (n = this.options.axis) && "x" !== n || (a.left = s.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft)), n && "y" !== n || (a.top = s.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop)), this.reverting = !0, x(this.helper).animate(a, parseInt(this.options.revert, 10) || 500, function () {
          i._clear(t)
        })) : this._clear(t, e), !1
      },
      cancel: function () {
        if (this.dragging) {
          this._mouseUp(new x.Event("mouseup", {
            target: null
          })), "original" === this.options.helper ? (this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper")) : this.currentItem.show();
          for (var t = this.containers.length - 1; 0 <= t; t--) this.containers[t]._trigger("deactivate", null, this._uiHash(this)), this.containers[t].containerCache.over && (this.containers[t]._trigger("out", null, this._uiHash(this)), this.containers[t].containerCache.over = 0)
        }
        return this.placeholder && (this.placeholder[0].parentNode && this.placeholder[0].parentNode.removeChild(this.placeholder[0]), "original" !== this.options.helper && this.helper && this.helper[0].parentNode && this.helper.remove(), x.extend(this, {
          helper: null,
          dragging: !1,
          reverting: !1,
          _noFinalSort: null
        }), this.domPosition.prev ? x(this.domPosition.prev).after(this.currentItem) : x(this.domPosition.parent).prepend(this.currentItem)), this
      },
      serialize: function (e) {
        var t = this._getItemsAsjQuery(e && e.connected),
          i = [];
        return e = e || {}, x(t).each(function () {
          var t = (x(e.item || this).attr(e.attribute || "id") || "").match(e.expression || /(.+)[\-=_](.+)/);
          t && i.push((e.key || t[1] + "[]") + "=" + (e.key && e.expression ? t[1] : t[2]))
        }), !i.length && e.key && i.push(e.key + "="), i.join("&")
      },
      toArray: function (t) {
        var e = this._getItemsAsjQuery(t && t.connected),
          i = [];
        return t = t || {}, e.each(function () {
          i.push(x(t.item || this).attr(t.attribute || "id") || "")
        }), i
      },
      _intersectsWith: function (t) {
        var e = this.positionAbs.left,
          i = e + this.helperProportions.width,
          s = this.positionAbs.top,
          n = s + this.helperProportions.height,
          a = t.left,
          o = a + t.width,
          r = t.top,
          l = r + t.height,
          c = this.offset.click.top,
          d = this.offset.click.left,
          c = "x" === this.options.axis || r < s + c && s + c < l,
          d = "y" === this.options.axis || a < e + d && e + d < o;
        return "pointer" === this.options.tolerance || this.options.forcePointerForContainers || "pointer" !== this.options.tolerance && this.helperProportions[this.floating ? "width" : "height"] > t[this.floating ? "width" : "height"] ? c && d : a < e + this.helperProportions.width / 2 && i - this.helperProportions.width / 2 < o && r < s + this.helperProportions.height / 2 && n - this.helperProportions.height / 2 < l
      },
      _intersectsWithPointer: function (t) {
        var e = "x" === this.options.axis || this._isOverAxis(this.positionAbs.top + this.offset.click.top, t.top, t.height),
          t = "y" === this.options.axis || this._isOverAxis(this.positionAbs.left + this.offset.click.left, t.left, t.width);
        return !(!e || !t) && (e = this._getDragVerticalDirection(), t = this._getDragHorizontalDirection(), this.floating ? "right" === t || "down" === e ? 2 : 1 : e && ("down" === e ? 2 : 1))
      },
      _intersectsWithSides: function (t) {
        var e = this._isOverAxis(this.positionAbs.top + this.offset.click.top, t.top + t.height / 2, t.height),
          i = this._isOverAxis(this.positionAbs.left + this.offset.click.left, t.left + t.width / 2, t.width),
          s = this._getDragVerticalDirection(),
          t = this._getDragHorizontalDirection();
        return this.floating && t ? "right" === t && i || "left" === t && !i : s && ("down" === s && e || "up" === s && !e)
      },
      _getDragVerticalDirection: function () {
        var t = this.positionAbs.top - this.lastPositionAbs.top;
        return 0 != t && (0 < t ? "down" : "up")
      },
      _getDragHorizontalDirection: function () {
        var t = this.positionAbs.left - this.lastPositionAbs.left;
        return 0 != t && (0 < t ? "right" : "left")
      },
      refresh: function (t) {
        return this._refreshItems(t), this._setHandleClassName(), this.refreshPositions(), this
      },
      _connectWith: function () {
        var t = this.options;
        return t.connectWith.constructor === String ? [t.connectWith] : t.connectWith
      },
      _getItemsAsjQuery: function (t) {
        var e, i, s, n, a = [],
          o = [],
          r = this._connectWith();
        if (r && t)
          for (e = r.length - 1; 0 <= e; e--)
            for (i = (s = x(r[e], this.document[0])).length - 1; 0 <= i; i--)(n = x.data(s[i], this.widgetFullName)) && n !== this && !n.options.disabled && o.push([x.isFunction(n.options.items) ? n.options.items.call(n.element) : x(n.options.items, n.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), n]);

        function l() {
          a.push(this)
        }
        for (o.push([x.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
            options: this.options,
            item: this.currentItem
          }) : x(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]), e = o.length - 1; 0 <= e; e--) o[e][0].each(l);
        return x(a)
      },
      _removeCurrentsFromItems: function () {
        var i = this.currentItem.find(":data(" + this.widgetName + "-item)");
        this.items = x.grep(this.items, function (t) {
          for (var e = 0; e < i.length; e++)
            if (i[e] === t.item[0]) return !1;
          return !0
        })
      },
      _refreshItems: function (t) {
        this.items = [], this.containers = [this];
        var e, i, s, n, a, o, r, l, c = this.items,
          d = [
            [x.isFunction(this.options.items) ? this.options.items.call(this.element[0], t, {
              item: this.currentItem
            }) : x(this.options.items, this.element), this]
          ],
          h = this._connectWith();
        if (h && this.ready)
          for (e = h.length - 1; 0 <= e; e--)
            for (i = (s = x(h[e], this.document[0])).length - 1; 0 <= i; i--)(n = x.data(s[i], this.widgetFullName)) && n !== this && !n.options.disabled && (d.push([x.isFunction(n.options.items) ? n.options.items.call(n.element[0], t, {
              item: this.currentItem
            }) : x(n.options.items, n.element), n]), this.containers.push(n));
        for (e = d.length - 1; 0 <= e; e--)
          for (a = d[e][1], l = (o = d[e][i = 0]).length; i < l; i++)(r = x(o[i])).data(this.widgetName + "-item", a), c.push({
            item: r,
            instance: a,
            width: 0,
            height: 0,
            left: 0,
            top: 0
          })
      },
      refreshPositions: function (t) {
        var e, i, s, n;
        for (this.floating = !!this.items.length && ("x" === this.options.axis || this._isFloating(this.items[0].item)), this.offsetParent && this.helper && (this.offset.parent = this._getParentOffset()), e = this.items.length - 1; 0 <= e; e--)(i = this.items[e]).instance !== this.currentContainer && this.currentContainer && i.item[0] !== this.currentItem[0] || (s = this.options.toleranceElement ? x(this.options.toleranceElement, i.item) : i.item, t || (i.width = s.outerWidth(), i.height = s.outerHeight()), n = s.offset(), i.left = n.left, i.top = n.top);
        if (this.options.custom && this.options.custom.refreshContainers) this.options.custom.refreshContainers.call(this);
        else
          for (e = this.containers.length - 1; 0 <= e; e--) n = this.containers[e].element.offset(), this.containers[e].containerCache.left = n.left, this.containers[e].containerCache.top = n.top, this.containers[e].containerCache.width = this.containers[e].element.outerWidth(), this.containers[e].containerCache.height = this.containers[e].element.outerHeight();
        return this
      },
      _createPlaceholder: function (i) {
        var s, n = (i = i || this).options;
        n.placeholder && n.placeholder.constructor !== String || (s = n.placeholder, n.placeholder = {
          element: function () {
            var t = i.currentItem[0].nodeName.toLowerCase(),
              e = x("<" + t + ">", i.document[0]);
            return i._addClass(e, "ui-sortable-placeholder", s || i.currentItem[0].className)._removeClass(e, "ui-sortable-helper"), "tbody" === t ? i._createTrPlaceholder(i.currentItem.find("tr").eq(0), x("<tr>", i.document[0]).appendTo(e)) : "tr" === t ? i._createTrPlaceholder(i.currentItem, e) : "img" === t && e.attr("src", i.currentItem.attr("src")), s || e.css("visibility", "hidden"), e
          },
          update: function (t, e) {
            s && !n.forcePlaceholderSize || (e.height() || e.height(i.currentItem.innerHeight() - parseInt(i.currentItem.css("paddingTop") || 0, 10) - parseInt(i.currentItem.css("paddingBottom") || 0, 10)), e.width() || e.width(i.currentItem.innerWidth() - parseInt(i.currentItem.css("paddingLeft") || 0, 10) - parseInt(i.currentItem.css("paddingRight") || 0, 10)))
          }
        }), i.placeholder = x(n.placeholder.element.call(i.element, i.currentItem)), i.currentItem.after(i.placeholder), n.placeholder.update(i, i.placeholder)
      },
      _createTrPlaceholder: function (t, e) {
        var i = this;
        t.children().each(function () {
          x("<td>&#160;</td>", i.document[0]).attr("colspan", x(this).attr("colspan") || 1).appendTo(e)
        })
      },
      _contactContainers: function (t) {
        for (var e, i, s, n, a, o, r, l, c, d = null, h = null, u = this.containers.length - 1; 0 <= u; u--)
          if (!x.contains(this.currentItem[0], this.containers[u].element[0]))
            if (this._intersectsWith(this.containers[u].containerCache)) {
              if (d && x.contains(this.containers[u].element[0], d.element[0])) continue;
              d = this.containers[u], h = u
            } else this.containers[u].containerCache.over && (this.containers[u]._trigger("out", t, this._uiHash(this)), this.containers[u].containerCache.over = 0);
        if (d)
          if (1 === this.containers.length) this.containers[h].containerCache.over || (this.containers[h]._trigger("over", t, this._uiHash(this)), this.containers[h].containerCache.over = 1);
          else {
            for (i = 1e4, s = null, n = (l = d.floating || this._isFloating(this.currentItem)) ? "left" : "top", a = l ? "width" : "height", c = l ? "pageX" : "pageY", e = this.items.length - 1; 0 <= e; e--) x.contains(this.containers[h].element[0], this.items[e].item[0]) && this.items[e].item[0] !== this.currentItem[0] && (o = this.items[e].item.offset()[n], r = !1, t[c] - o > this.items[e][a] / 2 && (r = !0), Math.abs(t[c] - o) < i && (i = Math.abs(t[c] - o), s = this.items[e], this.direction = r ? "up" : "down"));
            (s || this.options.dropOnEmpty) && (this.currentContainer !== this.containers[h] ? (s ? this._rearrange(t, s, null, !0) : this._rearrange(t, null, this.containers[h].element, !0), this._trigger("change", t, this._uiHash()), this.containers[h]._trigger("change", t, this._uiHash(this)), this.currentContainer = this.containers[h], this.options.placeholder.update(this.currentContainer, this.placeholder), this.containers[h]._trigger("over", t, this._uiHash(this)), this.containers[h].containerCache.over = 1) : this.currentContainer.containerCache.over || (this.containers[h]._trigger("over", t, this._uiHash()), this.currentContainer.containerCache.over = 1))
          }
      },
      _createHelper: function (t) {
        var e = this.options,
          t = x.isFunction(e.helper) ? x(e.helper.apply(this.element[0], [t, this.currentItem])) : "clone" === e.helper ? this.currentItem.clone() : this.currentItem;
        return t.parents("body").length || x("parent" !== e.appendTo ? e.appendTo : this.currentItem[0].parentNode)[0].appendChild(t[0]), t[0] === this.currentItem[0] && (this._storedCSS = {
          width: this.currentItem[0].style.width,
          height: this.currentItem[0].style.height,
          position: this.currentItem.css("position"),
          top: this.currentItem.css("top"),
          left: this.currentItem.css("left")
        }), t[0].style.width && !e.forceHelperSize || t.width(this.currentItem.width()), t[0].style.height && !e.forceHelperSize || t.height(this.currentItem.height()), t
      },
      _adjustOffsetFromHelper: function (t) {
        "string" == typeof t && (t = t.split(" ")), "left" in (t = x.isArray(t) ? {
          left: +t[0],
          top: +t[1] || 0
        } : t) && (this.offset.click.left = t.left + this.margins.left), "right" in t && (this.offset.click.left = this.helperProportions.width - t.right + this.margins.left), "top" in t && (this.offset.click.top = t.top + this.margins.top), "bottom" in t && (this.offset.click.top = this.helperProportions.height - t.bottom + this.margins.top)
      },
      _getParentOffset: function () {
        this.offsetParent = this.helper.offsetParent();
        var t = this.offsetParent.offset();
        return "absolute" === this.cssPosition && this.scrollParent[0] !== this.document[0] && x.contains(this.scrollParent[0], this.offsetParent[0]) && (t.left += this.scrollParent.scrollLeft(), t.top += this.scrollParent.scrollTop()), {
          top: (t = this.offsetParent[0] === this.document[0].body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && x.ui.ie ? {
            top: 0,
            left: 0
          } : t).top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
          left: t.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
        }
      },
      _getRelativeOffset: function () {
        if ("relative" !== this.cssPosition) return {
          top: 0,
          left: 0
        };
        var t = this.currentItem.position();
        return {
          top: t.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
          left: t.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
        }
      },
      _cacheMargins: function () {
        this.margins = {
          left: parseInt(this.currentItem.css("marginLeft"), 10) || 0,
          top: parseInt(this.currentItem.css("marginTop"), 10) || 0
        }
      },
      _cacheHelperProportions: function () {
        this.helperProportions = {
          width: this.helper.outerWidth(),
          height: this.helper.outerHeight()
        }
      },
      _setContainment: function () {
        var t, e, i = this.options;
        "parent" === i.containment && (i.containment = this.helper[0].parentNode), "document" !== i.containment && "window" !== i.containment || (this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, "document" === i.containment ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left, ("document" === i.containment ? this.document.height() || document.body.parentNode.scrollHeight : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top]), /^(document|window|parent)$/.test(i.containment) || (t = x(i.containment)[0], e = x(i.containment).offset(), i = "hidden" !== x(t).css("overflow"), this.containment = [e.left + (parseInt(x(t).css("borderLeftWidth"), 10) || 0) + (parseInt(x(t).css("paddingLeft"), 10) || 0) - this.margins.left, e.top + (parseInt(x(t).css("borderTopWidth"), 10) || 0) + (parseInt(x(t).css("paddingTop"), 10) || 0) - this.margins.top, e.left + (i ? Math.max(t.scrollWidth, t.offsetWidth) : t.offsetWidth) - (parseInt(x(t).css("borderLeftWidth"), 10) || 0) - (parseInt(x(t).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, e.top + (i ? Math.max(t.scrollHeight, t.offsetHeight) : t.offsetHeight) - (parseInt(x(t).css("borderTopWidth"), 10) || 0) - (parseInt(x(t).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top])
      },
      _convertPositionTo: function (t, e) {
        e = e || this.position;
        var i = "absolute" === t ? 1 : -1,
          s = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && x.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
          t = /(html|body)/i.test(s[0].tagName);
        return {
          top: e.top + this.offset.relative.top * i + this.offset.parent.top * i - ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : t ? 0 : s.scrollTop()) * i,
          left: e.left + this.offset.relative.left * i + this.offset.parent.left * i - ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : t ? 0 : s.scrollLeft()) * i
        }
      },
      _generatePosition: function (t) {
        var e = this.options,
          i = t.pageX,
          s = t.pageY,
          n = "absolute" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && x.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent,
          a = /(html|body)/i.test(n[0].tagName);
        return "relative" !== this.cssPosition || this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0] || (this.offset.relative = this._getRelativeOffset()), this.originalPosition && (this.containment && (t.pageX - this.offset.click.left < this.containment[0] && (i = this.containment[0] + this.offset.click.left), t.pageY - this.offset.click.top < this.containment[1] && (s = this.containment[1] + this.offset.click.top), t.pageX - this.offset.click.left > this.containment[2] && (i = this.containment[2] + this.offset.click.left), t.pageY - this.offset.click.top > this.containment[3] && (s = this.containment[3] + this.offset.click.top)), e.grid && (t = this.originalPageY + Math.round((s - this.originalPageY) / e.grid[1]) * e.grid[1], s = !this.containment || t - this.offset.click.top >= this.containment[1] && t - this.offset.click.top <= this.containment[3] ? t : t - this.offset.click.top >= this.containment[1] ? t - e.grid[1] : t + e.grid[1], t = this.originalPageX + Math.round((i - this.originalPageX) / e.grid[0]) * e.grid[0], i = !this.containment || t - this.offset.click.left >= this.containment[0] && t - this.offset.click.left <= this.containment[2] ? t : t - this.offset.click.left >= this.containment[0] ? t - e.grid[0] : t + e.grid[0])), {
          top: s - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : a ? 0 : n.scrollTop()),
          left: i - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : a ? 0 : n.scrollLeft())
        }
      },
      _rearrange: function (t, e, i, s) {
        i ? i[0].appendChild(this.placeholder[0]) : e.item[0].parentNode.insertBefore(this.placeholder[0], "down" === this.direction ? e.item[0] : e.item[0].nextSibling), this.counter = this.counter ? ++this.counter : 1;
        var n = this.counter;
        this._delay(function () {
          n === this.counter && this.refreshPositions(!s)
        })
      },
      _clear: function (t, e) {
        this.reverting = !1;
        var i, s = [];
        if (!this._noFinalSort && this.currentItem.parent().length && this.placeholder.before(this.currentItem), this._noFinalSort = null, this.helper[0] === this.currentItem[0]) {
          for (i in this._storedCSS) "auto" !== this._storedCSS[i] && "static" !== this._storedCSS[i] || (this._storedCSS[i] = "");
          this.currentItem.css(this._storedCSS), this._removeClass(this.currentItem, "ui-sortable-helper")
        } else this.currentItem.show();

        function n(e, i, s) {
          return function (t) {
            s._trigger(e, t, i._uiHash(i))
          }
        }
        for (this.fromOutside && !e && s.push(function (t) {
            this._trigger("receive", t, this._uiHash(this.fromOutside))
          }), !this.fromOutside && this.domPosition.prev === this.currentItem.prev().not(".ui-sortable-helper")[0] && this.domPosition.parent === this.currentItem.parent()[0] || e || s.push(function (t) {
            this._trigger("update", t, this._uiHash())
          }), this !== this.currentContainer && (e || (s.push(function (t) {
            this._trigger("remove", t, this._uiHash())
          }), s.push(function (e) {
            return function (t) {
              e._trigger("receive", t, this._uiHash(this))
            }
          }.call(this, this.currentContainer)), s.push(function (e) {
            return function (t) {
              e._trigger("update", t, this._uiHash(this))
            }
          }.call(this, this.currentContainer)))), i = this.containers.length - 1; 0 <= i; i--) e || s.push(n("deactivate", this, this.containers[i])), this.containers[i].containerCache.over && (s.push(n("out", this, this.containers[i])), this.containers[i].containerCache.over = 0);
        if (this.storedCursor && (this.document.find("body").css("cursor", this.storedCursor), this.storedStylesheet.remove()), this._storedOpacity && this.helper.css("opacity", this._storedOpacity), this._storedZIndex && this.helper.css("zIndex", "auto" === this._storedZIndex ? "" : this._storedZIndex), this.dragging = !1, e || this._trigger("beforeStop", t, this._uiHash()), this.placeholder[0].parentNode.removeChild(this.placeholder[0]), this.cancelHelperRemoval || (this.helper[0] !== this.currentItem[0] && this.helper.remove(), this.helper = null), !e) {
          for (i = 0; i < s.length; i++) s[i].call(this, t);
          this._trigger("stop", t, this._uiHash())
        }
        return this.fromOutside = !1, !this.cancelHelperRemoval
      },
      _trigger: function () {
        !1 === x.Widget.prototype._trigger.apply(this, arguments) && this.cancel()
      },
      _uiHash: function (t) {
        var e = t || this;
        return {
          helper: e.helper,
          placeholder: e.placeholder || x([]),
          position: e.position,
          originalPosition: e.originalPosition,
          offset: e.positionAbs,
          item: e.currentItem,
          sender: t ? t.element : null
        }
      }
    }), x.widget("ui.spinner", {
      version: "1.12.1",
      defaultElement: "<input>",
      widgetEventPrefix: "spin",
      options: {
        classes: {
          "ui-spinner": "ui-corner-all",
          "ui-spinner-down": "ui-corner-br",
          "ui-spinner-up": "ui-corner-tr"
        },
        culture: null,
        icons: {
          down: "ui-icon-triangle-1-s",
          up: "ui-icon-triangle-1-n"
        },
        incremental: !0,
        max: null,
        min: null,
        numberFormat: null,
        page: 10,
        step: 1,
        change: null,
        spin: null,
        start: null,
        stop: null
      },
      _create: function () {
        this._setOption("max", this.options.max), this._setOption("min", this.options.min), this._setOption("step", this.options.step), "" !== this.value() && this._value(this.element.val(), !0), this._draw(), this._on(this._events), this._refresh(), this._on(this.window, {
          beforeunload: function () {
            this.element.removeAttr("autocomplete")
          }
        })
      },
      _getCreateOptions: function () {
        var s = this._super(),
          n = this.element;
        return x.each(["min", "max", "step"], function (t, e) {
          var i = n.attr(e);
          null != i && i.length && (s[e] = i)
        }), s
      },
      _events: {
        keydown: function (t) {
          this._start(t) && this._keydown(t) && t.preventDefault()
        },
        keyup: "_stop",
        focus: function () {
          this.previous = this.element.val()
        },
        blur: function (t) {
          this.cancelBlur ? delete this.cancelBlur : (this._stop(), this._refresh(), this.previous !== this.element.val() && this._trigger("change", t))
        },
        mousewheel: function (t, e) {
          if (e) {
            if (!this.spinning && !this._start(t)) return !1;
            this._spin((0 < e ? 1 : -1) * this.options.step, t), clearTimeout(this.mousewheelTimer), this.mousewheelTimer = this._delay(function () {
              this.spinning && this._stop(t)
            }, 100), t.preventDefault()
          }
        },
        "mousedown .ui-spinner-button": function (t) {
          var e;

          function i() {
            this.element[0] === x.ui.safeActiveElement(this.document[0]) || (this.element.trigger("focus"), this.previous = e, this._delay(function () {
              this.previous = e
            }))
          }
          e = this.element[0] === x.ui.safeActiveElement(this.document[0]) ? this.previous : this.element.val(), t.preventDefault(), i.call(this), this.cancelBlur = !0, this._delay(function () {
            delete this.cancelBlur, i.call(this)
          }), !1 !== this._start(t) && this._repeat(null, x(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
        },
        "mouseup .ui-spinner-button": "_stop",
        "mouseenter .ui-spinner-button": function (t) {
          if (x(t.currentTarget).hasClass("ui-state-active")) return !1 !== this._start(t) && void this._repeat(null, x(t.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, t)
        },
        "mouseleave .ui-spinner-button": "_stop"
      },
      _enhance: function () {
        this.uiSpinner = this.element.attr("autocomplete", "off").wrap("<span>").parent().append("<a></a><a></a>")
      },
      _draw: function () {
        this._enhance(), this._addClass(this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content"), this._addClass("ui-spinner-input"), this.element.attr("role", "spinbutton"), this.buttons = this.uiSpinner.children("a").attr("tabIndex", -1).attr("aria-hidden", !0).button({
          classes: {
            "ui-button": ""
          }
        }), this._removeClass(this.buttons, "ui-corner-all"), this._addClass(this.buttons.first(), "ui-spinner-button ui-spinner-up"), this._addClass(this.buttons.last(), "ui-spinner-button ui-spinner-down"), this.buttons.first().button({
          icon: this.options.icons.up,
          showLabel: !1
        }), this.buttons.last().button({
          icon: this.options.icons.down,
          showLabel: !1
        }), this.buttons.height() > Math.ceil(.5 * this.uiSpinner.height()) && 0 < this.uiSpinner.height() && this.uiSpinner.height(this.uiSpinner.height())
      },
      _keydown: function (t) {
        var e = this.options,
          i = x.ui.keyCode;
        switch (t.keyCode) {
          case i.UP:
            return this._repeat(null, 1, t), !0;
          case i.DOWN:
            return this._repeat(null, -1, t), !0;
          case i.PAGE_UP:
            return this._repeat(null, e.page, t), !0;
          case i.PAGE_DOWN:
            return this._repeat(null, -e.page, t), !0
        }
        return !1
      },
      _start: function (t) {
        return !(!this.spinning && !1 === this._trigger("start", t) || (this.counter || (this.counter = 1), this.spinning = !0, 0))
      },
      _repeat: function (t, e, i) {
        t = t || 500, clearTimeout(this.timer), this.timer = this._delay(function () {
          this._repeat(40, e, i)
        }, t), this._spin(e * this.options.step, i)
      },
      _spin: function (t, e) {
        var i = this.value() || 0;
        this.counter || (this.counter = 1), i = this._adjustValue(i + t * this._increment(this.counter)), this.spinning && !1 === this._trigger("spin", e, {
          value: i
        }) || (this._value(i), this.counter++)
      },
      _increment: function (t) {
        var e = this.options.incremental;
        return e ? x.isFunction(e) ? e(t) : Math.floor(t * t * t / 5e4 - t * t / 500 + 17 * t / 200 + 1) : 1
      },
      _precision: function () {
        var t = this._precisionOf(this.options.step);
        return t = null !== this.options.min ? Math.max(t, this._precisionOf(this.options.min)) : t
      },
      _precisionOf: function (t) {
        var e = t.toString(),
          t = e.indexOf(".");
        return -1 === t ? 0 : e.length - t - 1
      },
      _adjustValue: function (t) {
        var e, i = this.options,
          s = t - (e = null !== i.min ? i.min : 0);
        return t = e + Math.round(s / i.step) * i.step, t = parseFloat(t.toFixed(this._precision())), null !== i.max && t > i.max ? i.max : null !== i.min && t < i.min ? i.min : t
      },
      _stop: function (t) {
        this.spinning && (clearTimeout(this.timer), clearTimeout(this.mousewheelTimer), this.counter = 0, this.spinning = !1, this._trigger("stop", t))
      },
      _setOption: function (t, e) {
        var i;
        if ("culture" === t || "numberFormat" === t) return i = this._parse(this.element.val()), this.options[t] = e, void this.element.val(this._format(i));
        "max" !== t && "min" !== t && "step" !== t || "string" == typeof e && (e = this._parse(e)), "icons" === t && (i = this.buttons.first().find(".ui-icon"), this._removeClass(i, null, this.options.icons.up), this._addClass(i, null, e.up), i = this.buttons.last().find(".ui-icon"), this._removeClass(i, null, this.options.icons.down), this._addClass(i, null, e.down)), this._super(t, e)
      },
      _setOptionDisabled: function (t) {
        this._super(t), this._toggleClass(this.uiSpinner, null, "ui-state-disabled", !!t), this.element.prop("disabled", !!t), this.buttons.button(t ? "disable" : "enable")
      },
      _setOptions: nt(function (t) {
        this._super(t)
      }),
      _parse: function (t) {
        return "" === (t = "string" == typeof t && "" !== t ? window.Globalize && this.options.numberFormat ? Globalize.parseFloat(t, 10, this.options.culture) : +t : t) || isNaN(t) ? null : t
      },
      _format: function (t) {
        return "" === t ? "" : window.Globalize && this.options.numberFormat ? Globalize.format(t, this.options.numberFormat, this.options.culture) : t
      },
      _refresh: function () {
        this.element.attr({
          "aria-valuemin": this.options.min,
          "aria-valuemax": this.options.max,
          "aria-valuenow": this._parse(this.element.val())
        })
      },
      isValid: function () {
        var t = this.value();
        return null !== t && t === this._adjustValue(t)
      },
      _value: function (t, e) {
        var i;
        "" !== t && null !== (i = this._parse(t)) && (e || (i = this._adjustValue(i)), t = this._format(i)), this.element.val(t), this._refresh()
      },
      _destroy: function () {
        this.element.prop("disabled", !1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"), this.uiSpinner.replaceWith(this.element)
      },
      stepUp: nt(function (t) {
        this._stepUp(t)
      }),
      _stepUp: function (t) {
        this._start() && (this._spin((t || 1) * this.options.step), this._stop())
      },
      stepDown: nt(function (t) {
        this._stepDown(t)
      }),
      _stepDown: function (t) {
        this._start() && (this._spin((t || 1) * -this.options.step), this._stop())
      },
      pageUp: nt(function (t) {
        this._stepUp((t || 1) * this.options.page)
      }),
      pageDown: nt(function (t) {
        this._stepDown((t || 1) * this.options.page)
      }),
      value: function (t) {
        if (!arguments.length) return this._parse(this.element.val());
        nt(this._value).call(this, t)
      },
      widget: function () {
        return this.uiSpinner
      }
    }), !1 !== x.uiBackCompat && x.widget("ui.spinner", x.ui.spinner, {
      _enhance: function () {
        this.uiSpinner = this.element.attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())
      },
      _uiSpinnerHtml: function () {
        return "<span>"
      },
      _buttonHtml: function () {
        return "<a></a><a></a>"
      }
    }), x.ui.spinner, x.widget("ui.tabs", {
      version: "1.12.1",
      delay: 300,
      options: {
        active: null,
        classes: {
          "ui-tabs": "ui-corner-all",
          "ui-tabs-nav": "ui-corner-all",
          "ui-tabs-panel": "ui-corner-bottom",
          "ui-tabs-tab": "ui-corner-top"
        },
        collapsible: !1,
        event: "click",
        heightStyle: "content",
        hide: null,
        show: null,
        activate: null,
        beforeActivate: null,
        beforeLoad: null,
        load: null
      },
      _isLocal: (et = /#.*$/, function (t) {
        var e = t.href.replace(et, ""),
          i = location.href.replace(et, "");
        try {
          e = decodeURIComponent(e)
        } catch (t) {}
        try {
          i = decodeURIComponent(i)
        } catch (t) {}
        return 1 < t.hash.length && e === i
      }),
      _create: function () {
        var e = this,
          t = this.options;
        this.running = !1, this._addClass("ui-tabs", "ui-widget ui-widget-content"), this._toggleClass("ui-tabs-collapsible", null, t.collapsible), this._processTabs(), t.active = this._initialActive(), x.isArray(t.disabled) && (t.disabled = x.unique(t.disabled.concat(x.map(this.tabs.filter(".ui-state-disabled"), function (t) {
          return e.tabs.index(t)
        }))).sort()), !1 !== this.options.active && this.anchors.length ? this.active = this._findActive(t.active) : this.active = x(), this._refresh(), this.active.length && this.load(t.active)
      },
      _initialActive: function () {
        var i = this.options.active,
          t = this.options.collapsible,
          s = location.hash.substring(1);
        return null === i && (s && this.tabs.each(function (t, e) {
          if (x(e).attr("aria-controls") === s) return i = t, !1
        }), null !== (i = null === i ? this.tabs.index(this.tabs.filter(".ui-tabs-active")) : i) && -1 !== i || (i = !!this.tabs.length && 0)), !1 !== i && -1 === (i = this.tabs.index(this.tabs.eq(i))) && (i = !t && 0), i = !t && !1 === i && this.anchors.length ? 0 : i
      },
      _getCreateEventData: function () {
        return {
          tab: this.active,
          panel: this.active.length ? this._getPanelForTab(this.active) : x()
        }
      },
      _tabKeydown: function (t) {
        var e = x(x.ui.safeActiveElement(this.document[0])).closest("li"),
          i = this.tabs.index(e),
          s = !0;
        if (!this._handlePageNav(t)) {
          switch (t.keyCode) {
            case x.ui.keyCode.RIGHT:
            case x.ui.keyCode.DOWN:
              i++;
              break;
            case x.ui.keyCode.UP:
            case x.ui.keyCode.LEFT:
              s = !1, i--;
              break;
            case x.ui.keyCode.END:
              i = this.anchors.length - 1;
              break;
            case x.ui.keyCode.HOME:
              i = 0;
              break;
            case x.ui.keyCode.SPACE:
              return t.preventDefault(), clearTimeout(this.activating), void this._activate(i);
            case x.ui.keyCode.ENTER:
              return t.preventDefault(), clearTimeout(this.activating), void this._activate(i !== this.options.active && i);
            default:
              return
          }
          t.preventDefault(), clearTimeout(this.activating), i = this._focusNextTab(i, s), t.ctrlKey || t.metaKey || (e.attr("aria-selected", "false"), this.tabs.eq(i).attr("aria-selected", "true"), this.activating = this._delay(function () {
            this.option("active", i)
          }, this.delay))
        }
      },
      _panelKeydown: function (t) {
        this._handlePageNav(t) || t.ctrlKey && t.keyCode === x.ui.keyCode.UP && (t.preventDefault(), this.active.trigger("focus"))
      },
      _handlePageNav: function (t) {
        return t.altKey && t.keyCode === x.ui.keyCode.PAGE_UP ? (this._activate(this._focusNextTab(this.options.active - 1, !1)), !0) : t.altKey && t.keyCode === x.ui.keyCode.PAGE_DOWN ? (this._activate(this._focusNextTab(this.options.active + 1, !0)), !0) : void 0
      },
      _findNextTab: function (t, e) {
        for (var i = this.tabs.length - 1; - 1 !== x.inArray(t = (t = i < t ? 0 : t) < 0 ? i : t, this.options.disabled);) t = e ? t + 1 : t - 1;
        return t
      },
      _focusNextTab: function (t, e) {
        return t = this._findNextTab(t, e), this.tabs.eq(t).trigger("focus"), t
      },
      _setOption: function (t, e) {
        "active" !== t ? (this._super(t, e), "collapsible" === t && (this._toggleClass("ui-tabs-collapsible", null, e), e || !1 !== this.options.active || this._activate(0)), "event" === t && this._setupEvents(e), "heightStyle" === t && this._setupHeightStyle(e)) : this._activate(e)
      },
      _sanitizeSelector: function (t) {
        return t ? t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : ""
      },
      refresh: function () {
        var t = this.options,
          e = this.tablist.children(":has(a[href])");
        t.disabled = x.map(e.filter(".ui-state-disabled"), function (t) {
          return e.index(t)
        }), this._processTabs(), !1 !== t.active && this.anchors.length ? this.active.length && !x.contains(this.tablist[0], this.active[0]) ? this.tabs.length === t.disabled.length ? (t.active = !1, this.active = x()) : this._activate(this._findNextTab(Math.max(0, t.active - 1), !1)) : t.active = this.tabs.index(this.active) : (t.active = !1, this.active = x()), this._refresh()
      },
      _refresh: function () {
        this._setOptionDisabled(this.options.disabled), this._setupEvents(this.options.event), this._setupHeightStyle(this.options.heightStyle), this.tabs.not(this.active).attr({
          "aria-selected": "false",
          "aria-expanded": "false",
          tabIndex: -1
        }), this.panels.not(this._getPanelForTab(this.active)).hide().attr({
          "aria-hidden": "true"
        }), this.active.length ? (this.active.attr({
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        }), this._addClass(this.active, "ui-tabs-active", "ui-state-active"), this._getPanelForTab(this.active).show().attr({
          "aria-hidden": "false"
        })) : this.tabs.eq(0).attr("tabIndex", 0)
      },
      _processTabs: function () {
        var l = this,
          t = this.tabs,
          e = this.anchors,
          i = this.panels;
        this.tablist = this._getList().attr("role", "tablist"), this._addClass(this.tablist, "ui-tabs-nav", "ui-helper-reset ui-helper-clearfix ui-widget-header"), this.tablist.on("mousedown" + this.eventNamespace, "> li", function (t) {
          x(this).is(".ui-state-disabled") && t.preventDefault()
        }).on("focus" + this.eventNamespace, ".ui-tabs-anchor", function () {
          x(this).closest("li").is(".ui-state-disabled") && this.blur()
        }), this.tabs = this.tablist.find("> li:has(a[href])").attr({
          role: "tab",
          tabIndex: -1
        }), this._addClass(this.tabs, "ui-tabs-tab", "ui-state-default"), this.anchors = this.tabs.map(function () {
          return x("a", this)[0]
        }).attr({
          role: "presentation",
          tabIndex: -1
        }), this._addClass(this.anchors, "ui-tabs-anchor"), this.panels = x(), this.anchors.each(function (t, e) {
          var i, s, n, a = x(e).uniqueId().attr("id"),
            o = x(e).closest("li"),
            r = o.attr("aria-controls");
          l._isLocal(e) ? (n = (i = e.hash).substring(1), s = l.element.find(l._sanitizeSelector(i))) : (i = "#" + (n = o.attr("aria-controls") || x({}).uniqueId()[0].id), (s = l.element.find(i)).length || (s = l._createPanel(n)).insertAfter(l.panels[t - 1] || l.tablist), s.attr("aria-live", "polite")), s.length && (l.panels = l.panels.add(s)), r && o.data("ui-tabs-aria-controls", r), o.attr({
            "aria-controls": n,
            "aria-labelledby": a
          }), s.attr("aria-labelledby", a)
        }), this.panels.attr("role", "tabpanel"), this._addClass(this.panels, "ui-tabs-panel", "ui-widget-content"), t && (this._off(t.not(this.tabs)), this._off(e.not(this.anchors)), this._off(i.not(this.panels)))
      },
      _getList: function () {
        return this.tablist || this.element.find("ol, ul").eq(0)
      },
      _createPanel: function (t) {
        return x("<div>").attr("id", t).data("ui-tabs-destroy", !0)
      },
      _setOptionDisabled: function (t) {
        var e, i;
        for (x.isArray(t) && (t.length ? t.length === this.anchors.length && (t = !0) : t = !1), i = 0; e = this.tabs[i]; i++) e = x(e), !0 === t || -1 !== x.inArray(i, t) ? (e.attr("aria-disabled", "true"), this._addClass(e, null, "ui-state-disabled")) : (e.removeAttr("aria-disabled"), this._removeClass(e, null, "ui-state-disabled"));
        this.options.disabled = t, this._toggleClass(this.widget(), this.widgetFullName + "-disabled", null, !0 === t)
      },
      _setupEvents: function (t) {
        var i = {};
        t && x.each(t.split(" "), function (t, e) {
          i[e] = "_eventHandler"
        }), this._off(this.anchors.add(this.tabs).add(this.panels)), this._on(!0, this.anchors, {
          click: function (t) {
            t.preventDefault()
          }
        }), this._on(this.anchors, i), this._on(this.tabs, {
          keydown: "_tabKeydown"
        }), this._on(this.panels, {
          keydown: "_panelKeydown"
        }), this._focusable(this.tabs), this._hoverable(this.tabs)
      },
      _setupHeightStyle: function (t) {
        var i, e = this.element.parent();
        "fill" === t ? (i = e.height(), i -= this.element.outerHeight() - this.element.height(), this.element.siblings(":visible").each(function () {
          var t = x(this),
            e = t.css("position");
          "absolute" !== e && "fixed" !== e && (i -= t.outerHeight(!0))
        }), this.element.children().not(this.panels).each(function () {
          i -= x(this).outerHeight(!0)
        }), this.panels.each(function () {
          x(this).height(Math.max(0, i - x(this).innerHeight() + x(this).height()))
        }).css("overflow", "auto")) : "auto" === t && (i = 0, this.panels.each(function () {
          i = Math.max(i, x(this).height("").height())
        }).height(i))
      },
      _eventHandler: function (t) {
        var e = this.options,
          i = this.active,
          s = x(t.currentTarget).closest("li"),
          n = s[0] === i[0],
          a = n && e.collapsible,
          o = a ? x() : this._getPanelForTab(s),
          r = i.length ? this._getPanelForTab(i) : x(),
          i = {
            oldTab: i,
            oldPanel: r,
            newTab: a ? x() : s,
            newPanel: o
          };
        t.preventDefault(), s.hasClass("ui-state-disabled") || s.hasClass("ui-tabs-loading") || this.running || n && !e.collapsible || !1 === this._trigger("beforeActivate", t, i) || (e.active = !a && this.tabs.index(s), this.active = n ? x() : s, this.xhr && this.xhr.abort(), r.length || o.length || x.error("jQuery UI Tabs: Mismatching fragment identifier."), o.length && this.load(this.tabs.index(s), t), this._toggle(t, i))
      },
      _toggle: function (t, e) {
        var i = this,
          s = e.newPanel,
          n = e.oldPanel;

        function a() {
          i.running = !1, i._trigger("activate", t, e)
        }

        function o() {
          i._addClass(e.newTab.closest("li"), "ui-tabs-active", "ui-state-active"), s.length && i.options.show ? i._show(s, i.options.show, a) : (s.show(), a())
        }
        this.running = !0, n.length && this.options.hide ? this._hide(n, this.options.hide, function () {
          i._removeClass(e.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), o()
        }) : (this._removeClass(e.oldTab.closest("li"), "ui-tabs-active", "ui-state-active"), n.hide(), o()), n.attr("aria-hidden", "true"), e.oldTab.attr({
          "aria-selected": "false",
          "aria-expanded": "false"
        }), s.length && n.length ? e.oldTab.attr("tabIndex", -1) : s.length && this.tabs.filter(function () {
          return 0 === x(this).attr("tabIndex")
        }).attr("tabIndex", -1), s.attr("aria-hidden", "false"), e.newTab.attr({
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        })
      },
      _activate: function (t) {
        var t = this._findActive(t);
        t[0] !== this.active[0] && (t = (t = !t.length ? this.active : t).find(".ui-tabs-anchor")[0], this._eventHandler({
          target: t,
          currentTarget: t,
          preventDefault: x.noop
        }))
      },
      _findActive: function (t) {
        return !1 === t ? x() : this.tabs.eq(t)
      },
      _getIndex: function (t) {
        return t = "string" == typeof t ? this.anchors.index(this.anchors.filter("[href$='" + x.ui.escapeSelector(t) + "']")) : t
      },
      _destroy: function () {
        this.xhr && this.xhr.abort(), this.tablist.removeAttr("role").off(this.eventNamespace), this.anchors.removeAttr("role tabIndex").removeUniqueId(), this.tabs.add(this.panels).each(function () {
          x.data(this, "ui-tabs-destroy") ? x(this).remove() : x(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")
        }), this.tabs.each(function () {
          var t = x(this),
            e = t.data("ui-tabs-aria-controls");
          e ? t.attr("aria-controls", e).removeData("ui-tabs-aria-controls") : t.removeAttr("aria-controls")
        }), this.panels.show(), "content" !== this.options.heightStyle && this.panels.css("height", "")
      },
      enable: function (i) {
        var t = this.options.disabled;
        !1 !== t && (t = void 0 !== i && (i = this._getIndex(i), x.isArray(t) ? x.map(t, function (t) {
          return t !== i ? t : null
        }) : x.map(this.tabs, function (t, e) {
          return e !== i ? e : null
        })), this._setOptionDisabled(t))
      },
      disable: function (t) {
        var e = this.options.disabled;
        if (!0 !== e) {
          if (void 0 === t) e = !0;
          else {
            if (t = this._getIndex(t), -1 !== x.inArray(t, e)) return;
            e = x.isArray(e) ? x.merge([t], e).sort() : [t]
          }
          this._setOptionDisabled(e)
        }
      },
      load: function (t, s) {
        t = this._getIndex(t);

        function n(t, e) {
          "abort" === e && a.panels.stop(!1, !0), a._removeClass(i, "ui-tabs-loading"), o.removeAttr("aria-busy"), t === a.xhr && delete a.xhr
        }
        var a = this,
          i = this.tabs.eq(t),
          t = i.find(".ui-tabs-anchor"),
          o = this._getPanelForTab(i),
          r = {
            tab: i,
            panel: o
          };
        this._isLocal(t[0]) || (this.xhr = x.ajax(this._ajaxSettings(t, s, r)), this.xhr && "canceled" !== this.xhr.statusText && (this._addClass(i, "ui-tabs-loading"), o.attr("aria-busy", "true"), this.xhr.done(function (t, e, i) {
          setTimeout(function () {
            o.html(t), a._trigger("load", s, r), n(i, e)
          }, 1)
        }).fail(function (t, e) {
          setTimeout(function () {
            n(t, e)
          }, 1)
        })))
      },
      _ajaxSettings: function (t, i, s) {
        var n = this;
        return {
          url: t.attr("href").replace(/#.*$/, ""),
          beforeSend: function (t, e) {
            return n._trigger("beforeLoad", i, x.extend({
              jqXHR: t,
              ajaxSettings: e
            }, s))
          }
        }
      },
      _getPanelForTab: function (t) {
        t = x(t).attr("aria-controls");
        return this.element.find(this._sanitizeSelector("#" + t))
      }
    }), !1 !== x.uiBackCompat && x.widget("ui.tabs", x.ui.tabs, {
      _processTabs: function () {
        this._superApply(arguments), this._addClass(this.tabs, "ui-tab")
      }
    }), x.ui.tabs, x.widget("ui.tooltip", {
      version: "1.12.1",
      options: {
        classes: {
          "ui-tooltip": "ui-corner-all ui-widget-shadow"
        },
        content: function () {
          var t = x(this).attr("title") || "";
          return x("<a>").text(t).html()
        },
        hide: !0,
        items: "[title]:not([disabled])",
        position: {
          my: "left top+15",
          at: "left bottom",
          collision: "flipfit flip"
        },
        show: !0,
        track: !1,
        close: null,
        open: null
      },
      _addDescribedBy: function (t, e) {
        var i = (t.attr("aria-describedby") || "").split(/\s+/);
        i.push(e), t.data("ui-tooltip-id", e).attr("aria-describedby", x.trim(i.join(" ")))
      },
      _removeDescribedBy: function (t) {
        var e = t.data("ui-tooltip-id"),
          i = (t.attr("aria-describedby") || "").split(/\s+/),
          e = x.inArray(e, i); - 1 !== e && i.splice(e, 1), t.removeData("ui-tooltip-id"), (i = x.trim(i.join(" "))) ? t.attr("aria-describedby", i) : t.removeAttr("aria-describedby")
      },
      _create: function () {
        this._on({
          mouseover: "open",
          focusin: "open"
        }), this.tooltips = {}, this.parents = {}, this.liveRegion = x("<div>").attr({
          role: "log",
          "aria-live": "assertive",
          "aria-relevant": "additions"
        }).appendTo(this.document[0].body), this._addClass(this.liveRegion, null, "ui-helper-hidden-accessible"), this.disabledTitles = x([])
      },
      _setOption: function (t, e) {
        var i = this;
        this._super(t, e), "content" === t && x.each(this.tooltips, function (t, e) {
          i._updateContent(e.element)
        })
      },
      _setOptionDisabled: function (t) {
        this[t ? "_disable" : "_enable"]()
      },
      _disable: function () {
        var s = this;
        x.each(this.tooltips, function (t, e) {
          var i = x.Event("blur");
          i.target = i.currentTarget = e.element[0], s.close(i, !0)
        }), this.disabledTitles = this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function () {
          var t = x(this);
          if (t.is("[title]")) return t.data("ui-tooltip-title", t.attr("title")).removeAttr("title")
        }))
      },
      _enable: function () {
        this.disabledTitles.each(function () {
          var t = x(this);
          t.data("ui-tooltip-title") && t.attr("title", t.data("ui-tooltip-title"))
        }), this.disabledTitles = x([])
      },
      open: function (t) {
        var i = this,
          e = x(t ? t.target : this.element).closest(this.options.items);
        e.length && !e.data("ui-tooltip-id") && (e.attr("title") && e.data("ui-tooltip-title", e.attr("title")), e.data("ui-tooltip-open", !0), t && "mouseover" === t.type && e.parents().each(function () {
          var t, e = x(this);
          e.data("ui-tooltip-open") && ((t = x.Event("blur")).target = t.currentTarget = this, i.close(t, !0)), e.attr("title") && (e.uniqueId(), i.parents[this.id] = {
            element: this,
            title: e.attr("title")
          }, e.attr("title", ""))
        }), this._registerCloseHandlers(t, e), this._updateContent(e, t))
      },
      _updateContent: function (e, i) {
        var t = this.options.content,
          s = this,
          n = i ? i.type : null;
        if ("string" == typeof t || t.nodeType || t.jquery) return this._open(i, e, t);
        (t = t.call(e[0], function (t) {
          s._delay(function () {
            e.data("ui-tooltip-open") && (i && (i.type = n), this._open(i, e, t))
          })
        })) && this._open(i, e, t)
      },
      _open: function (t, e, i) {
        var s, n, a, o = x.extend({}, this.options.position);

        function r(t) {
          o.of = t, n.is(":hidden") || n.position(o)
        }
        i && ((s = this._find(e)) ? s.tooltip.find(".ui-tooltip-content").html(i) : (e.is("[title]") && (t && "mouseover" === t.type ? e.attr("title", "") : e.removeAttr("title")), s = this._tooltip(e), n = s.tooltip, this._addDescribedBy(e, n.attr("id")), n.find(".ui-tooltip-content").html(i), this.liveRegion.children().hide(), (i = x("<div>").html(n.find(".ui-tooltip-content").html())).removeAttr("name").find("[name]").removeAttr("name"), i.removeAttr("id").find("[id]").removeAttr("id"), i.appendTo(this.liveRegion), this.options.track && t && /^mouse/.test(t.type) ? (this._on(this.document, {
          mousemove: r
        }), r(t)) : n.position(x.extend({
          of: e
        }, this.options.position)), n.hide(), this._show(n, this.options.show), this.options.track && this.options.show && this.options.show.delay && (a = this.delayedShow = setInterval(function () {
          n.is(":visible") && (r(o.of), clearInterval(a))
        }, x.fx.interval)), this._trigger("open", t, {
          tooltip: n
        })))
      },
      _registerCloseHandlers: function (t, e) {
        var i = {
          keyup: function (t) {
            t.keyCode === x.ui.keyCode.ESCAPE && ((t = x.Event(t)).currentTarget = e[0], this.close(t, !0))
          }
        };
        e[0] !== this.element[0] && (i.remove = function () {
          this._removeTooltip(this._find(e).tooltip)
        }), t && "mouseover" !== t.type || (i.mouseleave = "close"), t && "focusin" !== t.type || (i.focusout = "close"), this._on(!0, e, i)
      },
      close: function (t) {
        var e, i = this,
          s = x(t ? t.currentTarget : this.element),
          n = this._find(s);
        n ? (e = n.tooltip, n.closing || (clearInterval(this.delayedShow), s.data("ui-tooltip-title") && !s.attr("title") && s.attr("title", s.data("ui-tooltip-title")), this._removeDescribedBy(s), n.hiding = !0, e.stop(!0), this._hide(e, this.options.hide, function () {
          i._removeTooltip(x(this))
        }), s.removeData("ui-tooltip-open"), this._off(s, "mouseleave focusout keyup"), s[0] !== this.element[0] && this._off(s, "remove"), this._off(this.document, "mousemove"), t && "mouseleave" === t.type && x.each(this.parents, function (t, e) {
          x(e.element).attr("title", e.title), delete i.parents[t]
        }), n.closing = !0, this._trigger("close", t, {
          tooltip: e
        }), n.hiding || (n.closing = !1))) : s.removeData("ui-tooltip-open")
      },
      _tooltip: function (t) {
        var e = x("<div>").attr("role", "tooltip"),
          i = x("<div>").appendTo(e),
          s = e.uniqueId().attr("id");
        return this._addClass(i, "ui-tooltip-content"), this._addClass(e, "ui-tooltip", "ui-widget ui-widget-content"), e.appendTo(this._appendTo(t)), this.tooltips[s] = {
          element: t,
          tooltip: e
        }
      },
      _find: function (t) {
        t = t.data("ui-tooltip-id");
        return t ? this.tooltips[t] : null
      },
      _removeTooltip: function (t) {
        t.remove(), delete this.tooltips[t.attr("id")]
      },
      _appendTo: function (t) {
        t = t.closest(".ui-front, dialog");
        return t = !t.length ? this.document[0].body : t
      },
      _destroy: function () {
        var s = this;
        x.each(this.tooltips, function (t, e) {
          var i = x.Event("blur"),
            e = e.element;
          i.target = i.currentTarget = e[0], s.close(i, !0), x("#" + t).remove(), e.data("ui-tooltip-title") && (e.attr("title") || e.attr("title", e.data("ui-tooltip-title")), e.removeData("ui-tooltip-title"))
        }), this.liveRegion.remove()
      }
    }), !1 !== x.uiBackCompat && x.widget("ui.tooltip", x.ui.tooltip, {
      options: {
        tooltipClass: null
      },
      _tooltip: function () {
        var t = this._superApply(arguments);
        return this.options.tooltipClass && t.tooltip.addClass(this.options.tooltipClass), t
      }
    }), x.ui.tooltip
  }), $("#clearSearch").on("click", function () {
    $(this).hide()
  }), $("#clearSearchMobile").on("click", function () {
    $(this).hide()
  }), $(document).ready(function () {
    setTimeout(function () {
      $(".pgd-hero-carousel").css("display", "block"), $(".pgd-hero-carousel").slick({
        arrows: !0,
        dots: !0,
        autoplay: !0,
        autoplaySpeed: 3e3,
        prevArrow: '<button type="button" class="style-prev slick-prev1"><img src="./assets/images/icon-left.svg"/></button>',
        nextArrow: '<button type="button" class="style-next slick-next1"><img src="./assets/images/icon-left.svg"/></button>'
      }), $(".pgd-carousel-triple").css("display", "block"), $(".pgd-carousel-triple").slick({
        slidesToShow: 3,
        slidesToScroll: 1,
        arrows: !0,
        dots: !1,
        prevArrow: '<button type="button" class="style-prev slick-prev3"><img src="./assets/images/icon-left.svg"/></button>',
        nextArrow: '<button type="button" class="style-next slick-next3"><img src="./assets/images/icon-left.svg"/></button>',
        responsive: [{
          breakpoint: 768,
          settings: {
            slidesToShow: 1,
            slidesToScroll: 1,
            dots: !0
          }
        }]
      }), $(".pgd-carousel-triple-card").css("display", "block"), $(".pgd-carousel-triple-card").slick({
        slidesToShow: 2,
        slidesToScroll: 1,
        arrows: !0,
        dots: !0,
        prevArrow: '<button type="button" class="style-prev slick-prev3"><img src="./assets/images/icon-left.svg"/></button>',
        nextArrow: '<button type="button" class="style-next slick-next3"><img src="./assets/images/icon-left.svg"/></button>',
        responsive: [{
          breakpoint: 768,
          settings: {
            slidesToShow: 1,
            slidesToScroll: 4,
            dots: !0
          }
        }]
      }), $(".pgd-carousel-promo").css("display", "block"), $(".pgd-carousel-promo").slick({
        arrows: !0,
        dots: !0,
        prevArrow: '<button type="button" class="style-prev slick-prev2"><img src="./assets/images/icon-left.svg"/></button>',
        nextArrow: '<button type="button" class="style-next slick-next2"><img src="./assets/images/icon-left.svg"/></button>',
        responsive: [{
          breakpoint: 768,
          settings: {
            dots: !0
          }
        }]
      })
    }, 100)
  }), $(".hero-carousel").slick({
    arrows: !0,
    dots: !0,
    autoplay: !0,
    autoplaySpeed: 3e3,
    slidesToShow: 1,
    slidesToScroll: 1,
    centerMode: !0,
    variableWidth: !0,
    infinite: !0,
    cssEase: "linear",
    initialSlide: 1,
    prevArrow: '<button type="button" class="style-prev slick-prev1"><img src="./assets/images/icon-left.svg" onerror="this.src=`./assets/images/icon-left.svg` || `./assets/images/icon-left.svg`"/></button>',
    nextArrow: '<button type="button" class="style-next slick-next1"><img src="./assets/images/icon-left.svg" onerror="this.src=`./assets/images/icon-left.svg` || `./assets/images/icon-left.svg`"/></button>',
    responsive: [{
      breakpoint: 768,
      settings: {
        arrows: !1
      }
    }]
  }), $(".navbar-toggler").on("click", function () {
    $(".navbar-toggler > span").hasClass("showed") ? ($(".navbar-toggler > span").removeClass("showed"), $(".navbar-toggler > span").addClass("hided")) : $(".navbar-toggler > span").hasClass("hided") && ($(".navbar-toggler > span").removeClass("hided"), $(".navbar-toggler > span").addClass("showed"))
  }), $(".btn-decrement").click(function () {
    parseInt($("#sumGold").val()) <= 0 ? $(".btn-decrement").prop("disabled", !0) : $("#sumGold").val(parseInt($("#sumGold").val()) - 1), checkLot($("#sumGold").val())
  }), $(".btn-increment").click(function () {
    $("#sumGold").val(parseInt($("#sumGold").val()) + 1), checkLot($("#sumGold").val())
  }), $(".jenis-perhiasan").on("click", function () {
    $(".jenis-perhiasan").removeClass("active"), $(this).addClass("active")
  }), $("#show-saldo").on("click", function () {
    "flex" == $(".hide-value__dot").css("display") ? ($(".hide-value__text").show(), $(".hide-value__dot").hide(), $("#eye-saldo").attr("src", "./assets/images/eye-off.svg")) : ($(".hide-value__text").hide(), $(".hide-value__dot").css("display", "flex"), $("#eye-saldo").attr("src", "./assets/images/eye-on.svg"))
  }), $(".deck-product-riwayat").slick({
    arrows: !0,
    dots: !0,
    slidesToShow: 5,
    slidesToScroll: 1,
    infinite: !1,
    prevArrow: '<button type="button" class="style-prev slick-prev1 prev-hide display-none"><img src="./assets/images/icon-left.svg" onerror="this.src=`./assets/images/icon-left.svg` || `./assets/images/icon-left.svg`"/></button>',
    nextArrow: '<button type="button" class="style-next slick-next1 next-hide"><img src="./assets/images/icon-left.svg" onerror="this.src=`./assets/images/icon-left.svg` || `./assets/images/icon-left.svg`"/></button>',
    responsive: [{
      breakpoint: 1124,
      settings: {
        slidesToShow: 3
      }
    }, {
      breakpoint: 768,
      settings: {
        slidesToShow: 4
      }
    }, {
      breakpoint: 385,
      settings: {
        slidesToShow: 3.8
      }
    }, {
      breakpoint: 361,
      settings: {
        slidesToShow: 3.6
      }
    }, {
      breakpoint: 361,
      settings: {
        slidesToShow: 3.6
      }
    }, {
      breakpoint: 352,
      settings: {
        slidesToShow: 3.5
      }
    }, {
      breakpoint: 339,
      settings: {
        slidesToShow: 3
      }
    }, {
      breakpoint: 296,
      settings: {
        slidesToShow: 2.7
      }
    }]
  }), $(".deck-product-riwayat").on("beforeChange", function (t, e, i, s) {
    s == e.$dots[0].children.length - 1 ? ($(".next-hide").attr("style", "display:none;"), $(".prev-hide").attr("style", "display:flex;")) : s != e.slideCount - 1 && 0 != s ? ($(".next-hide").attr("style", "display:flex;"), $(".prev-hide").removeClass("display-none"), $(".prev-hide").attr("style", "display:flex;")) : 0 != i && 0 != s || ($(".next-hide").attr("style", "display:flex;"), $(".prev-hide").attr("style", "display:none;"))
  }), $(".date-field").keyup(function () {
    if (this.value.length == this.maxLength && $(this).next(".date-field").focus(), document.forms.setDateBirth.checkValidity()) {
      var e = $("#date").val(),
        i = $("#month").val();
      let t;
      if (parseInt(i) < 13) switch (i) {
        case "01":
          t = "Januari";
          break;
        case "02":
          t = "Februari";
          break;
        case "03":
          t = "Maret";
          break;
        case "04":
          t = "April";
          break;
        case "05":
          t = "Mei";
          break;
        case "06":
          t = "Juni";
          break;
        case "07":
          t = "Juli";
          break;
        case "08":
          t = "Agustus";
          break;
        case "09":
          t = "September";
          break;
        case "10":
          t = "Oktober";
          break;
        case "11":
          t = "November";
          break;
        case "12":
          t = "Desember"
      }
      var s = $("#year").val(),
        s = `${e} ${t} ${s}`;
      parseInt(e) < 32 && parseInt(i) < 13 && 2 != parseInt(i) || parseInt(e) < 29 && 2 == parseInt(i) ? ($("#tanggalLahir").val(s), $("#tanggalLahir").change(), $("#close-modal").click()) : alert("Periksa lagi tanggal lahir anda")
    }
  }), $(".prevent-zero").on("input", function () {
    /^0/.test(this.value) && (this.value = this.value.replace(/^0/, ""))
  });
var stateHead1 = !1,
  stateHead2 = !1,
  stateHead3 = !1;

function showMenuLgProduk(t) {
  $(".head-menu__item").removeClass("show"), $(".hubungan-investor").removeClass("show"), $(".profile-korporasi").removeClass("show"), stateHead1 ? (stateHead1 = !1, $(".produk-layanan").removeClass("show"), $(t).removeClass("show")) : (stateHead1 = !0, $(".produk-layanan").addClass("show"), $(t).addClass("show"))
}

function showMenuLgHubunganInvestor(t) {
  $(".head-menu__item").removeClass("show"), stateHead2 ? (stateHead2 = !1, $(".hubungan-investor").removeClass("show"), $(t).removeClass("show")) : (stateHead2 = !0, $(".hubungan-investor").addClass("show"), $(t).addClass("show")), $(".profile-korporasi").removeClass("show"), $(".produk-layanan").removeClass("show")
}

function showMenuLgProfile(t) {
  $(".head-menu__item").removeClass("show"), $(".hubungan-investor").removeClass("show"), stateHead3 ? (stateHead3 = !1, $(".profile-korporasi").removeClass("show"), $(t).removeClass("show")) : (stateHead3 = !0, $(".profile-korporasi").addClass("show"), $(t).addClass("show")), $(".produk-layanan").removeClass("show")
}

function showMenu() {
  $(".navbar-collapse-pgd").toggle(), $(".pgd-corporate").hasClass("hided") ? ($(".pgd-corporate").removeClass("hided"), $(".pgd-corporate").addClass("showed")) : ($(".pgd-corporate").removeClass("showed"), $(".pgd-corporate").addClass("hided"))
}
$(".mobile-hide").click(function (t) {
  $(".contextual-menu").show(), t.stopPropagation()
}), $(".contextual-menu").click(function (t) {
  t.stopPropagation()
}), $(document).mouseup(function (t) {
  var e = $(".contextual-menu");
  e.is(t.target) || 0 !== e.has(t.target).length || e.hide()
}), $(".custom-accordion-input").mouseleave(function () {
  $(this).find(".accordion-button").addClass("collapsed"), $(this).find(".accordion-collapse").removeClass("show")
}), $(document).mouseup(function (t) {
  var e = $(".custom-accordion-input");
  e.is(t.target) || 0 !== e.has(t.target).length || (e.find(".accordion-button").addClass("collapsed"), e.find(".accordion-collapse").removeClass("show"))
});